// example only
// this will work for a function that has 2 inputs and 1 output, which are 32 bits wide
// this must be generated by titan for each function
import TitanComms;

module core_interface # (
    parameter INSTRUCTION_WIDTH = 8,
    parameter ADDRESS_WIDTH = 24,
    parameter VALUE_WIDTH = 32,
    parameter START_ADDRESS,
    parameter END_ADDRESS
) (
    input wire [INSTRUCTION_WIDTH-1:0] instruction,
    input wire [ADDRESS_WIDTH-1:0] address,
    input wire [VALUE_WIDTH-1:0] value,
    output wire [VALUE_WIDTH-1:0] output_value
)

    TitanComms::instruction instr_enum;

    // VALUE_WIDTH wide memory, 3 units deep
    reg [VALUE_WIDTH-1:0] value_memory [0:2];
    wire enable = (address >= START_ADDRESS) & (address <= END_ADDRESS);

    // need address in normal range to index memory, not global range
    wire [ADDRESS_WIDTH-1:0] normalised_address = END_ADDRESS - address;

    reg [VALUE_WIDTH-1:0] output_val_internal;

    always_comb begin
        // if we're being talked to
        if (enable) begin
            case instruction

                instr_enum.READ: begin
                    output_value <= value_memory[normalised_address];
                end

                instr_enum.WRITE: begin
                    value_memory[normalised_address] <= value;
                end

            endcase

        end

    end

    assign output_value = output_val_internal;


endmodule