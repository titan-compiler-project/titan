{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the Titan Compiler Project","text":"Curious about the project? <p>Check out the concept page.</p> Want to dive in? <p>See the user guide on how to get started.</p> Reference docs <p>Covers nearly everything you need to know about the compiler, communications method and the hardware modules.</p> Check out the authors <p>Visit the about page for some more info.</p> <p>Warning</p> <p>This is currently a work-in-progress compiler. Please be aware that there will be some bugs stil rumaging around in the code. </p>"},{"location":"about/","title":"About","text":"<p>Made as partial fulfilment of Masters by Research in Computer Science for the University of Lincoln by Kristaps Jurkans, supervised by Dr. Charles Fox.</p>"},{"location":"concept/","title":"The Concept","text":"<p>This compiler is based in the idea of DSAs, as talked about in Hennessy &amp; Pattersons Turing Award lecture. In essence, these devices have a highly specialised architecture, that targets one particular domain (think AI, ML, IoT) and provides a device which can perform tasks in that domain with better performance and efficiency.</p> <p>These architectures have to be custom built, and in order to achieve that we have to build some custom hardware. Instead of placing individual transistors down, we can program an FPGA using a HDL like SystemVerilog. Unfortunately, FPGAs do come with a steep learning curve, possibly dissuading people from using it. So why not attempt to make it easier to access, whilst also providing some DSA functionality?</p> <p>Python (and its variants like MicroPython) are growing in popularity, so much so that a recent StackOverflow survey had shown Python as being the 3rd most popular language. It seems like a good language to target due to that, but unfortunately it'll have to be a subset of the language so that it can map onto hardware and to also limit the scope of the compiler.</p> <p>Using SPIR-V as the intermediate language means that the front-end and back-end of the compiler can be swapped out, and the SPIR-V assembly can be compiled into something that can run on existing GPUs via OpenGL/OpenCL/Vulkan. Furthemore, SPIR-V's assembly structure mimics a dataflow graph, so we can use that to our advantage.</p> <p>With this SPIR-V assembly, we can then attempt to assemble some SystemVerilog and output this file to the user. With any luck, this SystemVerilog can be used to program the FPGA and provide the user with some custom hardware.</p>"},{"location":"license/","title":"License","text":"<p>This file is a part of the Titan Compiler Project.</p> <p>Copyright (C) 2024  Kristaps Jurkans</p> <p>This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.</p> <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.</p> <p>You should have received a copy of the GNU General Public License along with this program.  If not, see https://www.gnu.org/licenses/.</p>"},{"location":"reference-docs/pcb/","title":"FPGA Shield","text":"<p>An untested PCB design for an FPGA shield to interface with multiple microcontrollers over SPI is available in the repo. This shield is designed for the QMTech Cyclone V 5CEFA2 Core Development Board, and is very unlikely to work on other development boards. </p> <p>Features:</p> <ul> <li>Ability to connect a Raspberry Pi Pico, Teensy 3.2, ESP32 and CH341</li> <li>Header for OLED display, selectable source via jumpers</li> <li>Additional SPI headers</li> <li>I2C headers, with optional pull-up resistors</li> <li>Onboard 3.3V power supply </li> </ul>"},{"location":"reference-docs/potential-improvements/","title":"Potential improvements","text":"<p>This page serves as a way to keep track of what needs doing (i.e. what features to implement), and other potential improvements in the future to make the program more usable.</p>"},{"location":"reference-docs/potential-improvements/#on-going-to-do-list","title":"On-going to-do list","text":"<ul> <li> Arrays<ul> <li> declare size via decorator for arrays passed in as a parameter (needed because size &amp; type must be known)</li> </ul> </li> <li> Maps/loops without dependencies</li> <li> Automatic interface generation from template</li> <li> Total functional recursion</li> <li> Delayed inputs</li> <li> Rework verilog source code to use unpacked arrays in certain parts</li> </ul>"},{"location":"reference-docs/potential-improvements/#improvements","title":"Improvements","text":"<ul> <li> Rewrite in a typed language, potentially using the C-API to interface with the AST module.</li> <li> Better tests</li> <li> More varied sample code</li> <li> Add additional classes which inherit from the main Node class, and use them to correctly compile the relevant verilog code.</li> </ul>"},{"location":"reference-docs/compiler/main/","title":"Documentation for <code>main.py</code>","text":""},{"location":"reference-docs/compiler/main/#titan.main.main","title":"<code>main()</code>","text":"<p>Entry point for the program.</p> <p>Calls to handle CLI options, parsing, generating and writing.</p> Source code in <code>titan/main.py</code> <pre><code>def main():\n    \"\"\" Entry point for the program.\n\n        Calls to handle CLI options, parsing, generating and writing.\n\n    \"\"\"\n\n    args = run_argparse()\n    compiler_ctx = CompilerContext(args)\n\n\n    logging.basicConfig(\n        level=logging.DEBUG if compiler_ctx.user_wants_verbose_info() else logging.INFO,\n        handlers=[\n            logging.FileHandler(\"compiler_log.txt\"),\n            # logging.StreamHandler()\n            RichHandler(show_time=False, markup=True)\n        ],\n        # format=f\"[%(levelname)s] [%(module)s.%(funcName)s, line: %(lineno)d]: %(message)s\"\n        format=f\"%(message)s\"\n    )\n\n    logging.info(f\"--- New run, time is: {datetime.datetime.now().strftime('%d/%m/%Y %H:%M:%S')} ---\")\n    logging.debug(f\"arguments: {args}\")\n\n\n    logging.info(f\"Generating SPIR-V from {compiler_ctx.files[0]} ...\")\n    spirv_assembler = SPIRVAssembler(compiler_ctx.files[0], disable_debug=False)\n    spirv_assembler.compile()\n\n    if compiler_ctx.user_wants_spirv_asm():\n        spirv_assembler.output_to_file(os.path.basename(compiler_ctx.files[0])[:-3])\n\n    if compiler_ctx.user_only_wants_spirv():\n        return\n\n    logging.info(f\"Generating RTL ...\")\n    verilog_assembler = VerilogAssember(spirv_assembler.create_file_as_string())\n    verilog_assembler.compile(os.path.basename(compiler_ctx.files[0])[:-3])\n</code></pre>"},{"location":"reference-docs/compiler/main/#titan.main.run_argparse","title":"<code>run_argparse()</code>","text":"<p>Handles setting up and executing <code>argparse.ArgumentParser</code>.</p> <p>Returns:</p> Type Description <code>Namespace</code> <p>Parsed arguments</p> Source code in <code>titan/main.py</code> <pre><code>def run_argparse() -&gt; argparse.Namespace:\n    \"\"\" Handles setting up and executing `argparse.ArgumentParser`.\n\n        Returns:\n            Parsed arguments\n    \"\"\"\n    parser = argparse.ArgumentParser(\n        description = \"Compile a subset of Python into SystemVerilog. Visit https://titan-compiler-project.github.io/titan for more info.\"\n    )\n\n    parser.add_argument(\"source_file\", help=\"python source file to compile\")\n    parser.add_argument(\"-t\", \"--top\", help=\"specify the top function\")\n    parser.add_argument(\"-asm\", help=\"output the SPIR-V assembly code\", action=\"store_true\")\n    parser.add_argument(\"-s\", help=\"only run the SPIR-V generation\", action=\"store_true\", dest=\"run_spirv_only\")\n    parser.add_argument(\"-v\", \"--verbose\", help=\"output debug messages\", action=\"store_true\")\n\n    return parser.parse_args()\n</code></pre>"},{"location":"reference-docs/compiler/common/errors/","title":"Documentation for <code>errors.py</code>","text":""},{"location":"reference-docs/compiler/common/errors/#titan.common.errors","title":"<code>titan.common.errors</code>","text":""},{"location":"reference-docs/compiler/common/errors/#titan.common.errors.LoggedException","title":"<code>LoggedException</code>","text":"<p>             Bases: <code>Exception</code></p> <p>An exception that also logs the message to the given logger.</p> Source code in <code>titan/common/errors.py</code> <pre><code>class LoggedException(Exception):\n    \"\"\" An exception that also logs the message to the given logger. \"\"\"\n    def __init__(self, logger: logging.Logger, msg: str):\n        logger.error(msg)\n        super().__init__(msg)\n</code></pre>"},{"location":"reference-docs/compiler/common/errors/#titan.common.errors.TitanErrors","title":"<code>TitanErrors</code>","text":"<p>             Bases: <code>Enum</code></p> <p>A collection of symbolic names for errors, and associated error messages.</p> Source code in <code>titan/common/errors.py</code> <pre><code>class TitanErrors(Enum):\n    \"\"\" A collection of symbolic names for errors, and associated error messages.\"\"\"\n\n    PARSE_BAD_OPTION = \"unknown option\"\n    PARSE_OPTION_FAILURE = \"unable to parse option\" \n    NON_EXISTENT_FILE = \"file does not exist or could not be found\"\n    NO_PARSED_SOURCE_CODE = \"no parsed source code to generate SPIR-V from\"\n    UNDEFINED_TOP_MODULE = \"undefined top module when there are multiple modules, use the -t option to set the top\"\n    PARSED_UNKNOWN_TYPE = \"got unknown type while trying to generate SPIR-V\"\n    NOT_IMPLEMENTED = \"feature not implemented (yet)\"\n    TYPE_EXTRACT_FAILED = \"unable to extract type\"\n    UNKNOWN_TYPE_EXTRACTED = \"got unknown type while extracting\"\n    UNKNOWN_TYPE_IN_ARITHMETIC = \"got unknown type whilst parsing arithmetic\"\n    TYPE_MISMATCH = \"type mismatch\"\n    UNKNOWN_OPERATOR_DURING_GENERATION = \"got unknown operator whilst trying to generate opcode\"\n    UNKNOWN_TYPE_DURING_GENERATION = \"got unknown type when trying to generate opcode\"\n    NON_EXISTENT_SYMBOL = \"symbol does not exist\"\n    UNKNOWN_SPIRV_OPCODE = \"unknown SPIR-V opcode\"\n    UNEXPECTED = \"unexpected exception\"\n    BAD_TYPES = \"bad/unsupported type(s) for operation\"\n</code></pre>"},{"location":"reference-docs/compiler/common/grammar/","title":"Documentation for <code>grammar.py</code>","text":""},{"location":"reference-docs/compiler/common/grammar/#titan.common.grammar","title":"<code>titan.common.grammar</code>","text":""},{"location":"reference-docs/compiler/common/grammar/#titan.common.grammar.TitanPythonGrammar","title":"<code>TitanPythonGrammar</code>","text":"<p>             Bases: <code>NamedTuple</code></p> <p>Grammar for parsing Python.</p> Warning <p>This has been deprecated in favour for Python's AST module. This grammar should not be used at all.</p> Source code in <code>titan/common/grammar.py</code> <pre><code>class TitanPythonGrammar(NamedTuple):\n    \"\"\" Grammar for parsing Python.\n\n        Warning:\n            This has been deprecated in favour for Python's AST module. This grammar should not be used at all.\n    \"\"\"\n\n    # keywords\n    keyword_def = pp.Keyword(\"def\")\n    keyword_return = pp.Keyword(\"return\")\n    keyword_None = pp.Keyword(\"None\")\n\n    function_name = pp.pyparsing_common.identifier\n    variable_name = pp.pyparsing_common.identifier\n\n    # symbols\n    l_br, r_br = map(pp.Literal, \"()\")\n    l_cbr, r_cbr = map(pp.Literal, \"{}\")\n    colon = pp.Literal(\":\")\n    semicolon = pp.Literal(\";\")\n    return_arrow = pp.Literal(\"-&gt;\")\n\n    number = pp.pyparsing_common.number\n\n    type = pp.one_of([\"int\", \"float\", \"bool\"])\n\n    parameter_with_type_hint = pp.Group(variable_name.set_results_name(\"parameter\") + colon.suppress() + type.set_results_name(\"type\"))\n    function_parameter_list_with_type_hint = pp.delimited_list(parameter_with_type_hint) | pp.empty\n\n    function_parameter_list = pp.delimited_list(variable_name) | pp.empty\n    function_return_list = pp.Group(pp.delimited_list(variable_name | number | keyword_None))\n    function_call = function_name + l_br + function_parameter_list + r_br\n    # function_definition = keyword_def.suppress() + function_name.set_results_name(\"function_name\") + l_br.suppress() + function_parameter_list.set_results_name(\"function_param_list\") + r_br.suppress() + colon.suppress()\n    function_definition = keyword_def.suppress() + function_name.set_results_name(\"function_name\") + l_br.suppress() + function_parameter_list_with_type_hint.set_results_name(\"function_param_list\") + r_br.suppress() + return_arrow.suppress() + (type | keyword_None).set_results_name(\"function_return_type\") + colon.suppress()\n\n    # TODO: this doesn't like parsing \"a + b - 3\" or anything that isn't nicely seperated by brackets\n    #       - tried the github ver down below but it also has the same issue, the operators.py file needs to be looked at\n    # precendece reference for the comparison operators https://en.cppreference.com/w/c/language/operator_precedence\n    # TODO: perhaps this should have its name changed, it is no longer only handling only arithmetic, but also comparison and bitwise operators\n    arithmetic_expression = pp.infix_notation(variable_name | number, [\n        (\"-\", 1, pp.OpAssoc.RIGHT, o.UnaryOp),\n        (\"~\", 1, pp.OpAssoc.RIGHT, o.UnaryOp),\n        (pp.one_of(\"* /\"), 2, pp.OpAssoc.LEFT, o.BinaryOp),\n        (pp.one_of(\"+ -\"), 2, pp.OpAssoc.LEFT, o.BinaryOp),\n        (pp.one_of(\"&amp; | ^\"), 2, pp.OpAssoc.LEFT, o.BinaryOp),\n        (pp.one_of(\"&lt; &lt;= &gt;= &gt; == !=\"), 2, pp.OpAssoc.LEFT, o.BinaryOp),\n        (pp.one_of(\"&lt;&lt; &gt;&gt;\"), 2, pp.OpAssoc.LEFT, o.BinaryOp)\n    ])\n\n    # TODO: should these be separate or merged with the arithmetic_expression object\n    bitwise_expression = pp.infix_notation(variable_name | number, [\n        (\"~\", 1, pp.OpAssoc.RIGHT, o.UnaryOp),\n        (pp.one_of(\"&amp; | ^\"), 2, pp.OpAssoc.LEFT, o.BinaryOp)\n    ])\n\n\n    comparison_expression = pp.infix_notation(variable_name | number | arithmetic_expression, [\n        (pp.one_of(\"&lt; &lt;= &gt;= &gt; == !=\"), 2, pp.OpAssoc.LEFT, o.BinaryOp)\n    ])\n\n\n    # combo_expression = arithmetic_expression ^ bitwise_expression ^ comparison_expression\n\n    combo_expression = number ^ variable_name ^ arithmetic_expression\n\n    conditional_ternary_expr = (combo_expression + pp.Literal(\"if\").suppress() + comparison_expression + pp.Literal(\"else\").suppress() + combo_expression).set_parse_action(o.TernaryCondOp)\n\n\n    # https://github.com/pyparsing/pyparsing/blob/master/examples/simpleArith.py\n    # arithmetic_expression = pp.infix_notation(variable_name | number, [\n    #     (pp.one_of(\"+ -\"), 1, pp.OpAssoc.RIGHT, o.UnaryOp),\n    #     (pp.one_of(\"* /\"), 2, pp.OpAssoc.LEFT, o.BinaryOp),\n    #     (pp.one_of(\"+ -\"), 2, pp.OpAssoc.LEFT, o.BinaryOp)\n    # ])\n\n    assignment = (variable_name + \"=\" + (combo_expression ^ conditional_ternary_expr ^ function_call)).set_results_name(\"assignment\")\n    # assignment = (variable_name + \"=\" + (combo_expression | function_call)).set_results_name(\"assignment\")\n\n    # an optional \";\" was added to the end of the statement and function return grammars, this is so that it can still match\n    # when doing the preprocessing step, and when it comes to parsing the file itself\n    # TODO: this might cause issues, maybe split into two seperate variables?\n    statement = (pp.Group(assignment) | pp.Group(function_call)) + pp.Opt(semicolon.suppress())\n\n    function_body = pp.Group(pp.ZeroOrMore(statement)).set_results_name(\"function_statements\") + pp.Optional(keyword_return.suppress()  + function_return_list.set_results_name(\"function_returns\") + pp.Opt(semicolon.suppress()))\n\n    module = pp.ZeroOrMore(\n        pp.Group(\n            function_definition + l_cbr.suppress() + function_body + r_cbr.suppress()\n            )\n    )\n</code></pre>"},{"location":"reference-docs/compiler/common/grammar/#titan.common.grammar.TitanSPIRVGrammar","title":"<code>TitanSPIRVGrammar</code>","text":"<p>             Bases: <code>NamedTuple</code></p> <p>Grammar for parsing SPIR-V assembly.</p> <p>Requires <code>pyparsing</code> to function.</p> Source code in <code>titan/common/grammar.py</code> <pre><code>class TitanSPIRVGrammar(NamedTuple):\n    \"\"\" Grammar for parsing SPIR-V assembly.\n\n        Requires ``pyparsing`` to function.\n    \"\"\"\n\n    pp.ParserElement.set_default_whitespace_chars(\" \\t\")\n    nl = pp.Literal(\"\\n\")\n    eq = pp.Literal(\"=\").suppress()\n    op = pp.Literal(\"Op\").suppress()\n\n    id = pp.Combine(pp.Literal(\"%\") + pp.pyparsing_common.identifier).set_results_name(\"id\")\n    literal_string = pp.quoted_string # https://pyparsing-docs.readthedocs.io/en/latest/HowToUsePyparsing.html?highlight=string#common-string-and-token-constants\n\n    opcode = op + pp.Word(pp.alphanums).set_results_name(\"opcode\")\n\n    opcode_args = pp.Group(pp.delimited_list(\n        pp.ZeroOrMore(id | literal_string | pp.Word(pp.alphanums) | pp.pyparsing_common.number),\n        delim=\" \",\n        allow_trailing_delim=False\n    )).set_results_name(\"opcode_args\")\n\n\n    operation = opcode + pp.Opt(opcode_args) + nl.suppress()\n    assignment = id + eq + operation\n\n    line = pp.Group(operation | assignment)\n\n    spirv_body = pp.ZeroOrMore(\n        line\n    )\n</code></pre>"},{"location":"reference-docs/compiler/common/options/","title":"Documentation for <code>options.py</code>","text":""},{"location":"reference-docs/compiler/common/options/#titan.common.options","title":"<code>titan.common.options</code>","text":""},{"location":"reference-docs/compiler/common/options/#titan.common.options.Options","title":"<code>Options</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Enum containing all valid options.</p> Source code in <code>titan/common/options.py</code> <pre><code>class Options(Enum):\n    \"\"\" Enum containing all valid options.\"\"\"\n    OUTPUT_PREPROCESSED = \"oPP\"\n    OUTPUT_SPIRV_ASM = \"oSA\"\n    DEFINE_TOP_MODULE = \"t\"\n</code></pre>"},{"location":"reference-docs/compiler/common/options/#titan.common.options.parse_options","title":"<code>parse_options(machine_object, args)</code>","text":"<p>Method responsible for parsing the CLI options and assigning them to the appropriate places.</p> Note <p>This method was replaced with Python's own <code>argparse</code> library.</p> Source code in <code>titan/common/options.py</code> <pre><code>def parse_options(machine_object, args):\n    \"\"\" Method responsible for parsing the CLI options and assigning them to the appropriate places.\n\n        Note:\n            This method was replaced with Python's own ``argparse`` library.\n    \"\"\"\n    got_top_module = False\n    dont_repeat = False\n\n    for i in range(1, len(args)):\n        option = args[i]\n\n        if got_top_module and not dont_repeat:\n            dont_repeat = True\n            continue\n\n        if option[0] == \"-\":\n            option_string = option[1:]\n\n            match option_string:\n                case Options.OUTPUT_PREPROCESSED.value:\n                    machine_object.output_options.append(Options.OUTPUT_PREPROCESSED)\n\n                case Options.OUTPUT_SPIRV_ASM.value:\n                    machine_object.output_options.append(Options.OUTPUT_SPIRV_ASM)\n\n                case Options.DEFINE_TOP_MODULE.value:\n                    machine_object.options.append(Options.DEFINE_TOP_MODULE)\n                    machine_object.name_of_top_module = args[i + 1]\n                    got_top_module = True\n\n                case _:\n                    logging.exception(f\"{common.errors.TitanErrors.PARSE_BAD_OPTION.value} \\\"{option}\\\" ({common.errors.TitanErrors.PARSE_BAD_OPTION.name})\")\n                    raise Exception(f\"{common.errors.TitanErrors.PARSE_BAD_OPTION.value} \\\"{option}\\\" ({common.errors.TitanErrors.PARSE_BAD_OPTION.name})\")\n\n        elif option[-3:] == \".py\":\n            file_exists = Path(option).is_file()\n\n            if file_exists:\n                machine_object.files.append(option)\n            else:\n                logging.exception(f\"{common.errors.TitanErrors.PARSE_OPTION_FAILURE.value} \\\"{option}\\\" ({common.errors.TitanErrors.PARSE_OPTION_FAILURE.name})\")\n                raise Exception(f\"{common.errors.TitanErrors.PARSE_OPTION_FAILURE.value} \\\"{option}\\\" ({common.errors.TitanErrors.PARSE_OPTION_FAILURE.name})\")\n</code></pre>"},{"location":"reference-docs/compiler/common/symbols/","title":"Documentation for <code>symbols.py</code>","text":""},{"location":"reference-docs/compiler/common/symbols/#titan.common.symbols","title":"<code>titan.common.symbols</code>","text":""},{"location":"reference-docs/compiler/common/symbols/#titan.common.symbols.Information","title":"<code>Information</code>","text":"<p>             Bases: <code>NamedTuple</code></p> <p>Tuple to store information about the datatype and what operation is being performed.</p> Source code in <code>titan/common/symbols.py</code> <pre><code>class Information(NamedTuple):\n    \"\"\" Tuple to store information about the datatype and what operation is being performed.\"\"\"\n    datatype: DataType\n    operation: Operation\n</code></pre>"},{"location":"reference-docs/compiler/common/symbols/#titan.common.symbols.LiteralSymbolGroup","title":"<code>LiteralSymbolGroup</code>","text":"<p>             Bases: <code>set</code>, <code>Enum</code></p> <p>Enum containing symbols corresponding to operations.</p> Source code in <code>titan/common/symbols.py</code> <pre><code>class LiteralSymbolGroup(set, Enum):\n    \"\"\" Enum containing symbols corresponding to operations.\"\"\"\n    ARITHMETIC = {\"+\", \"-\", \"*\", \"/\"}\n    COMPARISON = {\"&gt;=\", \"&gt;\", \"&lt;\", \"&lt;=\", \"==\", \"!=\"}\n    BITWISE = {\"&lt;&lt;\" , \"&gt;&gt;\"}\n</code></pre>"},{"location":"reference-docs/compiler/common/symbols/#titan.common.symbols.Operation","title":"<code>Operation</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Enum containing possible operations, such as declaration or arithmetic.</p> Source code in <code>titan/common/symbols.py</code> <pre><code>class Operation(Enum):\n    \"\"\" Enum containing possible operations, such as declaration or arithmetic.\"\"\"\n    # vars\n    VARIABLE_DECLARATION = auto()\n    CONSTANT_DECLARATION = auto()\n    GLOBAL_VAR_DECLARATION = auto()\n    GLOBAL_CONST_DECLARATION = auto()\n\n    # funcs\n    FUNCTION_DECLARATION = auto()\n    FUNCTION_IN_VAR_PARAM = auto()\n    FUNCTION_OUT_VAR_PARAM = auto()\n\n    # operations\n    ASSIGNMENT = auto()\n    STORE = auto()\n    LOAD = auto()\n    ADD = \"+\"\n    SUB = \"-\"\n    MULT = \"*\"\n    DIV = \"/\"\n\n    # comparisons\n    DECISION = auto()\n    LESS_THAN = \"&lt;\"\n    LESS_OR_EQ = \"&lt;=\"\n    GREATER_THAN = \"&gt;\"\n    GREATER_OR_EQ = \"&gt;=\"\n    EQUAL_TO = \"==\"\n    NOT_EQUAL_TO = \"!=\"\n\n    # logical\n    SHIFT_LEFT = \"&lt;&lt;\"\n    SHIFT_RIGHT = \"&gt;&gt;\"\n\n    # misc\n    NOP = auto()\n\n    # array ops\n    ARRAY_INDEX = auto()\n    ARRAY_LOAD = auto()\n    ARRAY_STORE = auto()\n</code></pre>"},{"location":"reference-docs/compiler/common/symbols/#titan.common.symbols.Operation_Type","title":"<code>Operation_Type</code>","text":"<p>             Bases: <code>set</code>, <code>Enum</code></p> <p>Enum containing sets of <code>titan.common.symbols.Operation</code>, bundled into common groups.</p> Note <p>These groups are:</p> <ul> <li><code>ARITHMETIC</code></li> <li><code>GENERIC_CONSTANT_DECLARATION</code></li> <li><code>GENERIC_VARAIBLE_DECLARATION</code></li> <li><code>COMPARISON</code></li> <li><code>BITWISE</code></li> </ul> Source code in <code>titan/common/symbols.py</code> <pre><code>class Operation_Type(set, Enum):\n    \"\"\" Enum containing sets of ``titan.common.symbols.Operation``, bundled into common groups.\n\n        Note:\n            These groups are:\n\n            - ``ARITHMETIC``\n            - ``GENERIC_CONSTANT_DECLARATION``\n            - ``GENERIC_VARAIBLE_DECLARATION``\n            - ``COMPARISON``\n            - ``BITWISE``\n    \"\"\"\n    ARITHMETIC = {Operation.ADD, Operation.SUB, Operation.MULT, Operation.DIV}\n    GENERIC_CONSTANT_DECLARATION = {Operation.CONSTANT_DECLARATION, Operation.GLOBAL_CONST_DECLARATION}\n    GENERIC_VARIABLE_DECLARATION = {Operation.VARIABLE_DECLARATION, Operation.GLOBAL_VAR_DECLARATION}\n    COMPARISON = {Operation.LESS_THAN, Operation.LESS_OR_EQ, \n                  Operation.GREATER_THAN, Operation.GREATER_OR_EQ, \n                  Operation.EQUAL_TO, Operation.NOT_EQUAL_TO}\n    BITWISE = {Operation.SHIFT_LEFT, Operation.SHIFT_RIGHT}\n    ARRAY_OPERATIONS = {Operation.ARRAY_INDEX, Operation.ARRAY_LOAD, Operation.ARRAY_STORE}\n</code></pre>"},{"location":"reference-docs/compiler/common/symbols/#titan.common.symbols.SymbolTable","title":"<code>SymbolTable</code>","text":"<p>Simple symbol table class.</p> <p>Attributes:</p> Name Type Description <code>content</code> <p>Dictionary to store the symbols.</p> Source code in <code>titan/common/symbols.py</code> <pre><code>class SymbolTable():\n    \"\"\" Simple symbol table class.\n\n        Attributes:\n            content: Dictionary to store the symbols.\n    \"\"\"\n    # TODO: come up with a better solution -- using a dict for unique\n    # variable names will not work when the scope changes\n    # OR ---- new symbol table every scope change?\n    content = {}\n\n    def __init__(self):\n        pass\n\n    # add entry\n    def add(self, expression, information: Information):\n        \"\"\" Add an entry to the symbol table.\n\n            Args:\n                expression: Symbol to add.\n                information: Store information about the operation.\n        \"\"\"\n        self.content.update({expression: information})\n\n    # delete entry\n    def delete(self, expression):\n        \"\"\" Delete an entry from the symbol table.\n\n            Args:\n                expression: Symbol to delete.\n        \"\"\"\n        del self.content[expression]\n\n    # return using key\n    def get(self, expression) -&gt; Information:\n        \"\"\" Get information about the symbol.\n\n            Args:\n                expression: Symbol to query.\n\n            Returns:\n                Information about the symbol.\n        \"\"\"\n        return self.content.get(expression)\n\n    # if exists bool\n    def exists(self, expression) -&gt; bool:\n        \"\"\" Check if a symbol exists.\n\n            Args:\n                expression: Symbol to check.\n\n            Returns:\n                True if symbol exists, else False.\n        \"\"\"\n        return True if expression in self.content else False\n</code></pre>"},{"location":"reference-docs/compiler/common/symbols/#titan.common.symbols.SymbolTable.delete","title":"<code>delete(expression)</code>","text":"<p>Delete an entry from the symbol table.</p> <p>Parameters:</p> Name Type Description Default <code>expression</code> <p>Symbol to delete.</p> required Source code in <code>titan/common/symbols.py</code> <pre><code>def delete(self, expression):\n    \"\"\" Delete an entry from the symbol table.\n\n        Args:\n            expression: Symbol to delete.\n    \"\"\"\n    del self.content[expression]\n</code></pre>"},{"location":"reference-docs/compiler/common/symbols/#titan.common.symbols.SymbolTable.exists","title":"<code>exists(expression)</code>","text":"<p>Check if a symbol exists.</p> <p>Parameters:</p> Name Type Description Default <code>expression</code> <p>Symbol to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if symbol exists, else False.</p> Source code in <code>titan/common/symbols.py</code> <pre><code>def exists(self, expression) -&gt; bool:\n    \"\"\" Check if a symbol exists.\n\n        Args:\n            expression: Symbol to check.\n\n        Returns:\n            True if symbol exists, else False.\n    \"\"\"\n    return True if expression in self.content else False\n</code></pre>"},{"location":"reference-docs/compiler/common/symbols/#titan.common.symbols.SymbolTable.get","title":"<code>get(expression)</code>","text":"<p>Get information about the symbol.</p> <p>Parameters:</p> Name Type Description Default <code>expression</code> <p>Symbol to query.</p> required <p>Returns:</p> Type Description <code>Information</code> <p>Information about the symbol.</p> Source code in <code>titan/common/symbols.py</code> <pre><code>def get(self, expression) -&gt; Information:\n    \"\"\" Get information about the symbol.\n\n        Args:\n            expression: Symbol to query.\n\n        Returns:\n            Information about the symbol.\n    \"\"\"\n    return self.content.get(expression)\n</code></pre>"},{"location":"reference-docs/compiler/common/type/","title":"Documentation for <code>type.py</code>","text":""},{"location":"reference-docs/compiler/common/type/#titan.common.type","title":"<code>titan.common.type</code>","text":""},{"location":"reference-docs/compiler/common/type/#titan.common.type.DataType","title":"<code>DataType</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Enum to map primative (Python) datatypes onto more abstract keys.</p> Source code in <code>titan/common/type.py</code> <pre><code>class DataType(Enum):\n    \"\"\" Enum to map primative (Python) datatypes onto more abstract keys.\"\"\"\n    VOID = auto()\n    NONE = None\n    INTEGER = int\n    FLOAT = float\n    BOOLEAN = bool\n</code></pre>"},{"location":"reference-docs/compiler/common/type/#titan.common.type.StorageType","title":"<code>StorageType</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Enum to define an analog to SPIR-V's own storage operations.</p> <p>This is required because SPIR-V can define variables as being inputs or outputs, or function variables depending on where they are declared. It's important to keep track of these so that the generated SPIR-V is correct.</p> Source code in <code>titan/common/type.py</code> <pre><code>class StorageType(Enum):\n    \"\"\" Enum to define an analog to SPIR-V's own storage operations.\n\n        This is required because SPIR-V can define variables as being inputs or outputs, or function variables\n        depending on where they are declared. It's important to keep track of these so that the generated SPIR-V\n        is correct.\n    \"\"\"\n    IN = \"Input\"\n    OUT = \"Output\"\n    FUNCTION_VAR = \"Function\"\n    NONE = auto()\n</code></pre>"},{"location":"reference-docs/compiler/compiler/helper/","title":"Documentation for <code>helper.py</code>","text":""},{"location":"reference-docs/compiler/compiler/helper/#titan.compiler.helper.CompilerContext","title":"<code>CompilerContext</code>","text":"Source code in <code>titan/compiler/helper.py</code> <pre><code>class CompilerContext():\n\n    compiler_args, name_of_top_module = None, None\n    options, output_options, files, parsed_modules, functions = [], [], [], [], []\n\n\n    def __init__(self, args: Namespace = None):\n        \"\"\" Init function for the CompilerContext class.\n\n            Args:\n                args: Arguments to keep track of.\n\n            Attributes:\n                compiler_args: Arguments passed to the class.\n                name_of_top_module: The name of the top module/function in the hierarchy.\n                options: Parsed list of options provided by the user.\n                output_options: Parsed list of output options provided by the user.\n                files: List of files to process.\n                parsed_modules: TODO\n                functions: TODO\n        \"\"\"\n\n        self.compiler_args = args\n        self._legacy_arg_setter()\n\n    def _legacy_arg_setter(self):\n        \"\"\" Method to set the arguments due to legacy issues.\n\n            Automatically populates the relevant attributes, using the arguments that\n            were given during object instantiation.\n\n            (I changed my mind about the original implementation,\n            so this is a small workaround.)\n        \"\"\"\n        if self.compiler_args.top is not None:\n            self.options.append(Options.DEFINE_TOP_MODULE)\n            self.name_of_top_module = self.compiler_args.top\n\n        if self.compiler_args.asm:\n            self.output_options.append(Options.OUTPUT_SPIRV_ASM)\n\n        self.files.append(self.compiler_args.source_file)\n\n    def user_wants_spirv_asm(self) -&gt; bool:\n        \"\"\" Getter function to see if user wants compiler to output SPIR-V assembly.\n\n            Returns:\n                True if user wants assembly, otherwise false.\n        \"\"\"\n        return self.compiler_args.asm\n\n    def has_user_defined_top(self) -&gt; bool:\n        \"\"\" Getter function to see if user defined a name for the top module.\n\n            Returns:\n                True if user defined a name, otherwise false.\n        \"\"\"\n        return self.compiler_args.top is not None\n\n    def get_top_module_name(self) -&gt; str:\n        \"\"\" Getter function to fetch top module name.\n\n            Returns:\n                Name of the top module as defined by the user.\n        \"\"\"\n        return self.compiler_args.top\n\n    def user_only_wants_spirv(self) -&gt; bool:\n        \"\"\" Getter function to see if user only wants to run the SPIR-V portion of the compiler. \n\n            Returns:\n                True if user wants only SPIR-V, otherwise False.\n        \"\"\"\n        return self.compiler_args.run_spirv_only\n\n    def user_wants_verbose_info(self) -&gt; bool:\n        \"\"\" Getter function to see if user wants verbose debugging information.\n\n            Returns:\n                True if user wants debug info, else False.\n        \"\"\"\n        return self.compiler_args.verbose\n</code></pre>"},{"location":"reference-docs/compiler/compiler/helper/#titan.compiler.helper.CompilerContext.__init__","title":"<code>__init__(args=None)</code>","text":"<p>Init function for the CompilerContext class.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>Arguments to keep track of.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>compiler_args</code> <p>Arguments passed to the class.</p> <code>name_of_top_module</code> <p>The name of the top module/function in the hierarchy.</p> <code>options</code> <p>Parsed list of options provided by the user.</p> <code>output_options</code> <p>Parsed list of output options provided by the user.</p> <code>files</code> <p>List of files to process.</p> <code>parsed_modules</code> <p>TODO</p> <code>functions</code> <p>TODO</p> Source code in <code>titan/compiler/helper.py</code> <pre><code>def __init__(self, args: Namespace = None):\n    \"\"\" Init function for the CompilerContext class.\n\n        Args:\n            args: Arguments to keep track of.\n\n        Attributes:\n            compiler_args: Arguments passed to the class.\n            name_of_top_module: The name of the top module/function in the hierarchy.\n            options: Parsed list of options provided by the user.\n            output_options: Parsed list of output options provided by the user.\n            files: List of files to process.\n            parsed_modules: TODO\n            functions: TODO\n    \"\"\"\n\n    self.compiler_args = args\n    self._legacy_arg_setter()\n</code></pre>"},{"location":"reference-docs/compiler/compiler/helper/#titan.compiler.helper.CompilerContext._legacy_arg_setter","title":"<code>_legacy_arg_setter()</code>","text":"<p>Method to set the arguments due to legacy issues.</p> <p>Automatically populates the relevant attributes, using the arguments that were given during object instantiation.</p> <p>(I changed my mind about the original implementation, so this is a small workaround.)</p> Source code in <code>titan/compiler/helper.py</code> <pre><code>def _legacy_arg_setter(self):\n    \"\"\" Method to set the arguments due to legacy issues.\n\n        Automatically populates the relevant attributes, using the arguments that\n        were given during object instantiation.\n\n        (I changed my mind about the original implementation,\n        so this is a small workaround.)\n    \"\"\"\n    if self.compiler_args.top is not None:\n        self.options.append(Options.DEFINE_TOP_MODULE)\n        self.name_of_top_module = self.compiler_args.top\n\n    if self.compiler_args.asm:\n        self.output_options.append(Options.OUTPUT_SPIRV_ASM)\n\n    self.files.append(self.compiler_args.source_file)\n</code></pre>"},{"location":"reference-docs/compiler/compiler/helper/#titan.compiler.helper.CompilerContext.get_top_module_name","title":"<code>get_top_module_name()</code>","text":"<p>Getter function to fetch top module name.</p> <p>Returns:</p> Type Description <code>str</code> <p>Name of the top module as defined by the user.</p> Source code in <code>titan/compiler/helper.py</code> <pre><code>def get_top_module_name(self) -&gt; str:\n    \"\"\" Getter function to fetch top module name.\n\n        Returns:\n            Name of the top module as defined by the user.\n    \"\"\"\n    return self.compiler_args.top\n</code></pre>"},{"location":"reference-docs/compiler/compiler/helper/#titan.compiler.helper.CompilerContext.has_user_defined_top","title":"<code>has_user_defined_top()</code>","text":"<p>Getter function to see if user defined a name for the top module.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if user defined a name, otherwise false.</p> Source code in <code>titan/compiler/helper.py</code> <pre><code>def has_user_defined_top(self) -&gt; bool:\n    \"\"\" Getter function to see if user defined a name for the top module.\n\n        Returns:\n            True if user defined a name, otherwise false.\n    \"\"\"\n    return self.compiler_args.top is not None\n</code></pre>"},{"location":"reference-docs/compiler/compiler/helper/#titan.compiler.helper.CompilerContext.user_only_wants_spirv","title":"<code>user_only_wants_spirv()</code>","text":"<p>Getter function to see if user only wants to run the SPIR-V portion of the compiler. </p> <p>Returns:</p> Type Description <code>bool</code> <p>True if user wants only SPIR-V, otherwise False.</p> Source code in <code>titan/compiler/helper.py</code> <pre><code>def user_only_wants_spirv(self) -&gt; bool:\n    \"\"\" Getter function to see if user only wants to run the SPIR-V portion of the compiler. \n\n        Returns:\n            True if user wants only SPIR-V, otherwise False.\n    \"\"\"\n    return self.compiler_args.run_spirv_only\n</code></pre>"},{"location":"reference-docs/compiler/compiler/helper/#titan.compiler.helper.CompilerContext.user_wants_spirv_asm","title":"<code>user_wants_spirv_asm()</code>","text":"<p>Getter function to see if user wants compiler to output SPIR-V assembly.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if user wants assembly, otherwise false.</p> Source code in <code>titan/compiler/helper.py</code> <pre><code>def user_wants_spirv_asm(self) -&gt; bool:\n    \"\"\" Getter function to see if user wants compiler to output SPIR-V assembly.\n\n        Returns:\n            True if user wants assembly, otherwise false.\n    \"\"\"\n    return self.compiler_args.asm\n</code></pre>"},{"location":"reference-docs/compiler/compiler/helper/#titan.compiler.helper.CompilerContext.user_wants_verbose_info","title":"<code>user_wants_verbose_info()</code>","text":"<p>Getter function to see if user wants verbose debugging information.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if user wants debug info, else False.</p> Source code in <code>titan/compiler/helper.py</code> <pre><code>def user_wants_verbose_info(self) -&gt; bool:\n    \"\"\" Getter function to see if user wants verbose debugging information.\n\n        Returns:\n            True if user wants debug info, else False.\n    \"\"\"\n    return self.compiler_args.verbose\n</code></pre>"},{"location":"reference-docs/compiler/compiler/hinting/","title":"Documentation for <code>hinting.py</code>","text":"<p>Note</p> <p>This file is mainly for type hinting, and does not contain any functionality.</p>"},{"location":"reference-docs/compiler/compiler/hinting/#titan.compiler.hinting.spirv_id_and_type_context","title":"<code>titan.compiler.hinting.spirv_id_and_type_context</code>","text":"<p>             Bases: <code>TypedDict</code></p> Source code in <code>titan/compiler/hinting.py</code> <pre><code>class spirv_id_and_type_context(TypedDict):\n    spirv_id: str\n    type_context: NodeTypeContext\n</code></pre>"},{"location":"reference-docs/compiler/compiler/hinting/#titan.compiler.hinting.spirv_id_and_node","title":"<code>titan.compiler.hinting.spirv_id_and_node</code>","text":"<p>             Bases: <code>TypedDict</code></p> Source code in <code>titan/compiler/hinting.py</code> <pre><code>class spirv_id_and_node(TypedDict):\n    id: str\n    node: List[Node]\n</code></pre>"},{"location":"reference-docs/compiler/compiler/hinting/#titan.compiler.hinting.module_name_and_data","title":"<code>titan.compiler.hinting.module_name_and_data</code>","text":"<p>             Bases: <code>TypedDict</code></p> Source code in <code>titan/compiler/hinting.py</code> <pre><code>class module_name_and_data(TypedDict):\n    name: str\n    data: NodeModuleData\n</code></pre>"},{"location":"reference-docs/compiler/compiler/hinting/#titan.compiler.hinting.symbol_and_type","title":"<code>titan.compiler.hinting.symbol_and_type</code>","text":"<p>             Bases: <code>TypedDict</code></p> Source code in <code>titan/compiler/hinting.py</code> <pre><code>class symbol_and_type(TypedDict):\n    symbol: str\n    type: Union[int, float, bool, None]\n</code></pre>"},{"location":"reference-docs/compiler/compiler/hinting/#titan.compiler.hinting.declared_types","title":"<code>titan.compiler.hinting.declared_types</code>","text":"<p>             Bases: <code>TypedDict</code></p> Source code in <code>titan/compiler/hinting.py</code> <pre><code>class declared_types(TypedDict):\n    type: DataType\n    spirv_id: str\n</code></pre>"},{"location":"reference-docs/compiler/compiler/node/","title":"Documentation for <code>node.py</code>","text":""},{"location":"reference-docs/compiler/compiler/node/#titan.compiler.node.Node","title":"<code>Node</code>","text":"<p>Node class. </p> <p>Attributes:</p> Name Type Description <code>spirv_line_no</code> <code>int</code> <p>SPIR-V assembly line number.</p> <code>spirv_id</code> <code>str</code> <p>Assigned SPIR-V ID.</p> <code>type_id</code> <code>str</code> <p>Stores the type ID of the nodes type.</p> <code>input_left</code> <code>Node</code> <p>Left parent node.</p> <code>input_right</code> <code>Node</code> <p>Right parent node.</p> <code>operation</code> <code>Operation</code> <p>Operation that the node is performing.</p> <code>data</code> <code>None</code> <p>TODO</p> <code>is_comparison</code> <code>bool</code> <p>TODO</p> <code>tick</code> <code>int</code> <p>Integer representing at what stage in the pipeline this should be executed.</p> Source code in <code>titan/compiler/node.py</code> <pre><code>class Node:\n    \"\"\" Node class. \n\n        Attributes:\n            spirv_line_no (int): SPIR-V assembly line number.\n            spirv_id (str): Assigned SPIR-V ID.\n            type_id (str): Stores the type ID of the nodes type.\n            input_left (titan.compiler.node.Node): Left parent node.\n            input_right (titan.compiler.node.Node): Right parent node.\n            operation (titan.common.symbols.Operation): Operation that the node is performing.\n            data (None): TODO\n            is_comparison (bool): TODO\n            tick (int): Integer representing at what stage in the pipeline this should be executed.\n    \"\"\"\n\n    @staticmethod\n    def _calculate_tick(left_node: int, right_node: int, comparison_node: int = None) -&gt; int:\n        \"\"\" Calculate the correct tick for the node.\n\n            Ticks can be set to zero if the node has no parents, or to the highest tick of the parents + 1.\n\n            Args:\n                left_node: Left node.\n                right_node: Right node.\n                comparison_node: Comparison node, used if currently using a decision node.\n\n            Returns:\n                Maximum calculated tick, based on the nodes provided.\n        \"\"\"\n\n        # add values to list? if they're not None\n        comparison_generator = (value for value in [left_node, right_node, comparison_node] if value is not None)\n\n        try:\n            return max(comparison_generator) + 1\n        except ValueError:\n            # should only be the case where left_node = None, right_node = None and comparison_node = None\n            return 0\n\n    @staticmethod\n    def _set_tick_during_init(context: NodeContext):\n        \"\"\" Calculate the tick for the node during initialisation. \n\n            Args:\n                context: Context about the node to create.\n        \"\"\"\n\n        l_node_val = None if context.input_left == None else context.input_left.tick\n        r_node_val = None if context.input_right == None else context.input_right.tick\n\n        if context.is_comparison:\n            # return Node._calculate_tick(l_node_val, r_node_val, context.data[0].tick)\n            # TODO: do we have to account for the tick of the input nodes, if the selector is guaranteed to come after?\n            #                                                                               is it even guaranteed to come right after? idk\n            return Node._calculate_tick(0, 0, context.data[0].tick) \n        else:\n            return Node._calculate_tick(l_node_val, r_node_val)\n\n\n    def __init__(self, context: NodeContext):\n        \"\"\" Init function for a node.\n\n            Args:\n                context: Context to create the node with.\n        \"\"\"\n        self.spirv_line_no = context.line_no\n        self.spirv_id = context.id\n        self.type_id = context.type_id\n        self.input_left = context.input_left\n        self.input_right = context.input_right\n        self.operation = context.operation\n        self.data = context.data\n        self.is_comparison = context.is_comparison\n        self.tick = self._set_tick_during_init(context)\n        self.array_id = context.array_id\n        self.array_index_id = context.array_index_id\n\n\n    def _update_tick(self) -&gt; int:\n        \"\"\" Helper function to update the tick when one of the parent nodes are changed.\n\n            Returns:\n                Recalculated tick value.\n        \"\"\"\n        left_node_is_none = self.input_left == None\n        right_node_is_none = self.input_right == None\n\n        l_node_val = None if left_node_is_none else self.input_left.tick\n        r_node_val = None if right_node_is_none else self.input_right.tick\n\n        if self.is_comparison:\n            return Node._calculate_tick(l_node_val, r_node_val, self.data[0].tick)\n        else:\n            return Node._calculate_tick(l_node_val, r_node_val)\n\n\n    def update_input(self, pos: int, new_node: Node):\n        \"\"\" Update a parent node.\n\n            Automatically recalculates the tick for the current node.\n\n            Args:\n                pos: 0 = left node, 1 = right node\n                new_node: New node to update the input with.\n        \"\"\"        \n        if pos == 0: # left node\n            self.input_left = new_node\n        elif pos == 1: # right node\n            self.input_right = new_node\n\n        self.tick = self._update_tick()\n\n\n    # TODO: make this look better\n    def __str__(self):\n        # return f\"({self.__class__.__name__}: {self.spirv_line_no}:{self.spirv_id}, type_id: {self.type_id}, left: [{None if self.input_left is None else self.input_left.spirv_id}], right: [{None if self.input_right is None else self.input_right.spirv_id}], op: {self.operation}, data: {self.data},  is_comparison: {self.is_comparison}, tick: {self.tick})\"\n        # return f\"line # {self.spirv_line_no}: '{self.spirv_id}' @ tick {self.tick}: type_id: &lt;'{self.type_id}'&gt;, input_left: &lt;'{None if self.input_left is None else self.input_left.spirv_id}'&gt;, input_right: &lt;'{None if self.input_right is None else self.input_right.spirv_id}'&gt;, operation: &lt;{self.operation.name}&gt;, data: &lt;{self.data}&gt;, is_comparison: &lt;{self.is_comparison}&gt;, array_id: &lt;'{self.array_id}'&gt;, array_index_id: &lt;'{self.array_index_id}'&gt;\"\n\n        base_info = f\"line # {self.spirv_line_no+1}: '{self.spirv_id}' @ tick {self.tick}: type_id: &lt;'{self.type_id}'&gt;, operation: &lt;{self.operation.name}&gt;, input_left: &lt;'{None if self.input_left is None else self.input_left.spirv_id}'&gt;, input_right: &lt;'{None if self.input_right is None else self.input_right.spirv_id}'&gt;\"\n\n        if self.operation in Operation_Type.COMPARISON:\n            base_info += f\", data: &lt;{self.data}&gt;, is_comparison: {self.is_comparison}\"\n        elif self.operation in Operation_Type.ARRAY_OPERATIONS:\n            base_info += f\", array_id: &lt;'{self.array_id}'&gt;, array_index_id: &lt;'{self.array_index_id}'&gt;\"\n        elif self.operation in Operation_Type.GENERIC_CONSTANT_DECLARATION:\n            base_info += f\", data: &lt;{self.data}&gt;\"\n\n\n        return base_info\n\n\n    def __repr__(self):\n        return self.__str__()\n</code></pre>"},{"location":"reference-docs/compiler/compiler/node/#titan.compiler.node.Node.__init__","title":"<code>__init__(context)</code>","text":"<p>Init function for a node.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>NodeContext</code> <p>Context to create the node with.</p> required Source code in <code>titan/compiler/node.py</code> <pre><code>def __init__(self, context: NodeContext):\n    \"\"\" Init function for a node.\n\n        Args:\n            context: Context to create the node with.\n    \"\"\"\n    self.spirv_line_no = context.line_no\n    self.spirv_id = context.id\n    self.type_id = context.type_id\n    self.input_left = context.input_left\n    self.input_right = context.input_right\n    self.operation = context.operation\n    self.data = context.data\n    self.is_comparison = context.is_comparison\n    self.tick = self._set_tick_during_init(context)\n    self.array_id = context.array_id\n    self.array_index_id = context.array_index_id\n</code></pre>"},{"location":"reference-docs/compiler/compiler/node/#titan.compiler.node.Node._calculate_tick","title":"<code>_calculate_tick(left_node, right_node, comparison_node=None)</code>  <code>staticmethod</code>","text":"<p>Calculate the correct tick for the node.</p> <p>Ticks can be set to zero if the node has no parents, or to the highest tick of the parents + 1.</p> <p>Parameters:</p> Name Type Description Default <code>left_node</code> <code>int</code> <p>Left node.</p> required <code>right_node</code> <code>int</code> <p>Right node.</p> required <code>comparison_node</code> <code>int</code> <p>Comparison node, used if currently using a decision node.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>Maximum calculated tick, based on the nodes provided.</p> Source code in <code>titan/compiler/node.py</code> <pre><code>@staticmethod\ndef _calculate_tick(left_node: int, right_node: int, comparison_node: int = None) -&gt; int:\n    \"\"\" Calculate the correct tick for the node.\n\n        Ticks can be set to zero if the node has no parents, or to the highest tick of the parents + 1.\n\n        Args:\n            left_node: Left node.\n            right_node: Right node.\n            comparison_node: Comparison node, used if currently using a decision node.\n\n        Returns:\n            Maximum calculated tick, based on the nodes provided.\n    \"\"\"\n\n    # add values to list? if they're not None\n    comparison_generator = (value for value in [left_node, right_node, comparison_node] if value is not None)\n\n    try:\n        return max(comparison_generator) + 1\n    except ValueError:\n        # should only be the case where left_node = None, right_node = None and comparison_node = None\n        return 0\n</code></pre>"},{"location":"reference-docs/compiler/compiler/node/#titan.compiler.node.Node._set_tick_during_init","title":"<code>_set_tick_during_init(context)</code>  <code>staticmethod</code>","text":"<p>Calculate the tick for the node during initialisation. </p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>NodeContext</code> <p>Context about the node to create.</p> required Source code in <code>titan/compiler/node.py</code> <pre><code>@staticmethod\ndef _set_tick_during_init(context: NodeContext):\n    \"\"\" Calculate the tick for the node during initialisation. \n\n        Args:\n            context: Context about the node to create.\n    \"\"\"\n\n    l_node_val = None if context.input_left == None else context.input_left.tick\n    r_node_val = None if context.input_right == None else context.input_right.tick\n\n    if context.is_comparison:\n        # return Node._calculate_tick(l_node_val, r_node_val, context.data[0].tick)\n        # TODO: do we have to account for the tick of the input nodes, if the selector is guaranteed to come after?\n        #                                                                               is it even guaranteed to come right after? idk\n        return Node._calculate_tick(0, 0, context.data[0].tick) \n    else:\n        return Node._calculate_tick(l_node_val, r_node_val)\n</code></pre>"},{"location":"reference-docs/compiler/compiler/node/#titan.compiler.node.Node._update_tick","title":"<code>_update_tick()</code>","text":"<p>Helper function to update the tick when one of the parent nodes are changed.</p> <p>Returns:</p> Type Description <code>int</code> <p>Recalculated tick value.</p> Source code in <code>titan/compiler/node.py</code> <pre><code>def _update_tick(self) -&gt; int:\n    \"\"\" Helper function to update the tick when one of the parent nodes are changed.\n\n        Returns:\n            Recalculated tick value.\n    \"\"\"\n    left_node_is_none = self.input_left == None\n    right_node_is_none = self.input_right == None\n\n    l_node_val = None if left_node_is_none else self.input_left.tick\n    r_node_val = None if right_node_is_none else self.input_right.tick\n\n    if self.is_comparison:\n        return Node._calculate_tick(l_node_val, r_node_val, self.data[0].tick)\n    else:\n        return Node._calculate_tick(l_node_val, r_node_val)\n</code></pre>"},{"location":"reference-docs/compiler/compiler/node/#titan.compiler.node.Node.update_input","title":"<code>update_input(pos, new_node)</code>","text":"<p>Update a parent node.</p> <p>Automatically recalculates the tick for the current node.</p> <p>Parameters:</p> Name Type Description Default <code>pos</code> <code>int</code> <p>0 = left node, 1 = right node</p> required <code>new_node</code> <code>Node</code> <p>New node to update the input with.</p> required Source code in <code>titan/compiler/node.py</code> <pre><code>def update_input(self, pos: int, new_node: Node):\n    \"\"\" Update a parent node.\n\n        Automatically recalculates the tick for the current node.\n\n        Args:\n            pos: 0 = left node, 1 = right node\n            new_node: New node to update the input with.\n    \"\"\"        \n    if pos == 0: # left node\n        self.input_left = new_node\n    elif pos == 1: # right node\n        self.input_right = new_node\n\n    self.tick = self._update_tick()\n</code></pre>"},{"location":"reference-docs/compiler/compiler/node/#titan.compiler.node.NodeAssembler","title":"<code>NodeAssembler</code>","text":"<p>Node assembler.</p> Source code in <code>titan/compiler/node.py</code> <pre><code>class NodeAssembler():\n    \"\"\" Node assembler. \"\"\"\n\n    content: hinting.module_name_and_data = {}\n    declared_symbols = []\n\n\n    def _overwrite_body_nodes(self, module_name: str, nodes: List[Node]):\n        \"\"\" Overwrite an existing set of nodes for a given module/function.\n\n            Args:\n                module_name: The module to modify.\n                nodes: Updated list of nodes.\n\n            Note:\n                The parameter \"module_name\" used to be called \"fn_name\". This was modified during a rewrite,\n                and this message is a reminder of that.\n        \"\"\"\n\n        # self.content[module_name].nodes = nodes\n        self.content[module_name].body_nodes = nodes\n\n    # NOTE: equiv. to create_function\n    def create_module(self, module_name: str):\n        \"\"\" Method to create a new, empty module class. \n\n            Args:\n                module_name: Name of the module.\n        \"\"\"\n        self.content[module_name] = NodeModuleData()\n\n    # NOTE: equiv. to add_body_node_to_function\n    def add_body_node_to_module(self, module_name: str, node: Node):\n        \"\"\" Add a body node to an existing module.\n\n            Checks if the node exists by using the associated SPIR-V ID, creating it if not.\n            Then appends the node to that SPIR-V ID.\n\n            Args:\n                module_name: Module to ad to.\n                node: Node to add.\n        \"\"\"\n        if not self.node_exists(module_name, node.spirv_id):\n            self.content[module_name].body_nodes[node.spirv_id] = []\n\n        self.content[module_name].body_nodes[node.spirv_id].append(node)\n\n    def add_type_context_to_module(self, module_name: str, type_id: str, type_context: NodeTypeContext):\n        \"\"\" Add a type context to a function.\n\n            Args:\n                module_name: Module to add to.\n                type_id: ID to associate with the type.\n                type_context: Context about the type.\n        \"\"\"\n        self.content[module_name].types[type_id] = type_context\n\n    def get_type_context_from_module(self, module_name: str, type_id: str) -&gt; NodeTypeContext:\n        \"\"\" Get type context from a module using a type ID.\n\n            Args:\n                module_name: Module to fetch from.\n                type_id: ID of type to query.\n\n            Returns:\n                Context of the type.\n        \"\"\"\n        return self.content[module_name].types[type_id]\n\n    def type_exists_in_module(self, module_name: str, type_id: str) -&gt; bool:\n        \"\"\" Check if a type exists for a given module.\n\n            Args:\n                module_name: Module to check in.\n                type_id: Type ID to check for.\n\n            Returns:\n                True if ID exists in function, else false.\n        \"\"\"\n        return True if type_id in self.content[module_name].types else False\n\n    def add_output_to_module(self, module_name: str, symbol: str):\n        \"\"\" Add an output to a module.\n\n            Args:\n                module_name: Module to add to.\n                symbol: Symbol to add as an output.\n        \"\"\"\n        self.content[module_name].outputs.append(symbol)\n\n    def add_input_to_module(self, module_name: str, symbol: str):\n        \"\"\" Add an input to a module.\n\n            Args:\n                module_name: Module to add to.\n                symbol: Symbol to add as an input.\n        \"\"\"\n        self.content[module_name].inputs.append(symbol)\n\n    def is_symbol_an_input(self, module_name: str, symbol: str) -&gt; bool:\n        return symbol in self.content[module_name].inputs\n\n    def is_symbol_an_output(self, module_name: str, symbol: str) -&gt; bool:\n        return symbol in self.content[module_name].outputs\n\n    def get_datatype_from_id(self, module_name: str, id: str) -&gt; DataType:\n        \"\"\" Return primative type from ID.\n\n            Args:\n                module_name: Module to check in.\n                id: ID to query.\n\n            Returns:\n                Primative datatype of ID, if it exists.\n        \"\"\"\n        return self.content[module_name].types[id].type\n\n    def get_primative_type_id_from_id(self, module_name: str, id: str) -&gt; str:\n        \"\"\" Returns the associated primative type ID given an ID of a symbol.\n\n            Can handle pointers too.\n\n            Args:\n                module_name: Module to fetch from.\n                id: ID to fetch from.\n\n            Returns:\n                Primative type ID.\n        \"\"\"\n        x = self.content[module_name].types[id]\n        return x.alias if x.is_pointer else id\n\n    def get_primative_type_context_from_datatype(self, module_name: str, datatype: DataType) -&gt; NodeTypeContext:\n\n        best_type = None\n        for type in self.content[module_name].types.values():\n            if type.type == datatype and type.is_pointer == False and type.is_array is False:\n                best_type = type\n\n        assert best_type != None, f\"unable to find primative type from datatype\"\n        return best_type\n\n    def get_array_node_dimensions(self, module_name: str, node_id: str) -&gt; int | tuple[int]:\n        \"\"\" Get the array dimensions using the ID of the array.\n\n            Args:\n                module_name: Module to get from.\n                node_id: ID of array.\n\n            Returns:\n                array_dimensions: Defined array dimensions.\n        \"\"\"\n\n        array_node = self.get_node(module_name, node_id)\n        array_type_id = self.get_type_context_from_module(module_name, array_node.type_id)\n        array_max_size = self.get_node(module_name, array_type_id.array_dimension_id).data[0]\n\n        return array_max_size\n\n    # renamed from does_node_exist\n    def node_exists(self, module_name: str, node_id: str) -&gt; bool:\n        \"\"\" Checks if a node exists in a given module.\n\n            Args:\n                module_name: Module to check in.\n                node_id: Node ID to check for.\n\n            Returns:\n                True if node exists, else false.\n        \"\"\"\n        return True if node_id in self.content[module_name].body_nodes else False\n\n    def does_node_exist_in_dict(self, node_dict: dict[Node], node_id: str) -&gt; bool:\n        \"\"\" Checks if a node exists in the node dictionary.\n\n            Args:\n                node_dict: Dictionary containing Nodes.\n                node_id: ID of the node to check for.\n\n            Returns:\n                True if node exists in the dictionary, else false.\n        \"\"\"\n        return True if node_id in node_dict else False\n\n    def get_node(self, module_name: str, node_id: str) -&gt; Node:\n        \"\"\" Gets the latest node given a node ID in a given function.\n\n            Args:\n                module_name: Module to check in.\n                node_id: Node ID to check for.\n\n            Returns:\n                Latest node for the given node ID.\n        \"\"\"\n        # -1 for the very latest node\n        return self.content[module_name].body_nodes[node_id][-1]\n\n\n    # default arg_pos is [1, 2] since its commonly used\n    # however different values needed for other nodes\n    def get_left_and_right_nodes(self, module_name: str, line, arg_pos: list[int] = [1, 2]) -&gt; Tuple[Node, Node]:\n        left = self.get_node(module_name, line.opcode_args[arg_pos[0]])\n        right = self.get_node(module_name, line.opcode_args[arg_pos[1]])\n        return (left, right)\n\n    def modify_node(self, module_name: str, target_node_id: str, pos: int, value_node: Node, operation: Operation = Operation.NOP):\n        \"\"\" Modify the parents and/or the operation of a node within a module.\n\n            Args:\n                module_name: Module to modify node in.\n                target_node_id: Node to modify.\n                pos: Which parent of the node to modify. (0 = left, 1 = right)\n                value_node: New parent node.\n                operation: Operation that the node is performing.\n        \"\"\"\n\n        x = self.get_node(module_name, target_node_id)\n        logging.debug(f\"modifiying {target_node_id}: {x}\")\n        logging.debug(f\"\\tposition {pos} should contain {value_node.spirv_id}\")\n        logging.debug(f\"\\toperation {x.operation} should update to {operation}\")\n\n        if pos == 0:\n            new_ctx = NodeContext(\n                x.spirv_line_no, x.spirv_id, x.type_id, value_node, x.input_right, operation, x.data\n            )\n\n        elif pos == 1:\n            new_ctx = NodeContext(\n                x.spirv_line_no, x.spirv_id, x.type_id, x.input_left, value_node, operation, x.data\n            )\n\n        logging.debug(f\"new node context: {new_ctx}\")\n\n        self.content[module_name].body_nodes[target_node_id].append(Node(new_ctx))\n\n    def _sort_body_nodes_by_tick(self, module_name: str) -&gt; dict:\n        \"\"\" Sorts the nodes in ascending order (0 -&gt; max tick).\n\n            Args:\n                module_name: Name of module to sort nodes of.\n\n            Returns:\n                New dictionary containing sorted nodes, with the tick as the key.\n        \"\"\"\n        tick_dict = {}\n\n        # logging.debug(f\"nodes before {len(self.content[module_name].body_nodes)}: {self.content[module_name].body_nodes}\")\n        # TODO: can we just use list comprehension on this?\n        for symbols in self.content[module_name].body_nodes:\n            for node in self.content[module_name].body_nodes[symbols]:\n\n                if node.tick not in tick_dict.keys():\n                    tick_dict[node.tick] = []\n\n                tick_dict[node.tick].append(node)\n        # logging.debug(f\"nodes after {len(tick_dict)}: {tick_dict}\")\n        return tick_dict\n\n    @staticmethod\n    def _parent_exists(node: Node) -&gt; bool:\n        \"\"\" Check whether the node has any parents.\n\n            Args:\n                node: Node to check parents of.\n\n            Returns:\n                True if any parents exist, else false.\n        \"\"\"\n        return True if node.input_left is not None or node.input_right is not None else False\n\n    @staticmethod\n    def _encode_parents(node: Node) -&gt; int:\n        \"\"\" Numerically encode the position of the parents.\n\n            Note:\n                - 0: No parents exist.\n                - 1: Left parent exists.\n                - 2: Right parent exists.\n                - 3: Both parents exist.\n\n            Args:\n                node: Node to encode the parents of.\n        \"\"\"\n\n        count = 0\n\n        if node.input_left is not None:\n            count += 1\n\n        if node.input_right is not None:\n            count += 2\n\n        return count\n\n    def generate_dot_graph(self, file_name_suffix: str = \"\", clean_nodes = None, dark_mode: bool = True):\n        \"\"\" Generates Graphviz dot graphs of the dataflow of a function. Requires the ``graphviz`` package.\n\n            Args:\n                file_name_suffix: String to append to the filename.\n                clean_nodes: List of clean/optimised nodes.\n        \"\"\"\n        for module in self.content.keys():\n            dot = graphviz.Digraph(comment=f\"digraph for {module}\", filename=f\"digraph_{module}{file_name_suffix}.dot\", directory=\"dots\") \n\n            # dark mode\n            if dark_mode:\n                dot.attr(bgcolor=\"gray10\")\n                dot.attr(color=\"white\")\n                dot.attr(fontcolor=\"white\")\n\n            if clean_nodes is None:\n                x = self._sort_body_nodes_by_tick(module)\n            else:\n                x = clean_nodes\n\n            for k in range(0, len(x.keys())):\n                with dot.subgraph(name=f\"cluster_tick_{k}\") as ds:\n                    ds.attr(style=\"dashed\")\n                    ds.attr(label=f\"tick {k}\")\n\n                    try:\n                        for v in x[k]:\n                            current_node_label = f\"{v.spirv_id}_{k}\"\n                            ds.node(current_node_label, f\"{v.spirv_id} at tick {k} \\n({v.operation})\", color=\"white\", fontcolor=\"white\")\n\n                            if self._parent_exists(v):\n                                # check which parents exist\n                                parent_num = self._encode_parents(v)\n                                match parent_num:\n                                    case 1:\n                                        # ds.edge()\n                                        # get parent name/spirv id\n                                        parent_id_label = f\"{v.input_left.spirv_id}_{v.input_left.tick}\"\n                                        ds.edge(parent_id_label, current_node_label, color=\"white\")\n\n                                    case 2:\n                                        parent_id_label = f\"{v.input_right.spirv_id}_{v.input_right.tick}\"\n                                        ds.edge(parent_id_label, current_node_label, color=\"white\")\n                                    case 3:\n\n                                        # TODO: need a better way to determine correct id &amp; tick to use when dealing with decision nodes\n                                        # this solution will fail if it's basically a stack of Operation.STOREs because it only goes back\n                                        # two nodes.\n                                        if v.is_comparison:\n                                            if v.input_left.operation is Operation.STORE:\n                                                parent_l_id_label = f\"{v.input_left.input_left.spirv_id}_{self.get_node(module, v.input_left.input_left.spirv_id).tick}\"\n\n                                            if v.input_right.operation is Operation.STORE:\n                                                parent_r_id_label = f\"{v.input_right.input_right.spirv_id}_{self.get_node(module, v.input_right.input_right.spirv_id).tick}\"\n                                        else:\n                                            parent_l_id_label = f\"{v.input_left.spirv_id}_{v.input_left.tick}\"\n                                            parent_r_id_label = f\"{v.input_right.spirv_id}_{v.input_right.tick}\"\n\n                                        ds.edge(parent_l_id_label, current_node_label, color=\"white\" if not v.is_comparison else \"green\")\n                                        ds.edge(parent_r_id_label, current_node_label, color=\"white\" if not v.is_comparison else \"red\")\n\n                                        if v.is_comparison:\n                                            parent_compare_id_label = f\"{v.data[0].spirv_id}_{v.data[0].tick}\"\n                                            ds.edge(parent_compare_id_label, current_node_label, color=\"white\")\n\n                                    case _:\n                                        # should be unreachable\n                                        raise Exception(f\"{TitanErrors.UNEXPECTED.value} - got {parent_num} parents, but parents exist.\", TitanErrors.UNEXPECTED.name)\n                    except KeyError:\n                        continue\n\n            dot.render(view=False, overwrite_source=True)\n\n    def _find_best_parents(self, subject_node: Node) -&gt; Node | tuple[Node, Node]:\n        \"\"\" Attempt to find the best parents.\n\n            Args:\n                subject_node: Node to determine best parents for.\n\n            Returns:\n                best_node: Best parent (single).\n                best_nodes: Best parents (tuple).\n\n            TODO:\n                What's actually defined as being the best parent? AFAIK it was any non-temporary \n                node but will need to double check.\n\n            FIXME:\n                Avoid mixing different returns. This method can either return a single Node or \n                a tuple of Nodes.\n        \"\"\"\n        # if the node is a constant declaration, return itself\n        if subject_node.operation in Operation_Type.GENERIC_CONSTANT_DECLARATION:\n          return subject_node\n\n        # if node is a GLOBAL variable and is declared, return itself as being the best (this assumes that it is either an input or output of the function)\n        if subject_node.operation in Operation_Type.GENERIC_VARIABLE_DECLARATION and subject_node.spirv_id in self.declared_symbols:\n            return subject_node\n\n        # if variable is just storing a constant\n        if subject_node.operation is Operation.STORE and subject_node.input_left.operation in Operation_Type.GENERIC_CONSTANT_DECLARATION:\n            return subject_node.input_left\n\n        if subject_node.operation is Operation.STORE:\n            return subject_node.input_left\n\n        if subject_node.operation is Operation.ARRAY_INDEX:\n            return subject_node\n\n        if subject_node.operation is Operation.ARRAY_LOAD:\n            return subject_node\n\n        if subject_node.operation is Operation.ARRAY_STORE:\n            return subject_node\n\n        # a non existant id means that it was created for either loading or arithmetic\n        if subject_node.spirv_id not in self.declared_symbols:\n\n            # if a temp id was only created for loading an existing value\n            if subject_node.operation is Operation.LOAD:\n                return self._find_best_parents(subject_node.input_left)\n\n            elif subject_node.operation in Operation_Type.ARITHMETIC:\n                # tandem arithmetic means that this node references a previous node that is also an arithmetic node\n                # for example:\n                # %titan_id_0 = OpIAdd %int %const_3 %const_5\n                # %titan_id_1 = OpIMul %int %titan_id_0 %const_2\n                # \n                # we want to retain the refereced arithmetic node id (%titan_id_0) in this case, because it is the best parent for the left side\n                # so tandem_arith_left will be True\n                tandem_arith_left = True if subject_node.input_left.operation in Operation_Type.ARITHMETIC else False\n                tandem_arith_right = True if subject_node.input_right.operation in Operation_Type.ARITHMETIC else False\n                # print(f\"tal: {tandem_arith_left} - tar: {tandem_arith_right}\")\n\n                if tandem_arith_left and tandem_arith_right:\n                    return (subject_node.input_left, subject_node.input_right)\n                elif tandem_arith_left:\n                    return (subject_node.input_left, self._find_best_parents(subject_node.input_right))\n                elif tandem_arith_right:\n                    return (self._find_best_parents(subject_node.input_left), subject_node.input_right)\n                else:\n                    return (self._find_best_parents(subject_node.input_left), self._find_best_parents(subject_node.input_right))\n\n            # if its an actual comparison (and not a decision node), find the best parent nodes\n            elif subject_node.operation in Operation_Type.COMPARISON and subject_node.operation is not Operation.DECISION:\n                return (self._find_best_parents(subject_node.input_left), self._find_best_parents(subject_node.input_right))\n\n            # if its a decision node, the best node will be the comparison node that just came before it, so return it\n            elif subject_node.operation is Operation.DECISION:\n                return subject_node.data[0] \n\n            elif subject_node.operation in Operation_Type.BITWISE:\n                return (self._find_best_parents(subject_node.input_left), self._find_best_parents(subject_node.input_right))\n\n        raise Exception(f\"was unable to determine anything for node: {subject_node} -- missing case?\")\n\n    def _evaluate_parents_for_non_temp_id(self, current_node: Node) -&gt; list:\n        \"\"\" Method to evaluate the parents of a node for non-temporary IDs.\n\n            Calls ``titan.machine._find_best_parents`` internally, kinda acts like a wrapper function\n            to handle the scuffed returns.\n\n            Args:\n                current_node: Node to determine best parents for.\n\n            Returns:\n                The ID(s) of the best parent(s). Can either be a one or two-element list.\n        \"\"\"\n        # a temp id is defined as a LOAD instruction which references an existing symbol\n        # in spirv, this looks something like:\n        #   %1 = OpLoad %type_int %a\n        # where %1 is a temporary id containing the value of %a\n\n        best = self._find_best_parents(current_node)\n        node_names = []\n\n        try:\n            node_names = [best[0].spirv_id, best[1].spirv_id]\n        except:\n            node_names = [best.spirv_id]\n\n        return node_names\n\n    def clean_graph(self):\n        \"\"\" Method to remove temporary nodes generated by SPIR-V. \n\n            Does not return anything, overwrites the existing node list.\n        \"\"\"\n        logging.debug(f\"attempting to clean/remove temporary/unnecessary nodes...\")\n\n        def _fetch_last_node(node_dict, node_name: str):\n            if node_name in node_dict:\n                return node_dict[node_name][-1]\n            else:\n                raise Exception(TitanErrors.UNEXPECTED.value, TitanErrors.UNEXPECTED.name)\n\n        def _update_node_dict(node_dict, node_name: str, node_ctx: NodeContext):\n            if node_name in node_dict:\n                node_dict[node_name].append(Node(node_ctx))\n            else:\n                node_dict[node_name] = [Node(node_ctx)]\n\n\n\n        for function in self.content.keys():\n            clean_nodes: hinting.spirv_id_and_node = {}\n            tick_ordered_nodes = self._sort_body_nodes_by_tick(function)\n\n            logging.debug(f\"tick: 0\")\n            for node in tick_ordered_nodes[0]:\n                if node.spirv_id not in clean_nodes:\n                    logging.debug(f\"{node.spirv_id} did not exist in clean nodes and was added: {node}\")\n                    clean_nodes[node.spirv_id] = [node]\n                else:\n                    logging.debug(f\"{node.spirv_id} was appended to clean nodes list: {node}\")\n                    clean_nodes[node.spirv_id].append(node)\n\n            for tick in range(1, len(tick_ordered_nodes.keys())): #TODO: remove .keys() call\n                logging.debug(f\"tick: {tick}\")\n                _debug_str = f\"node: {node}\"\n                for node in tick_ordered_nodes[tick]:\n\n                    if node.spirv_id not in self.declared_symbols and node.operation is Operation.LOAD:\n                        _debug_str = _debug_str + f\"....ignored ({node.spirv_id})\"\n                        continue\n\n                    # logging.debug(_debug_str)\n\n                    # if _eval_parents_for_non_temp_id(node) returns a spirv id\n                    # we should just try and reference the latest one in the clean\n                    # nodes dict\n                    logging.debug(f\"{node}\")\n                    best_node_names = self._evaluate_parents_for_non_temp_id(node)\n                    logging.debug(f\"returned with {best_node_names}\")\n\n                    if len(best_node_names) == 1:\n                        # print(f\"returned with one node: {best_node_names[0]}\")\n                        # logging.debug(f\"returned with one node: {best_node_names[0]}\")\n\n                        if self.does_node_exist_in_dict(clean_nodes, node.spirv_id):\n                            n = _fetch_last_node(clean_nodes, best_node_names[0])\n\n                            new_ctx = NodeContext(\n                                line_no=node.spirv_line_no, id=node.spirv_id, type_id=node.type_id,\n                                input_left=n, input_right=None, operation=node.operation, data=node.data,\n                                is_comparison=node.is_comparison, array_id=node.array_id, array_index_id=node.array_index_id\n                            )\n\n                            logging.debug(f\"updating with the following context: {new_ctx}\")\n                            _update_node_dict(clean_nodes, node.spirv_id, new_ctx)\n\n                        else:\n\n                            # print(f\"-[Verilog_ASM.clean_graph] node {node} does not exist in clean dict\")\n\n                            if node.is_comparison:\n                                # accessing the node data should fetch the related comparison line &amp; its info\n                                # we assume that it is in the 0th index\n                                n = _fetch_last_node(clean_nodes, node.data[0].spirv_id)\n\n                                new_ctx = NodeContext(\n                                    line_no=node.spirv_line_no, id=node.spirv_id, type_id=node.type_id,\n                                    input_left=node.input_left, input_right=node.input_right,\n                                    operation=node.operation, data=[n], is_comparison=node.is_comparison,\n                                    array_id=node.array_id, array_index_id=node.array_index_id\n                                )\n\n                            else:\n                                # TODO: is there a way to get the current context of the node without recreating it?\n                                new_ctx = NodeContext(\n                                    line_no=node.spirv_line_no, id=node.spirv_id, type_id=node.type_id,\n                                    input_left=node.input_left, input_right=node.input_right, \n                                    operation=node.operation, data=node.data, is_comparison=node.is_comparison,\n                                    array_id=node.array_id, array_index_id=node.array_index_id\n                                )\n\n                            logging.debug(f\"updating with the following context: {new_ctx}\")\n                            _update_node_dict(clean_nodes, node.spirv_id, new_ctx)\n\n\n\n                    elif len(best_node_names) == 2:\n                        # print(f\"returned with two nodes: {best_node_names}\")\n                        logging.debug(f\"returned with two nodes: {best_node_names}\")\n                        n1 = _fetch_last_node(clean_nodes, best_node_names[0])\n                        n2 = _fetch_last_node(clean_nodes, best_node_names[1])\n\n                        # print(f\"\\t{n1}\\n\\t{n2}\")\n                        logging.debug(f\"\\tnode 1:{n1}\")\n                        logging.debug(f\"\\tnode 2: {n2}\")\n\n                        new_ctx = NodeContext(\n                            line_no=node.spirv_line_no, id=node.spirv_id, type_id=node.type_id,\n                            input_left=n1, input_right=n2, operation=node.operation, data=node.data,\n                            is_comparison=node.is_comparison, array_id=node.array_id, array_index_id=node.array_index_id\n                        )\n\n                        _update_node_dict(clean_nodes, node.spirv_id, new_ctx)\n\n            logging.debug(f\"---- symbol dump ----\")\n            for symbol in clean_nodes:\n                logging.debug(symbol)\n                for node in clean_nodes[symbol]:\n                    logging.debug(f\"\\t{node}\")\n\n            logging.debug(f\"---- end symbol dump ----\")\n\n            self._overwrite_body_nodes(function, clean_nodes)\n</code></pre>"},{"location":"reference-docs/compiler/compiler/node/#titan.compiler.node.NodeAssembler._encode_parents","title":"<code>_encode_parents(node)</code>  <code>staticmethod</code>","text":"<p>Numerically encode the position of the parents.</p> Note <ul> <li>0: No parents exist.</li> <li>1: Left parent exists.</li> <li>2: Right parent exists.</li> <li>3: Both parents exist.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Node</code> <p>Node to encode the parents of.</p> required Source code in <code>titan/compiler/node.py</code> <pre><code>@staticmethod\ndef _encode_parents(node: Node) -&gt; int:\n    \"\"\" Numerically encode the position of the parents.\n\n        Note:\n            - 0: No parents exist.\n            - 1: Left parent exists.\n            - 2: Right parent exists.\n            - 3: Both parents exist.\n\n        Args:\n            node: Node to encode the parents of.\n    \"\"\"\n\n    count = 0\n\n    if node.input_left is not None:\n        count += 1\n\n    if node.input_right is not None:\n        count += 2\n\n    return count\n</code></pre>"},{"location":"reference-docs/compiler/compiler/node/#titan.compiler.node.NodeAssembler._evaluate_parents_for_non_temp_id","title":"<code>_evaluate_parents_for_non_temp_id(current_node)</code>","text":"<p>Method to evaluate the parents of a node for non-temporary IDs.</p> <p>Calls <code>titan.machine._find_best_parents</code> internally, kinda acts like a wrapper function to handle the scuffed returns.</p> <p>Parameters:</p> Name Type Description Default <code>current_node</code> <code>Node</code> <p>Node to determine best parents for.</p> required <p>Returns:</p> Type Description <code>list</code> <p>The ID(s) of the best parent(s). Can either be a one or two-element list.</p> Source code in <code>titan/compiler/node.py</code> <pre><code>def _evaluate_parents_for_non_temp_id(self, current_node: Node) -&gt; list:\n    \"\"\" Method to evaluate the parents of a node for non-temporary IDs.\n\n        Calls ``titan.machine._find_best_parents`` internally, kinda acts like a wrapper function\n        to handle the scuffed returns.\n\n        Args:\n            current_node: Node to determine best parents for.\n\n        Returns:\n            The ID(s) of the best parent(s). Can either be a one or two-element list.\n    \"\"\"\n    # a temp id is defined as a LOAD instruction which references an existing symbol\n    # in spirv, this looks something like:\n    #   %1 = OpLoad %type_int %a\n    # where %1 is a temporary id containing the value of %a\n\n    best = self._find_best_parents(current_node)\n    node_names = []\n\n    try:\n        node_names = [best[0].spirv_id, best[1].spirv_id]\n    except:\n        node_names = [best.spirv_id]\n\n    return node_names\n</code></pre>"},{"location":"reference-docs/compiler/compiler/node/#titan.compiler.node.NodeAssembler._find_best_parents","title":"<code>_find_best_parents(subject_node)</code>","text":"<p>Attempt to find the best parents.</p> <p>Parameters:</p> Name Type Description Default <code>subject_node</code> <code>Node</code> <p>Node to determine best parents for.</p> required <p>Returns:</p> Name Type Description <code>best_node</code> <code>Node | tuple[Node, Node]</code> <p>Best parent (single).</p> <code>best_nodes</code> <code>Node | tuple[Node, Node]</code> <p>Best parents (tuple).</p> TODO <p>What's actually defined as being the best parent? AFAIK it was any non-temporary  node but will need to double check.</p> FIXME <p>Avoid mixing different returns. This method can either return a single Node or  a tuple of Nodes.</p> Source code in <code>titan/compiler/node.py</code> <pre><code>def _find_best_parents(self, subject_node: Node) -&gt; Node | tuple[Node, Node]:\n    \"\"\" Attempt to find the best parents.\n\n        Args:\n            subject_node: Node to determine best parents for.\n\n        Returns:\n            best_node: Best parent (single).\n            best_nodes: Best parents (tuple).\n\n        TODO:\n            What's actually defined as being the best parent? AFAIK it was any non-temporary \n            node but will need to double check.\n\n        FIXME:\n            Avoid mixing different returns. This method can either return a single Node or \n            a tuple of Nodes.\n    \"\"\"\n    # if the node is a constant declaration, return itself\n    if subject_node.operation in Operation_Type.GENERIC_CONSTANT_DECLARATION:\n      return subject_node\n\n    # if node is a GLOBAL variable and is declared, return itself as being the best (this assumes that it is either an input or output of the function)\n    if subject_node.operation in Operation_Type.GENERIC_VARIABLE_DECLARATION and subject_node.spirv_id in self.declared_symbols:\n        return subject_node\n\n    # if variable is just storing a constant\n    if subject_node.operation is Operation.STORE and subject_node.input_left.operation in Operation_Type.GENERIC_CONSTANT_DECLARATION:\n        return subject_node.input_left\n\n    if subject_node.operation is Operation.STORE:\n        return subject_node.input_left\n\n    if subject_node.operation is Operation.ARRAY_INDEX:\n        return subject_node\n\n    if subject_node.operation is Operation.ARRAY_LOAD:\n        return subject_node\n\n    if subject_node.operation is Operation.ARRAY_STORE:\n        return subject_node\n\n    # a non existant id means that it was created for either loading or arithmetic\n    if subject_node.spirv_id not in self.declared_symbols:\n\n        # if a temp id was only created for loading an existing value\n        if subject_node.operation is Operation.LOAD:\n            return self._find_best_parents(subject_node.input_left)\n\n        elif subject_node.operation in Operation_Type.ARITHMETIC:\n            # tandem arithmetic means that this node references a previous node that is also an arithmetic node\n            # for example:\n            # %titan_id_0 = OpIAdd %int %const_3 %const_5\n            # %titan_id_1 = OpIMul %int %titan_id_0 %const_2\n            # \n            # we want to retain the refereced arithmetic node id (%titan_id_0) in this case, because it is the best parent for the left side\n            # so tandem_arith_left will be True\n            tandem_arith_left = True if subject_node.input_left.operation in Operation_Type.ARITHMETIC else False\n            tandem_arith_right = True if subject_node.input_right.operation in Operation_Type.ARITHMETIC else False\n            # print(f\"tal: {tandem_arith_left} - tar: {tandem_arith_right}\")\n\n            if tandem_arith_left and tandem_arith_right:\n                return (subject_node.input_left, subject_node.input_right)\n            elif tandem_arith_left:\n                return (subject_node.input_left, self._find_best_parents(subject_node.input_right))\n            elif tandem_arith_right:\n                return (self._find_best_parents(subject_node.input_left), subject_node.input_right)\n            else:\n                return (self._find_best_parents(subject_node.input_left), self._find_best_parents(subject_node.input_right))\n\n        # if its an actual comparison (and not a decision node), find the best parent nodes\n        elif subject_node.operation in Operation_Type.COMPARISON and subject_node.operation is not Operation.DECISION:\n            return (self._find_best_parents(subject_node.input_left), self._find_best_parents(subject_node.input_right))\n\n        # if its a decision node, the best node will be the comparison node that just came before it, so return it\n        elif subject_node.operation is Operation.DECISION:\n            return subject_node.data[0] \n\n        elif subject_node.operation in Operation_Type.BITWISE:\n            return (self._find_best_parents(subject_node.input_left), self._find_best_parents(subject_node.input_right))\n\n    raise Exception(f\"was unable to determine anything for node: {subject_node} -- missing case?\")\n</code></pre>"},{"location":"reference-docs/compiler/compiler/node/#titan.compiler.node.NodeAssembler._overwrite_body_nodes","title":"<code>_overwrite_body_nodes(module_name, nodes)</code>","text":"<p>Overwrite an existing set of nodes for a given module/function.</p> <p>Parameters:</p> Name Type Description Default <code>module_name</code> <code>str</code> <p>The module to modify.</p> required <code>nodes</code> <code>List[Node]</code> <p>Updated list of nodes.</p> required Note <p>The parameter \"module_name\" used to be called \"fn_name\". This was modified during a rewrite, and this message is a reminder of that.</p> Source code in <code>titan/compiler/node.py</code> <pre><code>def _overwrite_body_nodes(self, module_name: str, nodes: List[Node]):\n    \"\"\" Overwrite an existing set of nodes for a given module/function.\n\n        Args:\n            module_name: The module to modify.\n            nodes: Updated list of nodes.\n\n        Note:\n            The parameter \"module_name\" used to be called \"fn_name\". This was modified during a rewrite,\n            and this message is a reminder of that.\n    \"\"\"\n\n    # self.content[module_name].nodes = nodes\n    self.content[module_name].body_nodes = nodes\n</code></pre>"},{"location":"reference-docs/compiler/compiler/node/#titan.compiler.node.NodeAssembler._parent_exists","title":"<code>_parent_exists(node)</code>  <code>staticmethod</code>","text":"<p>Check whether the node has any parents.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Node</code> <p>Node to check parents of.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if any parents exist, else false.</p> Source code in <code>titan/compiler/node.py</code> <pre><code>@staticmethod\ndef _parent_exists(node: Node) -&gt; bool:\n    \"\"\" Check whether the node has any parents.\n\n        Args:\n            node: Node to check parents of.\n\n        Returns:\n            True if any parents exist, else false.\n    \"\"\"\n    return True if node.input_left is not None or node.input_right is not None else False\n</code></pre>"},{"location":"reference-docs/compiler/compiler/node/#titan.compiler.node.NodeAssembler._sort_body_nodes_by_tick","title":"<code>_sort_body_nodes_by_tick(module_name)</code>","text":"<p>Sorts the nodes in ascending order (0 -&gt; max tick).</p> <p>Parameters:</p> Name Type Description Default <code>module_name</code> <code>str</code> <p>Name of module to sort nodes of.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>New dictionary containing sorted nodes, with the tick as the key.</p> Source code in <code>titan/compiler/node.py</code> <pre><code>def _sort_body_nodes_by_tick(self, module_name: str) -&gt; dict:\n    \"\"\" Sorts the nodes in ascending order (0 -&gt; max tick).\n\n        Args:\n            module_name: Name of module to sort nodes of.\n\n        Returns:\n            New dictionary containing sorted nodes, with the tick as the key.\n    \"\"\"\n    tick_dict = {}\n\n    # logging.debug(f\"nodes before {len(self.content[module_name].body_nodes)}: {self.content[module_name].body_nodes}\")\n    # TODO: can we just use list comprehension on this?\n    for symbols in self.content[module_name].body_nodes:\n        for node in self.content[module_name].body_nodes[symbols]:\n\n            if node.tick not in tick_dict.keys():\n                tick_dict[node.tick] = []\n\n            tick_dict[node.tick].append(node)\n    # logging.debug(f\"nodes after {len(tick_dict)}: {tick_dict}\")\n    return tick_dict\n</code></pre>"},{"location":"reference-docs/compiler/compiler/node/#titan.compiler.node.NodeAssembler.add_body_node_to_module","title":"<code>add_body_node_to_module(module_name, node)</code>","text":"<p>Add a body node to an existing module.</p> <p>Checks if the node exists by using the associated SPIR-V ID, creating it if not. Then appends the node to that SPIR-V ID.</p> <p>Parameters:</p> Name Type Description Default <code>module_name</code> <code>str</code> <p>Module to ad to.</p> required <code>node</code> <code>Node</code> <p>Node to add.</p> required Source code in <code>titan/compiler/node.py</code> <pre><code>def add_body_node_to_module(self, module_name: str, node: Node):\n    \"\"\" Add a body node to an existing module.\n\n        Checks if the node exists by using the associated SPIR-V ID, creating it if not.\n        Then appends the node to that SPIR-V ID.\n\n        Args:\n            module_name: Module to ad to.\n            node: Node to add.\n    \"\"\"\n    if not self.node_exists(module_name, node.spirv_id):\n        self.content[module_name].body_nodes[node.spirv_id] = []\n\n    self.content[module_name].body_nodes[node.spirv_id].append(node)\n</code></pre>"},{"location":"reference-docs/compiler/compiler/node/#titan.compiler.node.NodeAssembler.add_input_to_module","title":"<code>add_input_to_module(module_name, symbol)</code>","text":"<p>Add an input to a module.</p> <p>Parameters:</p> Name Type Description Default <code>module_name</code> <code>str</code> <p>Module to add to.</p> required <code>symbol</code> <code>str</code> <p>Symbol to add as an input.</p> required Source code in <code>titan/compiler/node.py</code> <pre><code>def add_input_to_module(self, module_name: str, symbol: str):\n    \"\"\" Add an input to a module.\n\n        Args:\n            module_name: Module to add to.\n            symbol: Symbol to add as an input.\n    \"\"\"\n    self.content[module_name].inputs.append(symbol)\n</code></pre>"},{"location":"reference-docs/compiler/compiler/node/#titan.compiler.node.NodeAssembler.add_output_to_module","title":"<code>add_output_to_module(module_name, symbol)</code>","text":"<p>Add an output to a module.</p> <p>Parameters:</p> Name Type Description Default <code>module_name</code> <code>str</code> <p>Module to add to.</p> required <code>symbol</code> <code>str</code> <p>Symbol to add as an output.</p> required Source code in <code>titan/compiler/node.py</code> <pre><code>def add_output_to_module(self, module_name: str, symbol: str):\n    \"\"\" Add an output to a module.\n\n        Args:\n            module_name: Module to add to.\n            symbol: Symbol to add as an output.\n    \"\"\"\n    self.content[module_name].outputs.append(symbol)\n</code></pre>"},{"location":"reference-docs/compiler/compiler/node/#titan.compiler.node.NodeAssembler.add_type_context_to_module","title":"<code>add_type_context_to_module(module_name, type_id, type_context)</code>","text":"<p>Add a type context to a function.</p> <p>Parameters:</p> Name Type Description Default <code>module_name</code> <code>str</code> <p>Module to add to.</p> required <code>type_id</code> <code>str</code> <p>ID to associate with the type.</p> required <code>type_context</code> <code>NodeTypeContext</code> <p>Context about the type.</p> required Source code in <code>titan/compiler/node.py</code> <pre><code>def add_type_context_to_module(self, module_name: str, type_id: str, type_context: NodeTypeContext):\n    \"\"\" Add a type context to a function.\n\n        Args:\n            module_name: Module to add to.\n            type_id: ID to associate with the type.\n            type_context: Context about the type.\n    \"\"\"\n    self.content[module_name].types[type_id] = type_context\n</code></pre>"},{"location":"reference-docs/compiler/compiler/node/#titan.compiler.node.NodeAssembler.clean_graph","title":"<code>clean_graph()</code>","text":"<p>Method to remove temporary nodes generated by SPIR-V. </p> <p>Does not return anything, overwrites the existing node list.</p> Source code in <code>titan/compiler/node.py</code> <pre><code>def clean_graph(self):\n    \"\"\" Method to remove temporary nodes generated by SPIR-V. \n\n        Does not return anything, overwrites the existing node list.\n    \"\"\"\n    logging.debug(f\"attempting to clean/remove temporary/unnecessary nodes...\")\n\n    def _fetch_last_node(node_dict, node_name: str):\n        if node_name in node_dict:\n            return node_dict[node_name][-1]\n        else:\n            raise Exception(TitanErrors.UNEXPECTED.value, TitanErrors.UNEXPECTED.name)\n\n    def _update_node_dict(node_dict, node_name: str, node_ctx: NodeContext):\n        if node_name in node_dict:\n            node_dict[node_name].append(Node(node_ctx))\n        else:\n            node_dict[node_name] = [Node(node_ctx)]\n\n\n\n    for function in self.content.keys():\n        clean_nodes: hinting.spirv_id_and_node = {}\n        tick_ordered_nodes = self._sort_body_nodes_by_tick(function)\n\n        logging.debug(f\"tick: 0\")\n        for node in tick_ordered_nodes[0]:\n            if node.spirv_id not in clean_nodes:\n                logging.debug(f\"{node.spirv_id} did not exist in clean nodes and was added: {node}\")\n                clean_nodes[node.spirv_id] = [node]\n            else:\n                logging.debug(f\"{node.spirv_id} was appended to clean nodes list: {node}\")\n                clean_nodes[node.spirv_id].append(node)\n\n        for tick in range(1, len(tick_ordered_nodes.keys())): #TODO: remove .keys() call\n            logging.debug(f\"tick: {tick}\")\n            _debug_str = f\"node: {node}\"\n            for node in tick_ordered_nodes[tick]:\n\n                if node.spirv_id not in self.declared_symbols and node.operation is Operation.LOAD:\n                    _debug_str = _debug_str + f\"....ignored ({node.spirv_id})\"\n                    continue\n\n                # logging.debug(_debug_str)\n\n                # if _eval_parents_for_non_temp_id(node) returns a spirv id\n                # we should just try and reference the latest one in the clean\n                # nodes dict\n                logging.debug(f\"{node}\")\n                best_node_names = self._evaluate_parents_for_non_temp_id(node)\n                logging.debug(f\"returned with {best_node_names}\")\n\n                if len(best_node_names) == 1:\n                    # print(f\"returned with one node: {best_node_names[0]}\")\n                    # logging.debug(f\"returned with one node: {best_node_names[0]}\")\n\n                    if self.does_node_exist_in_dict(clean_nodes, node.spirv_id):\n                        n = _fetch_last_node(clean_nodes, best_node_names[0])\n\n                        new_ctx = NodeContext(\n                            line_no=node.spirv_line_no, id=node.spirv_id, type_id=node.type_id,\n                            input_left=n, input_right=None, operation=node.operation, data=node.data,\n                            is_comparison=node.is_comparison, array_id=node.array_id, array_index_id=node.array_index_id\n                        )\n\n                        logging.debug(f\"updating with the following context: {new_ctx}\")\n                        _update_node_dict(clean_nodes, node.spirv_id, new_ctx)\n\n                    else:\n\n                        # print(f\"-[Verilog_ASM.clean_graph] node {node} does not exist in clean dict\")\n\n                        if node.is_comparison:\n                            # accessing the node data should fetch the related comparison line &amp; its info\n                            # we assume that it is in the 0th index\n                            n = _fetch_last_node(clean_nodes, node.data[0].spirv_id)\n\n                            new_ctx = NodeContext(\n                                line_no=node.spirv_line_no, id=node.spirv_id, type_id=node.type_id,\n                                input_left=node.input_left, input_right=node.input_right,\n                                operation=node.operation, data=[n], is_comparison=node.is_comparison,\n                                array_id=node.array_id, array_index_id=node.array_index_id\n                            )\n\n                        else:\n                            # TODO: is there a way to get the current context of the node without recreating it?\n                            new_ctx = NodeContext(\n                                line_no=node.spirv_line_no, id=node.spirv_id, type_id=node.type_id,\n                                input_left=node.input_left, input_right=node.input_right, \n                                operation=node.operation, data=node.data, is_comparison=node.is_comparison,\n                                array_id=node.array_id, array_index_id=node.array_index_id\n                            )\n\n                        logging.debug(f\"updating with the following context: {new_ctx}\")\n                        _update_node_dict(clean_nodes, node.spirv_id, new_ctx)\n\n\n\n                elif len(best_node_names) == 2:\n                    # print(f\"returned with two nodes: {best_node_names}\")\n                    logging.debug(f\"returned with two nodes: {best_node_names}\")\n                    n1 = _fetch_last_node(clean_nodes, best_node_names[0])\n                    n2 = _fetch_last_node(clean_nodes, best_node_names[1])\n\n                    # print(f\"\\t{n1}\\n\\t{n2}\")\n                    logging.debug(f\"\\tnode 1:{n1}\")\n                    logging.debug(f\"\\tnode 2: {n2}\")\n\n                    new_ctx = NodeContext(\n                        line_no=node.spirv_line_no, id=node.spirv_id, type_id=node.type_id,\n                        input_left=n1, input_right=n2, operation=node.operation, data=node.data,\n                        is_comparison=node.is_comparison, array_id=node.array_id, array_index_id=node.array_index_id\n                    )\n\n                    _update_node_dict(clean_nodes, node.spirv_id, new_ctx)\n\n        logging.debug(f\"---- symbol dump ----\")\n        for symbol in clean_nodes:\n            logging.debug(symbol)\n            for node in clean_nodes[symbol]:\n                logging.debug(f\"\\t{node}\")\n\n        logging.debug(f\"---- end symbol dump ----\")\n\n        self._overwrite_body_nodes(function, clean_nodes)\n</code></pre>"},{"location":"reference-docs/compiler/compiler/node/#titan.compiler.node.NodeAssembler.create_module","title":"<code>create_module(module_name)</code>","text":"<p>Method to create a new, empty module class. </p> <p>Parameters:</p> Name Type Description Default <code>module_name</code> <code>str</code> <p>Name of the module.</p> required Source code in <code>titan/compiler/node.py</code> <pre><code>def create_module(self, module_name: str):\n    \"\"\" Method to create a new, empty module class. \n\n        Args:\n            module_name: Name of the module.\n    \"\"\"\n    self.content[module_name] = NodeModuleData()\n</code></pre>"},{"location":"reference-docs/compiler/compiler/node/#titan.compiler.node.NodeAssembler.does_node_exist_in_dict","title":"<code>does_node_exist_in_dict(node_dict, node_id)</code>","text":"<p>Checks if a node exists in the node dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>node_dict</code> <code>dict[Node]</code> <p>Dictionary containing Nodes.</p> required <code>node_id</code> <code>str</code> <p>ID of the node to check for.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if node exists in the dictionary, else false.</p> Source code in <code>titan/compiler/node.py</code> <pre><code>def does_node_exist_in_dict(self, node_dict: dict[Node], node_id: str) -&gt; bool:\n    \"\"\" Checks if a node exists in the node dictionary.\n\n        Args:\n            node_dict: Dictionary containing Nodes.\n            node_id: ID of the node to check for.\n\n        Returns:\n            True if node exists in the dictionary, else false.\n    \"\"\"\n    return True if node_id in node_dict else False\n</code></pre>"},{"location":"reference-docs/compiler/compiler/node/#titan.compiler.node.NodeAssembler.generate_dot_graph","title":"<code>generate_dot_graph(file_name_suffix='', clean_nodes=None, dark_mode=True)</code>","text":"<p>Generates Graphviz dot graphs of the dataflow of a function. Requires the <code>graphviz</code> package.</p> <p>Parameters:</p> Name Type Description Default <code>file_name_suffix</code> <code>str</code> <p>String to append to the filename.</p> <code>''</code> <code>clean_nodes</code> <p>List of clean/optimised nodes.</p> <code>None</code> Source code in <code>titan/compiler/node.py</code> <pre><code>def generate_dot_graph(self, file_name_suffix: str = \"\", clean_nodes = None, dark_mode: bool = True):\n    \"\"\" Generates Graphviz dot graphs of the dataflow of a function. Requires the ``graphviz`` package.\n\n        Args:\n            file_name_suffix: String to append to the filename.\n            clean_nodes: List of clean/optimised nodes.\n    \"\"\"\n    for module in self.content.keys():\n        dot = graphviz.Digraph(comment=f\"digraph for {module}\", filename=f\"digraph_{module}{file_name_suffix}.dot\", directory=\"dots\") \n\n        # dark mode\n        if dark_mode:\n            dot.attr(bgcolor=\"gray10\")\n            dot.attr(color=\"white\")\n            dot.attr(fontcolor=\"white\")\n\n        if clean_nodes is None:\n            x = self._sort_body_nodes_by_tick(module)\n        else:\n            x = clean_nodes\n\n        for k in range(0, len(x.keys())):\n            with dot.subgraph(name=f\"cluster_tick_{k}\") as ds:\n                ds.attr(style=\"dashed\")\n                ds.attr(label=f\"tick {k}\")\n\n                try:\n                    for v in x[k]:\n                        current_node_label = f\"{v.spirv_id}_{k}\"\n                        ds.node(current_node_label, f\"{v.spirv_id} at tick {k} \\n({v.operation})\", color=\"white\", fontcolor=\"white\")\n\n                        if self._parent_exists(v):\n                            # check which parents exist\n                            parent_num = self._encode_parents(v)\n                            match parent_num:\n                                case 1:\n                                    # ds.edge()\n                                    # get parent name/spirv id\n                                    parent_id_label = f\"{v.input_left.spirv_id}_{v.input_left.tick}\"\n                                    ds.edge(parent_id_label, current_node_label, color=\"white\")\n\n                                case 2:\n                                    parent_id_label = f\"{v.input_right.spirv_id}_{v.input_right.tick}\"\n                                    ds.edge(parent_id_label, current_node_label, color=\"white\")\n                                case 3:\n\n                                    # TODO: need a better way to determine correct id &amp; tick to use when dealing with decision nodes\n                                    # this solution will fail if it's basically a stack of Operation.STOREs because it only goes back\n                                    # two nodes.\n                                    if v.is_comparison:\n                                        if v.input_left.operation is Operation.STORE:\n                                            parent_l_id_label = f\"{v.input_left.input_left.spirv_id}_{self.get_node(module, v.input_left.input_left.spirv_id).tick}\"\n\n                                        if v.input_right.operation is Operation.STORE:\n                                            parent_r_id_label = f\"{v.input_right.input_right.spirv_id}_{self.get_node(module, v.input_right.input_right.spirv_id).tick}\"\n                                    else:\n                                        parent_l_id_label = f\"{v.input_left.spirv_id}_{v.input_left.tick}\"\n                                        parent_r_id_label = f\"{v.input_right.spirv_id}_{v.input_right.tick}\"\n\n                                    ds.edge(parent_l_id_label, current_node_label, color=\"white\" if not v.is_comparison else \"green\")\n                                    ds.edge(parent_r_id_label, current_node_label, color=\"white\" if not v.is_comparison else \"red\")\n\n                                    if v.is_comparison:\n                                        parent_compare_id_label = f\"{v.data[0].spirv_id}_{v.data[0].tick}\"\n                                        ds.edge(parent_compare_id_label, current_node_label, color=\"white\")\n\n                                case _:\n                                    # should be unreachable\n                                    raise Exception(f\"{TitanErrors.UNEXPECTED.value} - got {parent_num} parents, but parents exist.\", TitanErrors.UNEXPECTED.name)\n                except KeyError:\n                    continue\n\n        dot.render(view=False, overwrite_source=True)\n</code></pre>"},{"location":"reference-docs/compiler/compiler/node/#titan.compiler.node.NodeAssembler.get_array_node_dimensions","title":"<code>get_array_node_dimensions(module_name, node_id)</code>","text":"<p>Get the array dimensions using the ID of the array.</p> <p>Parameters:</p> Name Type Description Default <code>module_name</code> <code>str</code> <p>Module to get from.</p> required <code>node_id</code> <code>str</code> <p>ID of array.</p> required <p>Returns:</p> Name Type Description <code>array_dimensions</code> <code>int | tuple[int]</code> <p>Defined array dimensions.</p> Source code in <code>titan/compiler/node.py</code> <pre><code>def get_array_node_dimensions(self, module_name: str, node_id: str) -&gt; int | tuple[int]:\n    \"\"\" Get the array dimensions using the ID of the array.\n\n        Args:\n            module_name: Module to get from.\n            node_id: ID of array.\n\n        Returns:\n            array_dimensions: Defined array dimensions.\n    \"\"\"\n\n    array_node = self.get_node(module_name, node_id)\n    array_type_id = self.get_type_context_from_module(module_name, array_node.type_id)\n    array_max_size = self.get_node(module_name, array_type_id.array_dimension_id).data[0]\n\n    return array_max_size\n</code></pre>"},{"location":"reference-docs/compiler/compiler/node/#titan.compiler.node.NodeAssembler.get_datatype_from_id","title":"<code>get_datatype_from_id(module_name, id)</code>","text":"<p>Return primative type from ID.</p> <p>Parameters:</p> Name Type Description Default <code>module_name</code> <code>str</code> <p>Module to check in.</p> required <code>id</code> <code>str</code> <p>ID to query.</p> required <p>Returns:</p> Type Description <code>DataType</code> <p>Primative datatype of ID, if it exists.</p> Source code in <code>titan/compiler/node.py</code> <pre><code>def get_datatype_from_id(self, module_name: str, id: str) -&gt; DataType:\n    \"\"\" Return primative type from ID.\n\n        Args:\n            module_name: Module to check in.\n            id: ID to query.\n\n        Returns:\n            Primative datatype of ID, if it exists.\n    \"\"\"\n    return self.content[module_name].types[id].type\n</code></pre>"},{"location":"reference-docs/compiler/compiler/node/#titan.compiler.node.NodeAssembler.get_node","title":"<code>get_node(module_name, node_id)</code>","text":"<p>Gets the latest node given a node ID in a given function.</p> <p>Parameters:</p> Name Type Description Default <code>module_name</code> <code>str</code> <p>Module to check in.</p> required <code>node_id</code> <code>str</code> <p>Node ID to check for.</p> required <p>Returns:</p> Type Description <code>Node</code> <p>Latest node for the given node ID.</p> Source code in <code>titan/compiler/node.py</code> <pre><code>def get_node(self, module_name: str, node_id: str) -&gt; Node:\n    \"\"\" Gets the latest node given a node ID in a given function.\n\n        Args:\n            module_name: Module to check in.\n            node_id: Node ID to check for.\n\n        Returns:\n            Latest node for the given node ID.\n    \"\"\"\n    # -1 for the very latest node\n    return self.content[module_name].body_nodes[node_id][-1]\n</code></pre>"},{"location":"reference-docs/compiler/compiler/node/#titan.compiler.node.NodeAssembler.get_primative_type_id_from_id","title":"<code>get_primative_type_id_from_id(module_name, id)</code>","text":"<p>Returns the associated primative type ID given an ID of a symbol.</p> <p>Can handle pointers too.</p> <p>Parameters:</p> Name Type Description Default <code>module_name</code> <code>str</code> <p>Module to fetch from.</p> required <code>id</code> <code>str</code> <p>ID to fetch from.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Primative type ID.</p> Source code in <code>titan/compiler/node.py</code> <pre><code>def get_primative_type_id_from_id(self, module_name: str, id: str) -&gt; str:\n    \"\"\" Returns the associated primative type ID given an ID of a symbol.\n\n        Can handle pointers too.\n\n        Args:\n            module_name: Module to fetch from.\n            id: ID to fetch from.\n\n        Returns:\n            Primative type ID.\n    \"\"\"\n    x = self.content[module_name].types[id]\n    return x.alias if x.is_pointer else id\n</code></pre>"},{"location":"reference-docs/compiler/compiler/node/#titan.compiler.node.NodeAssembler.get_type_context_from_module","title":"<code>get_type_context_from_module(module_name, type_id)</code>","text":"<p>Get type context from a module using a type ID.</p> <p>Parameters:</p> Name Type Description Default <code>module_name</code> <code>str</code> <p>Module to fetch from.</p> required <code>type_id</code> <code>str</code> <p>ID of type to query.</p> required <p>Returns:</p> Type Description <code>NodeTypeContext</code> <p>Context of the type.</p> Source code in <code>titan/compiler/node.py</code> <pre><code>def get_type_context_from_module(self, module_name: str, type_id: str) -&gt; NodeTypeContext:\n    \"\"\" Get type context from a module using a type ID.\n\n        Args:\n            module_name: Module to fetch from.\n            type_id: ID of type to query.\n\n        Returns:\n            Context of the type.\n    \"\"\"\n    return self.content[module_name].types[type_id]\n</code></pre>"},{"location":"reference-docs/compiler/compiler/node/#titan.compiler.node.NodeAssembler.modify_node","title":"<code>modify_node(module_name, target_node_id, pos, value_node, operation=Operation.NOP)</code>","text":"<p>Modify the parents and/or the operation of a node within a module.</p> <p>Parameters:</p> Name Type Description Default <code>module_name</code> <code>str</code> <p>Module to modify node in.</p> required <code>target_node_id</code> <code>str</code> <p>Node to modify.</p> required <code>pos</code> <code>int</code> <p>Which parent of the node to modify. (0 = left, 1 = right)</p> required <code>value_node</code> <code>Node</code> <p>New parent node.</p> required <code>operation</code> <code>Operation</code> <p>Operation that the node is performing.</p> <code>NOP</code> Source code in <code>titan/compiler/node.py</code> <pre><code>def modify_node(self, module_name: str, target_node_id: str, pos: int, value_node: Node, operation: Operation = Operation.NOP):\n    \"\"\" Modify the parents and/or the operation of a node within a module.\n\n        Args:\n            module_name: Module to modify node in.\n            target_node_id: Node to modify.\n            pos: Which parent of the node to modify. (0 = left, 1 = right)\n            value_node: New parent node.\n            operation: Operation that the node is performing.\n    \"\"\"\n\n    x = self.get_node(module_name, target_node_id)\n    logging.debug(f\"modifiying {target_node_id}: {x}\")\n    logging.debug(f\"\\tposition {pos} should contain {value_node.spirv_id}\")\n    logging.debug(f\"\\toperation {x.operation} should update to {operation}\")\n\n    if pos == 0:\n        new_ctx = NodeContext(\n            x.spirv_line_no, x.spirv_id, x.type_id, value_node, x.input_right, operation, x.data\n        )\n\n    elif pos == 1:\n        new_ctx = NodeContext(\n            x.spirv_line_no, x.spirv_id, x.type_id, x.input_left, value_node, operation, x.data\n        )\n\n    logging.debug(f\"new node context: {new_ctx}\")\n\n    self.content[module_name].body_nodes[target_node_id].append(Node(new_ctx))\n</code></pre>"},{"location":"reference-docs/compiler/compiler/node/#titan.compiler.node.NodeAssembler.node_exists","title":"<code>node_exists(module_name, node_id)</code>","text":"<p>Checks if a node exists in a given module.</p> <p>Parameters:</p> Name Type Description Default <code>module_name</code> <code>str</code> <p>Module to check in.</p> required <code>node_id</code> <code>str</code> <p>Node ID to check for.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if node exists, else false.</p> Source code in <code>titan/compiler/node.py</code> <pre><code>def node_exists(self, module_name: str, node_id: str) -&gt; bool:\n    \"\"\" Checks if a node exists in a given module.\n\n        Args:\n            module_name: Module to check in.\n            node_id: Node ID to check for.\n\n        Returns:\n            True if node exists, else false.\n    \"\"\"\n    return True if node_id in self.content[module_name].body_nodes else False\n</code></pre>"},{"location":"reference-docs/compiler/compiler/node/#titan.compiler.node.NodeAssembler.type_exists_in_module","title":"<code>type_exists_in_module(module_name, type_id)</code>","text":"<p>Check if a type exists for a given module.</p> <p>Parameters:</p> Name Type Description Default <code>module_name</code> <code>str</code> <p>Module to check in.</p> required <code>type_id</code> <code>str</code> <p>Type ID to check for.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if ID exists in function, else false.</p> Source code in <code>titan/compiler/node.py</code> <pre><code>def type_exists_in_module(self, module_name: str, type_id: str) -&gt; bool:\n    \"\"\" Check if a type exists for a given module.\n\n        Args:\n            module_name: Module to check in.\n            type_id: Type ID to check for.\n\n        Returns:\n            True if ID exists in function, else false.\n    \"\"\"\n    return True if type_id in self.content[module_name].types else False\n</code></pre>"},{"location":"reference-docs/compiler/compiler/node/#titan.compiler.node.NodeContext","title":"<code>NodeContext</code>","text":"<p>             Bases: <code>NamedTuple</code></p> <p>Tuple which holds context about a node.</p> <p>Attributes:</p> Name Type Description <code>line_no</code> <code>int</code> <p>Line of the SPIR-V assembly this node referring to.</p> <code>id</code> <code>str</code> <p>Associated SPIR-V ID.</p> <code>type_id</code> <code>str</code> <p>Associated type ID.</p> <code>input_left</code> <code>Node</code> <p>Left parent node.</p> <code>input_right</code> <code>Node</code> <p>Right parent node.</p> <code>operation</code> <code>Operation</code> <p>Operation being performed by the node.</p> <code>data</code> <code>list</code> <p>Additional information stored by the node.</p> <code>is_comparison</code> <code>bool</code> <p>Set if this node doing a comparison.</p> Source code in <code>titan/compiler/node.py</code> <pre><code>class NodeContext(NamedTuple):\n    \"\"\" Tuple which holds context about a node.\n\n        Attributes:\n            line_no (int): Line of the SPIR-V assembly this node referring to.\n            id (str): Associated SPIR-V ID.\n            type_id (str): Associated type ID.\n            input_left (titan.Node): Left parent node.\n            input_right (titan.Node): Right parent node.\n            operation (titan.common.symbols.Operation): Operation being performed by the node.\n            data: Additional information stored by the node.\n            is_comparison (bool): Set if this node doing a comparison.\n    \"\"\"\n    line_no: int = 0\n    id: str = \"\"\n    type_id: str = \"\"\n    input_left: Node = None\n    input_right: Node = None\n    operation: Operation = None\n    data: list = []\n    is_comparison: bool = False # OpSelect -- why not use the operation to determine this?\n    array_id: str = \"\"\n    array_index_id: str = \"\"\n</code></pre>"},{"location":"reference-docs/compiler/compiler/node/#titan.compiler.node.NodeModuleData","title":"<code>NodeModuleData</code>","text":"<p>Class encapsulating information required for a module.</p> <p>Attributes:</p> Name Type Description <code>types</code> <code>spirv_id_and_type_context</code> <p>All types contained within the function.</p> <code>inputs</code> <code>List[str]</code> <p>A list of all inputs.</p> <code>outputs</code> <code>List[str]</code> <p>A list of all outputs.</p> <code>body_nodes</code> <code>spirv_id_and_node</code> <p>A dictionary containing all body nodes, with the SPIR-V ID as its key and a list of associated nodes as its value.</p> Source code in <code>titan/compiler/node.py</code> <pre><code>class NodeModuleData():\n    \"\"\" Class encapsulating information required for a module.\n\n        Attributes:\n            types: All types contained within the function.\n            inputs: A list of all inputs.\n            outputs: A list of all outputs.\n            body_nodes: A dictionary containing all body nodes, with the SPIR-V ID as its key and a list of associated nodes as its value.\n    \"\"\"\n    types: hinting.spirv_id_and_type_context = {}\n    inputs: List[str] = []\n    outputs: List[str] = []\n    body_nodes: hinting.spirv_id_and_node = {}\n</code></pre>"},{"location":"reference-docs/compiler/compiler/node/#titan.compiler.node.NodeTypeContext","title":"<code>NodeTypeContext</code>","text":"<p>             Bases: <code>NamedTuple</code></p> <p>Tuple describing type information for a node.</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>DataType</code> <p>Primative datatype.</p> <code>data</code> <code>list</code> <p>Additional data to store in the type.</p> <code>is_pointer</code> <code>bool</code> <p>Set to true if the type describes a pointer.</p> <code>alias</code> <code>str</code> <p>If <code>is_pointer</code> is true, this attribute will store the original type id.</p> Source code in <code>titan/compiler/node.py</code> <pre><code>class NodeTypeContext(NamedTuple):\n    \"\"\" Tuple describing type information for a node.\n\n        Attributes:\n            type: Primative datatype.\n            data: Additional data to store in the type.\n            is_pointer: Set to true if the type describes a pointer.\n            alias: If ``is_pointer`` is true, this attribute will store the original type id.\n    \"\"\"\n    type: DataType = None\n    data: list = []\n    is_pointer: bool = False\n    alias: str = \"\" # alias is used to store the original type id when is_pointer is set to True\n    is_array: bool = False\n    array_dimension_id: str = \"\"\n</code></pre>"},{"location":"reference-docs/compiler/compiler/spirv/","title":"Documentation for <code>spirv.py</code>","text":""},{"location":"reference-docs/compiler/compiler/spirv/#titan.compiler.spirv.SPIRVAssembler","title":"<code>SPIRVAssembler</code>","text":"<p>             Bases: <code>NodeVisitor</code></p> <p>SPIR-V assembler class.</p> Source code in <code>titan/compiler/spirv.py</code> <pre><code>class SPIRVAssembler(ast.NodeVisitor):\n    \"\"\" SPIR-V assembler class. \"\"\"\n\n    class Sections(Enum):\n        \"\"\" Enum containing sections that are present in the final SPIR-V assembly file.\n\n            Dividing the SPIR-V file into sections helps with ensuring that the code is\n            placed in the right spot, and can be easily altered if needed.\n        \"\"\"\n        CAPABILITY_AND_EXTENSION = auto()\n        ENTRY_AND_EXEC_MODES = auto()\n        DEBUG_STATEMENTS = auto()\n        ANNOTATIONS = auto()\n        TYPES = auto()\n        VAR_CONST_DECLARATIONS = auto()\n        ARRAY_TYPES = auto()\n        ARRAY_DECLARATIONS = auto()\n        FUNCTIONS = auto()\n\n    class TypeContext(NamedTuple):\n        \"\"\" Tuple that provides context about a given type. Used to align Python types with SPIR-V.\n\n            Attributes:\n                primative_type (titan.common.type.DataType): Base/primative (python) type.\n                storage_type (titan.common.type.StorageType): Storage type in SPIR-V.\n                is_constant (bool): Type describes a constant.\n                is_pointer (bool): Type describes a pointer.\n                is_function_typedef (bool): Type describes a function definition. \n                is_array (bool): Type describes array.\n                array_size (int): Stores size of array.\n        \"\"\"\n        primative_type: DataType\n        storage_type: StorageType = StorageType.NONE\n        is_constant: bool = False\n        is_pointer: bool = False\n        is_function_typedef: bool = False\n        is_array: bool = False\n        array_size: int = 0\n\n    class ConstContext(NamedTuple):\n        \"\"\" Tuple that provides context about a given constant.\n\n            Attributes:\n                primative_type (titan.common.type.DataType): Base/primative (python) type.\n                value: Value of the constant. Can be int, float, bool or None.\n                declared_id: SPIR-V ID associated to the particular constant.\n        \"\"\"\n        primative_type: DataType\n        value: Union[int, float, bool, None]\n        declared_id: str = None\n\n    class SymbolInfo(NamedTuple):\n        \"\"\" Tuple that associates a primative type with a storage location.\n\n            Attributes:\n                type (titan.common.type.DataType): Base/primative (python) type.\n                location (titan.common.type.StorageType): Storage type in SPIR-V.\n                is_array (bool): Is the symbol an array type?\n                declared_type_id (str): SPIR-V type ID associated to the particular symbol.\n        \"\"\"\n        type: DataType\n        location: StorageType\n        is_array: bool = False\n        declared_type_id: str = None\n\n\n    class IntermediateIDContext(NamedTuple):\n        \"\"\" Tuple to store information about an intermediate ID. \n\n            Attributes:\n                type: Base/primative type.\n                is_accessing_array: Whether the ID is accessing an array or not (i.e represents OpAccessChain).\n        \"\"\"\n        type: DataType\n        is_accessing_array: bool = False\n\n    class symbol_info_hint(TypedDict):\n        symbol_id: str\n        info: SPIRVAssembler.SymbolInfo\n\n    class constant_context_and_id(TypedDict):\n        type: SPIRVAssembler.ConstContext\n        spirv_id: str\n\n    class intermediate_id_and_ctx(TypedDict):\n        intermediate_id: str\n        id_ctx: SPIRVAssembler.IntermediateIDContext\n\n    # attributes\n    entry_point = \"\"\n    _disable_debug = True\n    _latest_ifexp_selector_id = None\n    _latest_compare_id = None\n    _latest_function_name = None\n    _decorator_dict = {}\n    _import_mapping = bidict()\n\n\n    input_port_list: symbol_info_hint = {}\n    output_port_list: hinting.symbol_and_type = {}\n    symbol_info: symbol_info_hint = {}\n    declared_constants: constant_context_and_id = {}\n    declared_types: hinting.declared_types = {}\n    body = []\n\n    # attempts to align the output type list with the output port/symbol list\n    # this is so that the correct id (assuming that it is handled in order) will be assigned the correct type\n    # perhaps slightly over-engineered?\n    _internal_output_port_list_counter = 0 \n    output_type_list = []\n\n    location_id = 0\n    intermediate_id = 0\n    return_id = 0\n    intermediate_ids: intermediate_id_and_ctx = {}\n\n    _target_file = None\n    _tree = None\n\n    # TODO: remove the .name operators\n    generated_spirv = {\n        Sections.CAPABILITY_AND_EXTENSION.name: [],\n        Sections.ENTRY_AND_EXEC_MODES.name: [],\n        Sections.DEBUG_STATEMENTS.name: [],\n        Sections.ANNOTATIONS.name: [],\n        Sections.TYPES.name: [],\n        Sections.VAR_CONST_DECLARATIONS.name: [],\n        Sections.ARRAY_TYPES.name: [],\n        Sections.ARRAY_DECLARATIONS.name: [],\n        Sections.FUNCTIONS.name: []\n    }\n\n\n    def __init__(self, target_file: str, disable_debug=True):\n        \"\"\" Init function for _SPIRVHelperGenerator.\n\n            Creates various attributes and allows for helper function access.\n\n            Args:\n                disable_debug (bool): Disable debug output.\n                target_file: File to read.\n\n            Attributes:\n                entry_point (string): TODO\n                _disable_debug (bool): Disables debug. Set to value of parameter.\n                _latest_ifexp_selector_id (None): Last known ID for an if-expression selector.\n                _latest_compare_id (None): Last known ID for a compare expression.\n                _latest_function_name (None): TODO\n                _decorator_dict: Stores information regarding decorators are used on which functions.\n                input_port_list (TypedDict): List of input port names and their primative types.\n                output_port_lsit (TypedDict): List of output port names and their primative types.\n                _internal_output_port_list_counter (None): TODO\n                output_type_list: TODO\n                symbol_info: TODO\n                location_id: TODO\n                intermediate_id (int): Keep track of latest intermediate ID (used by unrolled expressions).\n                return_id (int): TODO\n                intermediate_ids: List of used intermediate IDs. Stores ID as string and primative type.\n                declared_constants: List of declared constants. Stores ConstContext and string ID of constant.\n                declared_types: List of declared types. Stores primative type and string ID.\n                body: TODO\n                generated_spirv (dict): Dictionary indexed with Sections enum, and stores generated lines in a list.\n                _import_mapping (bidict): Bi-directional dictionary to store import names &amp; aliases\n        \"\"\"\n\n        self._disable_debug = disable_debug\n        self._target_file = target_file\n        self._tree = ast.parse(open(self._target_file, \"r\").read())\n\n    def dump(self):\n        \"\"\" Output debug info if debug flag has been set. Uses the logging library.\"\"\"\n        if not self._disable_debug:\n\n            logging.debug(f\"entry point: {self.entry_point}\")\n            logging.debug(f\"input port list: {self.input_port_list}\")\n            logging.debug(f\"output port list: {self.output_port_list}\")\n            logging.debug(f\"output type list: {self.output_type_list}\")\n\n            logging.debug(f\"symbols with info:\")\n            for id, info in self.symbol_info.items():\n                logging.debug(f\"\\t{id} -&gt; {info}\")\n\n            logging.debug(f\"declared constants:\")\n            for info, id in self.declared_constants.items():\n                logging.debug(f\"\\t{id} -&gt; {info}\")\n\n\n            logging.debug(f\"declared types:\")\n            for info, id in self.declared_types.items():\n                logging.debug(f\"\\t{id} -&gt; {info}\")\n\n            logging.debug(f\"intermediate line id &amp; type:\")\n            for id, type in self.intermediate_ids.items():\n                logging.debug(f\"\\t{id} -&gt; {type}\")\n\n            logging.debug(f\"generated spirv:\")\n            for section in self.generated_spirv.keys():\n                logging.debug(f\"section: {section}\")\n\n                for value in self.generated_spirv[section]:\n                    logging.debug(f\"\\t{value}\")\n\n    def add_line(self, section: Sections, line: str):\n        \"\"\" Add a generated line of SPIR-V to a given section.\n\n            Args:\n                section (titan.compiler.spirv.SPIRVAssembler.Sections): The section to append the line to.\n                line (str): The line to add.\n        \"\"\"\n        self.generated_spirv[section.name].append(line)\n\n\n    def add_output_type(self, type):\n        \"\"\" Add an output type.\n\n            Args:\n                type: The type to add.\n\n            Warning:\n                This function may be removed in the future. It's not clear _what_ specifically it is adding.\n                Could possibly cause issues with the rest of the program.\n        \"\"\"\n        self.output_type_list.append(type)\n\n    def add_output_symbol(self, symbol: str):\n        \"\"\" Add an output symbol to the output_port_list.\n\n            Also increments an internal counter.\n\n            Args:\n                symbol (str): The symbol to be added. \n        \"\"\"\n        # HACK: what is the point of this line\n        self.output_port_list[symbol] = self.output_type_list[self._internal_output_port_list_counter]\n        self._internal_output_port_list_counter += 1\n\n    def symbol_exists(self, symbol: str) -&gt; bool:\n        \"\"\" Check if a symbol exists.\n\n            Args:\n                symbol (str): Given symbol name, without the SPIR-V \"%\" prefix.\n\n            Returns:\n                symbol_exists: True if symbol exists, else False.\n        \"\"\"\n        return True if symbol in self.symbol_info else False\n\n    # NOTE: unused, no references    \n    # def add_symbol(self, symbol_id: str, type, location: StorageType, is_array: bool = False, declared_type_id: str = None):\n    #     \"\"\" Add a symbol.\n\n    #         The value ``type`` arg will be automatically converted into a valid ``titan.common.type.DataType`` value.\n\n    #         Args:\n    #             symbol_id: ID given to the symbol.\n    #             type: Python type of the symbol.\n    #             location: Given storage location for the symbol. Required for SPIR-V.\n    #             is_array: Is the symbol an array?\n    #             declared_id: SPIR-V ID of the type associated with the particular symbol.\n\n    #         TODO:\n    #             Need to determine whether the symbol ID contains the \"%\" prefix or not.\n    #     \"\"\"\n    #     self.symbol_info[symbol_id] = self.SymbolInfo(DataType(type), location, is_array, declared_type_id)\n\n    def get_symbol_info(self, symbol_id: str) -&gt; SymbolInfo:\n        \"\"\" Get information regarding a given symbol via ID.\n\n            Args:\n                symbol_id: ID of the symbol to check.\n\n            Returns:\n                Symbol information tuple.\n        \"\"\"\n        return self.symbol_info[symbol_id]\n\n    # basically works the same as add_symbol\n    def update_symbol_info(self, symbol_id: str, info: SymbolInfo):\n        \"\"\" Update the information currently stored of a given symbol.\n\n            Warning:\n                Simply overwrites an existing entry. The symbol _must_ have been declared before using this,\n                otherwise you may run into a KeyError exception.\n\n            Args:\n                symbol_id: ID of the symbol to update.\n                info: Tuple to update the information with.\n        \"\"\"\n        self.symbol_info[symbol_id] = info\n\n    def add_symbol_if_nonexistant(self, symbol: str, type, location: StorageType, array_type_id: str = None, array_size: int = 0) -&gt; bool:\n        \"\"\" Add a symbol, only if it does not already exist.\n\n            Method first checks if symbol exists or not. If not, it'll generate the corresponding SPIR-V\n            lines depending on its type and location, and increment the ``location_id`` counter.\n\n            Args:\n                symbol: Name of the symbol to add.\n                type: Python type of the symbol.\n                location: Given storage location for the symbol. Required for SPIR-V.\n                array_type_id: SPIR-V ID (with %) of the array type.\n                array_size: Total elements present in the array.\n\n            Returns:\n                symbol_added: True if symbol has been added, else False.\n        \"\"\"\n\n        symbol_is_array = False if array_type_id is None else True\n\n        if symbol not in self.symbol_info:\n            logging.debug(f\"updating symbol: {symbol}\")\n\n            # keeping track of which id is used to create the symbol\n            final_type_id = None\n\n            self.add_line(self.Sections.DEBUG_STATEMENTS, f\"OpName %{symbol} \\\"{symbol}\\\"\")\n\n            # if i/o\n            if location is (StorageType.IN or StorageType.OUT):\n                # add location (glsl specific i think)\n                self.add_line(self.Sections.ANNOTATIONS, f\"OpDecorate %{symbol} Location {self.location_id}\")\n\n                if location is StorageType.IN:\n                    # more glsl specific stuff\n                    self.add_line(self.Sections.ANNOTATIONS, f\"OpDecorate %{symbol} Flat\")\n\n                    # input variable pointer type\n                    ptr_id = self.add_type_if_nonexistant(\n                        self.TypeContext(primative_type=DataType(type), storage_type=StorageType.IN, is_pointer=True),\n                        f\"%pointer_input_{DataType(type).name.lower()}\"\n                    )\n\n\n                    if symbol_is_array:\n                        self.add_line(self.Sections.VAR_CONST_DECLARATIONS, f\"%{symbol} = OpVariable {array_type_id} Input\")\n                        final_type_id = array_type_id\n\n                    else:\n                        self.add_line(self.Sections.VAR_CONST_DECLARATIONS, f\"%{symbol} = OpVariable {ptr_id} Input\")\n                        final_type_id = ptr_id\n\n\n                elif location is StorageType.OUT:\n\n                    ptr_id = self.add_type_if_nonexistant(\n                        self.TypeContext(primative_type=DataType(type), storage_type=StorageType.IN, is_pointer=True),\n                        f\"%pointer_output_{DataType(type).name.lower()}\"\n                    )\n\n                    if symbol_is_array:\n                        self.add_line(self.Sections.VAR_CONST_DECLARATIONS, f\"%{symbol} = OpVariable {array_type_id} Output\")\n                        final_type_id = array_type_id\n                    else:\n                        self.add_line(self.Sections.VAR_CONST_DECLARATIONS, f\"%{symbol} = OpVariable {ptr_id} Output\")\n                        final_type_id = ptr_id\n\n\n\n            elif location is StorageType.FUNCTION_VAR:\n\n                ptr_id = self.add_type_if_nonexistant(\n                    self.TypeContext(\n                        primative_type=DataType(type), storage_type=StorageType.FUNCTION_VAR, is_pointer=True),\n                    f\"%pointer_funcvar_{DataType(type).name.lower()}\"\n                )\n\n                if symbol_is_array:\n                    self.add_line(self.Sections.FUNCTIONS, f\"%{symbol} = OpVariable {array_type_id} Function\")\n                    final_type_id = array_type_id\n                else:\n                    self.add_line(self.Sections.FUNCTIONS, f\"%{symbol} = OpVariable {ptr_id} Function\")\n                    final_type_id = ptr_id\n\n            # increment by 1 for regular variables, or by element count for arrays\n            self.location_id += 1 if not symbol_is_array else array_size\n\n            symbol_info = self.SymbolInfo(DataType(type), location, is_array=symbol_is_array, declared_type_id=final_type_id)\n            logging.debug(f\"{symbol} : {symbol_info}\")\n            self.symbol_info[symbol] = symbol_info\n            return True\n        else:\n            return False\n\n    def get_symbol_type(self, symbol: str) -&gt; DataType:\n        \"\"\" Get symbol type, using symbol ID.\n\n            Args:\n                symbol: Symbol ID\n\n            Returns:\n                Primative type of symbol.\n        \"\"\"\n        # symbol_info[symbol] -&gt; info (SymbolInfo).type\n        return self.symbol_info[symbol].type\n\n    # NOTE: unused, no references\n    # def get_symbol_declared_type_id(self, symbol: str) -&gt; str:\n    #     \"\"\" Get the ID of the type that was used to declare the symbol with.\n\n    #         Args:\n    #             symbol: Symbol ID\n\n    #         Returns:\n    #             Type ID\n    #     \"\"\"\n    #     return self.symbol_info[symbol].declared_type_id\n\n    def intermediate_id_exists(self, intermediate_id: str) -&gt; bool:\n        \"\"\" Check if an intermediate ID already exists.\n\n            Args:\n                intermediate_id: Intermediate ID to check.\n\n            Returns:\n                True if intermediate ID already exists, else False.\n        \"\"\"\n        return True if intermediate_id in self.intermediate_ids else False\n\n    def add_intermediate_id(self, intermediate_id: str, type: DataType, is_accessing_array: bool = False):\n        \"\"\" Add an intermediate ID.\n\n            Args:\n                intermediate_id: Intermediate ID to add.\n                type: Type to associate with the intermediate ID.\n        \"\"\"\n        # self.intermediate_ids[intermediate_id] = type\n        self.intermediate_ids[intermediate_id] = self.IntermediateIDContext(type, is_accessing_array)\n\n    def get_type_of_intermediate_id(self, intermediate_id: str) -&gt; DataType:\n        \"\"\" Returns the type of an intermediate ID, _not_ the type ID.\n\n            Args:\n                intermediate_id: Intermediate ID to return the type of.\n\n            Returns:\n                Primative intermediate ID type.\n        \"\"\"\n        return self.intermediate_ids[intermediate_id].type\n\n    def get_is_intermediate_id_accessing_array(self, intermediate_id: str) -&gt; bool:\n        \"\"\" Returns true/false if intermediate ID is accessing an array.\n\n            Args:\n                intermediate_id: Intermediate ID to check\n\n            Returns:\n                True if accessing array, else False\n        \"\"\"\n        return self.intermediate_ids[intermediate_id].is_accessing_array\n\n    # type helpers\n    def type_exists(self, type: TypeContext) -&gt; bool:\n        \"\"\" Check if a type already exists, using a ``TypeContext``.\n\n            Args:\n                type: Type to check if it exists.\n\n            Returns:\n                True if type exists, else False.\n        \"\"\"\n        return True if type in self.declared_types else False\n\n    def add_type(self, type: TypeContext, id: str):\n        \"\"\" Add a type, using ``TypeContext``. Used to generate SPIR-V types.\n\n            Args:\n                type: Type, as ``TypeContext`` to add.\n                id: ID to associate with the type.\n        \"\"\"\n        self.declared_types[type] = id\n\n    def get_type_id(self, type: TypeContext) -&gt; str:\n        \"\"\" Get the ID of a given type.\n\n            Args:\n                type: Type to get ID for.\n\n            Returns:\n                ID of the type.\n        \"\"\"\n        # FIXME: the type hint declared for this attribute does not use TypeContext as the key.\n        #        declared_type_hint suggests to use common.type.DataType as the key!\n        return self.declared_types[type]\n\n    def get_primative_type_id(self, type: DataType) -&gt; str:\n        \"\"\" Get the ID of a primative type.\n\n            Args:\n                type: Primative type to get ID for.\n\n            Return:\n                ID of the type.\n        \"\"\"\n\n        # TODO: convoluted? may be a better way to do this\n        # can this just be replaced with indexing with the primative type instead of going through TypeContext?\n        return self.declared_types[\n            self.TypeContext(DataType(type))\n        ]\n\n    def add_type_if_nonexistant(self, type_ctx: TypeContext, id: str) -&gt; str:\n        \"\"\" Add a type, only if it does not already exist.\n\n            If the type does not already exist, the function will generate the corresponding SPIR-V for it.\n\n            Note: Currently supported types:\n                - OpTypeVoid\n                - OpTypeInteger (32-bit signed)\n                - OpTypeBool\n                - OpTypeFloat (32-bit float)\n                - OpTypeArray\n\n            Args:\n                type: The type to add.\n                id: The ID to associate with the type.\n\n            Returns:\n                type_id: The ID of the type.\n        \"\"\"\n        if not self.type_exists(type_ctx):\n\n            # TODO: remove\n            self.add_type(type_ctx, id)\n\n            spirv_txt = f\"{id} = \"\n\n            if type_ctx.is_function_typedef:\n                prim_tid = self.get_primative_type_id(type_ctx.primative_type)\n                spirv_txt += f\"OpTypeFunction {prim_tid}\"\n\n            elif type_ctx.is_pointer and not type_ctx.is_array:\n                prim_tid = self.get_primative_type_id(type_ctx.primative_type)\n                storage_type_str = type_ctx.storage_type.value\n\n                assert type(storage_type_str) is str, f\"did not get text for the storage type: {type_ctx.storage_type}\"\n\n                spirv_txt += f\"OpTypePointer {storage_type_str} {prim_tid}\"\n\n            elif type_ctx.is_array and not type_ctx.is_pointer:\n                prim_tid = self.get_primative_type_id(type_ctx.primative_type)\n\n                # get id for array size, may need to add if doesnt exist\n                const_size_id = self.add_const_if_nonexistant(\n                    self.ConstContext(\n                        type_ctx.primative_type,\n                        type_ctx.array_size\n                    )\n                )\n\n                spirv_txt += f\"OpTypeArray {prim_tid} %{const_size_id}\"\n\n            elif type_ctx.is_array and type_ctx.is_pointer:\n\n                # get base array id for this specific pointer\n                array_type_id = self.get_type_id(\n                    self.TypeContext(\n                        primative_type=type_ctx.primative_type,\n                        storage_type=StorageType.NONE, # the base array id does not have storage type\n                        is_pointer=False,\n                        is_array=True,\n                        array_size=type_ctx.array_size\n                    )\n                )\n\n                spirv_txt += f\"OpTypePointer {type_ctx.storage_type.value} {array_type_id}\"\n\n            # this should mean we're working with the primative types\n            elif (not type_ctx.is_constant) and (not type_ctx.is_pointer) and (not type_ctx.is_function_typedef):\n\n                match type_ctx.primative_type:\n                    case DataType.VOID:\n                        spirv_txt += f\"OpTypeVoid\"\n                    case DataType.INTEGER:\n                        spirv_txt += f\"OpTypeInt 32 1\"\n                    case DataType.BOOLEAN:\n                        spirv_txt += f\"OpTypeBool\"\n                    case DataType.FLOAT:\n                        spirv_txt += f\"OpTypeFloat 32\"\n                    case _:\n                        logging.exception(f\"type text for {type_ctx} not implemented yet (did you wrap the type in a DataType() call to enum?)\", exc_info=False)\n                        raise Exception(f\"type text for {type_ctx} not implemented yet (did you wrap the type in a DataType() call to enum?)\")\n            else:\n                logging.exception(f\"unable to generate spirv text for type {id} -&gt; {type_ctx}\", exc_info=False)\n                raise Exception(f\"unable to generate spirv text for type {id} -&gt; {type_ctx}\")\n\n\n            if not type_ctx.is_array:\n                self.add_line(\n                    self.Sections.TYPES,\n                    spirv_txt\n            )\n            else:\n                self.add_line(\n                    self.Sections.ARRAY_TYPES,\n                    spirv_txt\n                )\n\n            return id\n        else:\n            return self.get_type_id(type_ctx)\n\n    # const helpers\n    def const_exists(self, const: ConstContext | str) -&gt; bool:\n        \"\"\" Check if a constant exists.\n\n            Args:\n                const: Constant to check, either with ConstContext or ID (without '%')\n\n            Returns:\n                True if constant exists, else False.\n        \"\"\"\n        return const in self.declared_constants.keys() or const in self.declared_constants.values()\n\n    # NOTE: unused, no references    \n    # def add_const(self, c_ctx: ConstContext, spirv_id: str):\n    #     \"\"\" Add a constant.\n\n    #         Args:\n    #             c_ctx: Constant to add.\n    #             spirv_id: The ID to associate with the constant.\n    #     \"\"\"\n    #     self.declared_constants[c_ctx] = spirv_id\n\n    def add_const_if_nonexistant(self, const: ConstContext, negative_val: bool = False) -&gt; str:\n        \"\"\" Add a constant, only if it does not exist already.\n\n            Checks if the constant exists, and if not, the method will generate the corresponding SPIR-V.\n\n            Args:\n                const: Constant to add.\n                negative_val: Flag the value as a negative constant. Needed to generate the SPIR-V assembly correctly.\n\n            Returns:\n                constant_id: Returns the ID of the constant.\n        \"\"\"\n\n        if const not in self.declared_constants:\n            txt_val = str(const.value)\n            const_str = f\"const_{DataType(const.primative_type).name.lower()}\"\n\n            # format the string properly\n            if negative_val:\n                txt_val = txt_val.replace(\"-\", \"n\")\n\n            if const.primative_type is float:\n                txt_val = txt_val.replace(\".\", \"_\")\n\n            const_str += f\"_{txt_val}\"\n\n            self.declared_constants[const] = const_str\n\n            # check if type has been declared\n            self.add_type_if_nonexistant(self.TypeContext(DataType(const.primative_type)),f\"%type_{(DataType(const.primative_type).name).lower()}\")\n\n            self.add_line(\n                self.Sections.VAR_CONST_DECLARATIONS,\n                f\"%{const_str} = OpConstant {self.get_primative_type_id(DataType(const.primative_type))} {const.value}\"\n            )\n\n            return const_str\n        else:\n            return self.declared_constants[const]\n\n    def get_const_id(self, value, type) -&gt; str:\n        \"\"\" Get the ID of a constant.\n\n            Args:\n                value: A constant value.\n                type: The type of the constant value.\n\n            Returns:\n                ID of the constant.\n        \"\"\"\n        temp_c_ctx = self.ConstContext(type, value)\n        return self.declared_constants[temp_c_ctx]\n\n    def get_const_id_with_ctx(self, context: ConstContext) -&gt; str:\n        \"\"\" Get the ID of a constant, using ``ConstContext``.\n\n            Args:\n                context: Context of the constant.\n\n            Returns:\n                ID of the constant.\n        \"\"\"\n        return self.declared_constants[context]\n\n    def get_new_intermediate_id(self) -&gt; str:\n        \"\"\" Gets intermediate ID string and increments the counter.\n\n            Returns:\n                A (hopefully) unused intermediate ID value.\n        \"\"\"\n        new_id = f\"titan_id_{self.intermediate_id}\"\n        self.intermediate_id += 1\n        return new_id\n\n    def add_temp_load_op_if_needed(self, id: str, type_id: str) -&gt; str:\n        \"\"\" Add an OpLoad into a temporary ID if the symbol already exists, or if dealing with arrays (TODO).\n\n            Required by SPIR-V syntax.\n\n            Args:\n                id: ID of the symbol.\n                type_id: ID of the type of the symbol.\n\n            Returns:\n                Returns the new temporary ID if the symbol exists, otherwise returns provided symbol_id.\n        \"\"\"\n\n        # if id is a symbol\n        if self.symbol_exists(id):\n            temp_id = f\"temp_{id}\"\n\n            self.add_line(\n                self.Sections.FUNCTIONS,\n                f\"%{temp_id} = OpLoad {type_id} %{id}\"\n            )\n\n            return temp_id\n\n        # if constant -- no need to load anything, can use directly\n        elif self.const_exists(id.strip(\"%\")):\n            return id\n\n        # not a symbol, and not an intermediate id..? what does this line do?\n        elif (not self.symbol_exists(id) and not self.intermediate_id_exists(id)) or self.get_is_intermediate_id_accessing_array(id):\n\n            temp_id = self.get_new_intermediate_id()\n            self.add_line(\n                self.Sections.FUNCTIONS,\n                f\"%{temp_id} = OpLoad {type_id} %{id}\"\n            )\n\n            return temp_id\n        else:\n            return id\n\n\n    ### ast related stuff here\n\n    def compile(self):\n        \"\"\" Begin the AST/Python -&gt; SPIR-V compilation. \"\"\"\n        self.visit(self._tree)\n\n        if not self._disable_debug:\n            self.dump()\n\n    # TODO: probably inefficient\n    def create_file_as_string(self) -&gt; str:\n        \"\"\" Transforms the generated SPIR-V assembly from lists into a very long string.\n\n            TODO:\n                Rework this function. Must be a better way to do this.\n\n            Returns:\n                String containing all of the generated SPIR-V assembly code.\n        \"\"\"\n        fake_file = \"\"\n\n        # key=section, value=list of lines\n        for lines in self.generated_spirv.values():\n            for line in lines:\n                fake_file += f\"{line}\\n\"\n\n        return fake_file\n\n    def output_to_file(self, filename:str):\n        \"\"\" Write generated SPIR-V assembly into a real file.\n\n            Args:\n                filename: Name of the file to write to. ``.spvasm`` will be automatically appended.\n        \"\"\"\n        ff = self.create_file_as_string()\n\n        with open(f\"{filename}.spvasm\", \"w\") as f:\n            for line in ff:\n                f.write(line)\n\n    # dont look at this\n    def _get_python_type_from_string(self, type: str):\n        \"\"\" Returns the Python type by extracting the string from the type, and evaluating it.\n\n            Warning:\n                This is probably bad, and should be replaced when possible.\n\n            Args:\n                type: Python type as a string, i.e. \"&lt;class 'int'&gt;\"\n\n            Returns:\n                Type as an object.\n        \"\"\"\n        # returns python type from &lt;class 'x'&gt; string\n        return eval(type.split(\"'\")[0])\n\n    # ---------- start of AST functions ----------\n    # see: https://docs.python.org/3/library/ast.html\n\n    def visit_Module(self, node):\n        \"\"\" Function called when visiting a module.\n\n            Method first sets the entry point to the name of the function inside the module. If there are multiple,\n            the name can either be specified via a command line option, or if present, a function named \"step\" will\n            be the entry point. If there is only one function, then it will be used instead, regardless of the name.\n\n            Some initial boilerplate SPIR-V code is added at this stage.\n\n            After that the method will visit all of the functions in the body, generating the equivalent SPIR-V assembly.\n            The ports (I/O or parameters/returns) are handled after the function visits.\n\n            Args:\n                node: The current node.\n\n            Attributes:\n                _module_contains_step_function (bool): A check if the module contains a function specifically called \"step\".\n\n        \"\"\"\n        _module_contains_step_function = False\n\n        logging.debug(f\"found {len(node.body)} functions\")\n\n        for i in range(len(node.body)):\n            # skip over imports in module definition\n            if node is ast.Import or ast.ImportFrom:\n                continue\n\n            if node.body[i].name == \"step\":\n                _module_contains_step_function = True\n                self.entry_point = \"step\"\n\n        if not _module_contains_step_function:\n            total_func_defs = 0\n            func_def_pos = 0\n\n            for i in range(len(node.body)):\n                operation = node.body[i]\n\n                if type(operation) is ast.FunctionDef:\n                    total_func_defs += 1\n                    func_def_pos = i\n\n\n            assert total_func_defs != 0, \"no function defintions found\"\n            assert not total_func_defs &gt; 1, \"multiple function defintions found, please specify top\"\n\n            self.entry_point = node.body[func_def_pos].name\n            logging.debug(f\"setting entry point as '{self.entry_point}'\")\n\n        # spirv boilerplate\n        self.add_line(\n            self.Sections.CAPABILITY_AND_EXTENSION,\n            f\"OpCapability Shader\"\n        )\n\n        self.add_line(\n            self.Sections.CAPABILITY_AND_EXTENSION,\n            f\"OpMemoryModel Logical GLSL450\"\n        )\n\n        # this makes the assumption that the module body only contains FunctionDef nodes\n        # may not always be the case...\n        # TODO: rename 'fn', misleading\n        for fn in node.body:\n\n            # deal with imports\n            if type(fn) is ast.Import:\n                self.visit_Import(fn)\n                continue\n            elif type(fn) is ast.ImportFrom:\n                self.visit_ImportFrom(fn)\n                continue\n\n            # ignore everything else\n            elif type(fn) is not ast.FunctionDef:\n                logging.debug(f\"not processing {type(fn)}\")\n                continue\n\n            # evaluate function signature\n            self.visit_FunctionDef(fn)\n\n            # if the function is our entry point, we want to capture its params\n            # TODO: this will fail if the entry point is not the first function in the list,\n            #       since the lists/dicts will contain previous function entries, messing with the names\n            if fn.name == self.entry_point:\n                # take contents of input/output ports and convert them into ids\n                ports_str = \"\"\n\n                for symbol, symbol_ctx in self.symbol_info.items():\n                    if (symbol_ctx.location is StorageType.IN) or (symbol_ctx.location is StorageType.OUT):\n                        ports_str += f\"%{symbol} \"\n\n                self.add_line(\n                    self.Sections.ENTRY_AND_EXEC_MODES,\n                    f\"OpEntryPoint Fragment %{fn.name} \\\"{fn.name}\\\" {ports_str}\"\n                )\n\n            self.add_line(\n                self.Sections.ENTRY_AND_EXEC_MODES,\n                f\"OpExecutionMode %{fn.name} OriginUpperLeft\"\n            )\n\n            logging.debug(f\"exit function {fn.name}\")\n\n\n    def visit_Import(self, node):\n        \"\"\" Function called when visiting import nodes.\n\n            Updates an internal attribute to keep track of imported modules, as names only.\n            Does not actually evaluate if module exists, only intended to work with Numpy for arrays.\n        \"\"\"\n\n        for imported_module in node.names:\n            # cant use hasattr() because it will always return true, check against None instead\n            if imported_module.asname is None:\n                # no alternative name given\n                self._import_mapping[imported_module.name] = imported_module.name\n            else:\n                self._import_mapping[imported_module.name] = imported_module.asname\n\n    def visit_ImportFrom(self, node):\n        \"\"\" Function called when visiting import from 'x' nodes. \n\n            Does not implement any functionality.\n        \"\"\"\n        logging.error(f\"importing directly from modules not supported: {ast.dump(node)}\")\n\n    def visit_FunctionDef(self, node):\n        \"\"\" Function called when visiting a function definition.\n\n            Method evaluates function signature, generates appropriate SPIR-V types and visits the body nodes.\n\n            Args:\n                node: The current node.\n\n        \"\"\"\n\n        _debug_returns = None\n        if hasattr(node, \"returns\"):\n            _debug_returns = f\"returns type {node.returns.id}\"\n        else:\n            _debug_returns = \"does not hint at returning anything\"\n            logging.info(f\"'{node.name}' does not have a return type hint - is this expected?\")\n\n        logging.debug(f\"function {node.name} {_debug_returns}\")\n        self._latest_function_name = node.name\n\n        self.add_line(self.Sections.DEBUG_STATEMENTS, f\"OpName %{node.name} \\\"{node.name}\\\"\")\n\n        void_ctx = self.TypeContext(DataType.VOID, StorageType.NONE)\n        t_void_id = self.add_type_if_nonexistant(void_ctx, f\"%type_void\")\n\n        # make spirv function def for OpTypeFunction\n        fn_ctx = self.TypeContext(DataType.VOID, StorageType.NONE, False, False, True)\n        t_fn_void_id = self.add_type_if_nonexistant(fn_ctx, f\"%type_function_{(DataType.VOID.name).lower()}\")\n\n        # mark start of function\n        self.add_line(self.Sections.FUNCTIONS, f\"%{node.name} = OpFunction {t_void_id} None {t_fn_void_id}\")\n        self.add_line(self.Sections.FUNCTIONS, f\"%label_{node.name} = OpLabel\")\n\n        # process decorators - this should handle array defs etc\n        # TODO: can this be replaced with a specialised function, as to free up the visit_Call function?\n        for decorator in node.decorator_list:\n            self.visit_Call(decorator)\n\n        # iterate through each arg, make type &amp; pointer type\n        for args in node.args.args:\n\n            # args.arg == argument name\n            # args.annotation == type annotation\n            #   - seems like python types are recognised as \"ast.Name\"\n\n            if type(args.annotation) is ast.Name:\n                # potentially bad\n                type_class = eval(args.annotation.id)\n\n                # TODO: update true/false for arrays?\n                # check if generic type exists\n                t_ctx = self.TypeContext(DataType(type_class), StorageType.NONE, False, False)\n                self.add_type_if_nonexistant(t_ctx, f\"%type_{(DataType(type_class).name).lower()}\")\n\n                # dealing with args means that a special type needs to be made\n                ptr_t_ctx = self.TypeContext(DataType(type_class), StorageType.IN, False, True)\n                self.add_type_if_nonexistant(ptr_t_ctx, f\"%pointer_input_{(DataType(type_class).name).lower()}\")\n\n                self.add_symbol_if_nonexistant(args.arg, type_class, StorageType.IN)\n\n            elif type(args.annotation) is ast.Attribute:\n                logging.debug(f\"not doing anything for arg {args.arg} as annotation was ast.Attribute\")\n                pass\n            else:\n                raise Exception(f\"unexpected type of annotation for argument: {type(args.annotation)}\")\n\n\n        # TODO: needs implementation for multiple returns\n        # handle returns (types for now)\n        assert not isinstance(node.returns, ast.Call), \"multiple returns/function calls not handled\"\n\n        if isinstance(node.returns, ast.Name):\n            type_class = self._get_python_type_from_string(node.returns.id)\n            self.add_output_type(type_class)\n\n            type_as_string = DataType(type_class).name.lower()\n\n            # add primative type if it does not exist\n            self.add_type_if_nonexistant(self.TypeContext(DataType(type_class)), f\"%type_{type_as_string}\")\n\n            # add pointer type if it does not exist\n            self.add_type_if_nonexistant(self.TypeContext(DataType(type_class), StorageType.OUT, False, True, False),\n                f\"%pointer_output_{type_as_string}\"\n            )\n\n\n\n        logging.debug(f\"body start {node.name}\")\n        super().generic_visit(node)\n        logging.debug(f\"body end {node.name}\")\n\n        # spirv boilerplate for end of function\n        self.add_line(\n            self.Sections.FUNCTIONS,\n            f\"OpReturn\"\n        )\n\n        self.add_line(\n            self.Sections.FUNCTIONS,\n            f\"OpFunctionEnd\"\n        )\n\n    def visit_Call(self, node):\n        \"\"\" Function called when performing a function call.\n\n            Warning:\n                Work in progress. Will be used to implement decorators, to enable features such as delayed inputs.\n\n            Args:\n                node: The current node.\n        \"\"\"\n        logging.debug(f\"TODO: function calls/decorators properly\")\n        logging.debug(ast.dump(node))\n\n        if isinstance(node.func, ast.Attribute):\n            # logging.debug(f\"attribute hit with name {node.func.value.id}.{node.func.attr} with args {node.args}, targeting {self.spirv_helper._latest_function_name}\")\n\n            match node.func.attr:\n                case \"lag\":\n                    logging.debug(f\"lagging decorator found\")\n                    assert len(node.args) == 1, f\"unexpected amount of args, wanted 1 but got {len(node.args)}\"\n\n                    decorator_args = node.args[0] # there should only be one entry, and this should be a list\n                    assert isinstance(decorator_args, ast.List), f\"expecting list for decorator, got {type(decorator_args)} instead\"\n\n                    list_of_inputs_and_lags = decorator_args.elts\n\n                    # {function_name: {\n                    #                   input1: 2,\n                    #                   input2: 5\n                    #                 }\n                    # }\n\n                    temp_dict = {}\n\n                    for element in list_of_inputs_and_lags:\n                        # still working with ast.Lists here\n                        assert len(element.elts) == 2, f\"unexpected amount for elements, wanted 2 but got {len(element.elts)} instead\"\n\n                        target_input = self._extract_content(element.elts[0])\n                        target_lag_depth = self._extract_content(element.elts[1])\n                        temp_dict[target_input] = target_lag_depth\n\n                    self._decorator_dict[self._latest_function_name] = temp_dict\n                    logging.debug(f\"lagging decorator produced: {self._decorator_dict}\")\n\n                    logging.info(f\"Generating JSON (contains lagging information)...\")\n                    with open(f\"{self._latest_function_name}_lagging_info.json\", \"w+\") as f:\n                        f.write(json.dumps(self._decorator_dict, indent=4))\n\n\n                case \"recursive\":\n                    raise Exception(\"TODO\")\n\n                case \"arraydefs\":\n                    # format example:\n                    # @titan.arraydefs(\n                    #   {\n                    #       \"a\": [3, int],\n                    #       \"b\": [(3, 2), float]\n                    #   }\n                    # )\n                    # expecting dictionary that contains the symbols as keys, and their type def as values\n                    #   - the dimensions can either be int, or tuple of ints\n                    #   - the second value in list must be a python base type\n\n                    assert len(node.args) == 1, f\"unexpected number of arguments, wanted 1 but got {len(node.args)}\"\n                    assert type(node.args[0]) == ast.Dict, f\"expected dict for arg, got {type(node.args[0])} instead\"\n\n                    dict_keys = node.args[0].keys\n                    dict_vals = node.args[0].values\n\n                    for key, value in zip(dict_keys, dict_vals):\n                        assert type(key.value) == str, f\"expected str for symbol, got {type(key.value)} instead\"\n                        array_symbol = key.value\n\n                        # this is the dictionary value part\n                        assert type(value) == ast.List, f\"expected list for array definition, got {type(value)} instead\"\n                        assert type(value.elts[0]) in [ast.Constant, ast.Tuple], f\"unexpected element type, wanted either constant or tuple but got {type(value.elts[0])}\"\n                        assert type(value.elts[0]) == ast.Constant, f\"TODO: tuple support for array defs\"\n\n                        array_shape = value.elts[0].value\n                        # assuming that its still int, size must be &gt; 1 -- will need to be updated when implementing tuples\n                        assert array_shape &gt; 1, f\"cannot define array with size less than or equal to 1, got but {array_shape}\"\n\n                        assert eval(value.elts[1].id) in [int, float, bool], f\"attmpted to evaluate type given '{value.elts[1].id}' but failed. allowed types are int, float, bool\"\n                        array_type = eval(value.elts[1].id)\n\n                        logging.debug(f\"creating array with symbol '{array_symbol}', shape: {array_shape}, type: {array_type}\")\n\n                        # init primative types\n                        primative_type_id = self.add_type_if_nonexistant(self.TypeContext(primative_type=DataType(array_type)), f\"%type_{DataType(array_type).name.lower()}\")\n\n                        if type(array_shape) is int:\n                            self.add_const_if_nonexistant(\n                                self.ConstContext(\n                                    primative_type=DataType(type(array_shape)), value=array_shape\n                                )\n                            )\n                        else:\n                            raise Exception(\"unexpected type\")\n\n                        t_ctx_array = self.TypeContext(\n                            primative_type=DataType(array_type), is_array=True, array_size=array_shape\n                        )\n\n                        t_id_array = self.add_type_if_nonexistant(t_ctx_array, f\"%array_{DataType(array_type).name.lower()}_{array_shape}\")\n\n                        t_ctx_array_ptr = self.TypeContext(\n                            primative_type=DataType(array_type), storage_type=StorageType.IN, is_pointer=True,\n                            is_array=True, array_size=array_shape\n                        )\n\n                        t_id_array_ptr = self.add_type_if_nonexistant(t_ctx_array_ptr, f\"%array_ptr_{DataType(array_type).name.lower()}_{array_shape}_{StorageType.IN.value.lower()}\")\n                        self.add_symbol_if_nonexistant(array_symbol, array_type, StorageType.IN, t_id_array_ptr, array_shape)\n\n                case _:\n                    raise Exception(\"unexpected attribute when handling a call\")\n\n    def visit_Assign(self, node):\n        \"\"\" Function called when performing an assignment.\n\n            Attempts to evaluate the assignment, by calling ``_eval_line()``.\n\n            Args:\n                node: The current node.\n        \"\"\"\n\n        assert len(node.targets) == 1, \"multiple assignments not supported\"\n\n\n        # special case: array initialisation\n        # will deal within _eval_line() instead\n        if isinstance(node.value, ast.Call):\n            eval_id, eval_ctx = self._eval_line_wrap(node)\n            return\n\n        # special case: array indexing, if the target is array then we are doing \"x[1] = b\"\n        elif isinstance(node.targets[0], ast.Subscript):\n            index_id, index_ctx = self._eval_line(node.value)\n            access_id, access_ctx = self._eval_line(node.targets[0])\n            value_temp_load_id = self.add_temp_load_op_if_needed(index_id, index_ctx.primative_type)\n\n            self.add_line(\n                self.Sections.FUNCTIONS,\n                f\"OpStore %{access_id.strip('%')} %{value_temp_load_id.strip('%')}\"\n            )\n            return        \n\n        # if node.value contains a subscript object, it means we're doing something like \"b = x[1]\"\n        elif isinstance(node.value, ast.Subscript):\n\n            # evaluate array access\n            access_id, access_ctx = self._eval_line(node.value)\n\n            # make symbol if non-existant\n            self.add_symbol_if_nonexistant(node.targets[0].id, access_ctx.primative_type.value, StorageType.FUNCTION_VAR)\n\n            # add opload for array\n            temp_load_id = self.add_temp_load_op_if_needed(access_id, self.get_primative_type_id(self.get_type_of_intermediate_id(access_id)))\n\n            # store\n            self.add_line(\n                self.Sections.FUNCTIONS,\n                f\"OpStore %{node.targets[0].id} %{temp_load_id}\"\n            )\n\n            return\n\n        # for all other things\n        else:\n            try:\n                eval_id, eval_ctx = self._eval_line_wrap(node)\n            except Exception as e:\n                logging.exception(f\"failed to unpack evaluation, usually a sign that the operation was not handled properly... exception: {e}\")\n                raise Exception(f\"failed to unpack evaluation, usually a sign that the operation was not handled properly... exception: {e}\")\n\n            type_class = self._extract_type(eval_ctx)\n            assert not type_class is None, f\"evaluated type as None for variable with no type declaration\"\n\n            t_id = self.add_type_if_nonexistant(\n                self.TypeContext(\n                    DataType(type_class)\n                ),\n                f\"%type_{DataType(type_class).name.lower()}\"\n            )\n\n            self.add_symbol_if_nonexistant(node.targets[0].id, type_class, StorageType.FUNCTION_VAR)\n\n            self.add_line(\n                self.Sections.FUNCTIONS,\n                f\"OpStore %{node.targets[0].id} %{eval_id.strip('%')}\"\n            )\n\n    def visit_AnnAssign(self, node):\n        # print(f\"{node.annotation.id} {node.target.id} = {node.value.value}\")\n        type_class = self._get_python_type_from_string(node.annotation.id)\n\n        t_id = self.add_type_if_nonexistant(\n            self.TypeContext(DataType(type_class)),\n            f\"%type_{DataType(type_class).name.lower()}\"\n        )\n\n        try:\n            eval_id, eval_ctx = self._eval_line_wrap(node)\n        except Exception as e:\n            logging.exception(f\"failed to unpack evaluation, usually a sign that the operation was not handled properly... exception: {e}\")\n            raise Exception(f\"failed to unpack evaluation, usually a sign that the operation was not handled properly... exception: {e}\")\n\n\n        eval_type = self._extract_type(eval_ctx)\n\n        if eval_type != type_class:\n            logging.exception(f\"mismatched types: eval_type {eval_type} - type_class {type_class}\", exc_info=False)\n            raise Exception(f\"mismatched types: eval_type {eval_type} - type_class {type_class}\")\n\n        self.add_symbol_if_nonexistant(node.target.id, type_class, StorageType.FUNCTION_VAR)\n\n        self.add_line(\n            self.Sections.FUNCTIONS,\n            f\"OpStore %{node.target.id} {eval_id}\"\n        )  \n\n    def visit_Return(self, node):\n        \"\"\" Handle return nodes. \"\"\"\n\n        # TODO: add calls to _eval_line to get proper id for node\n        # if isinstance(node.value, ast.Constant):\n            # logging.debug(f\"returning const: {node.value.value}\")\n            # logging.exception(f\"TODO: return constant value\", exc_info=False)\n            # raise Exception(\"TODO: return constant value\")\n\n        assert not isinstance(node.value, ast.Constant), f\"TODO: return constant values (returning {node.value.value})\"\n        assert not isinstance(node.value, ast.BinOp), f\"TODO: return binops\"\n\n        if isinstance(node.value, ast.Name):\n            logging.debug(f\"returning name: {node.value.id}\")\n            id, ctx = self._eval_line(node.value)\n\n            if self.symbol_exists(id):\n                s_info = self.get_symbol_info(id)\n\n                # because the symbol exists, and isn't a temporary one\n                # and if we're returning it, it must be an output\n                if s_info.location == StorageType.FUNCTION_VAR:\n                    s_info_new = self.SymbolInfo(\n                        ctx, StorageType.OUT, s_info.is_array\n                    )\n\n                    self.update_symbol_info(id, s_info_new)\n\n                    ptr_t_id = self.get_type_id(\n                        self.TypeContext(\n                            ctx, StorageType.FUNCTION_VAR, False, True\n                        )\n                    )\n\n                    ptr_t_out_id = self.get_type_id(\n                        self.TypeContext(\n                            ctx, StorageType.OUT, False, True\n                        )\n                    )\n\n                    self.add_line(\n                        self.Sections.VAR_CONST_DECLARATIONS,\n                        f\"%{id} = OpVariable {ptr_t_out_id} Output\"\n                    )\n\n                    str_to_match = f\"%{id} = OpVariable {ptr_t_id} Function\"\n\n                    # TODO: implement better method\n                    # bruteforce remove reference of symbol declaration in FUNCTIONS section\n                    i = 0\n                    for line in self.generated_spirv[self.Sections.FUNCTIONS.name]:\n                        if line == str_to_match:\n                            self.generated_spirv[self.Sections.FUNCTIONS.name].pop(i)\n                            break\n                        i += 1\n\n        elif isinstance(node.value, ast.IfExp):\n\n            #        v node.value.body.id\n            # return c if a &gt; 0 else 0 \n            #             ^ ^        ^ node.value.orelse\n            #             | | node.value.test.{ops|comparators}\n            #             | node.value.test.left\n\n            # TODO: need to get ID somehow, move the IfExp function to something else accessible and call it directly?\n            super().generic_visit(node)\n\n            # because this is direct return, we have to make a temp symbol into which we can return (in spirv terms)\n            # we have to also add it to the symbols list, making sure that it has the same type as the indicated return type\n            # and that it doesn't clash with the return type\n\n            out_str_id = f\"titan_return_id_{self.return_id}\"\n            self.return_id += 1\n            # TODO: make sure names don't clash?\n            self.add_symbol_if_nonexistant(\n                out_str_id, self.output_type_list[0], StorageType.OUT\n            )\n\n            self.add_output_symbol(out_str_id)\n\n            # store titan_id_x into the newly created return variable\n            self.add_line(\n                self.Sections.FUNCTIONS,\n                f\"OpStore %{out_str_id} %{self._latest_ifexp_selector_id}\"\n            )\n\n            ptr_t_out_ctx = self.TypeContext(\n                DataType(self.output_type_list[0]), StorageType.OUT,\n                False, True, False\n            )\n\n            ptr_t_out_id = self.get_type_id(ptr_t_out_ctx)\n\n            self.add_line(\n                self.Sections.VAR_CONST_DECLARATIONS,\n                f\"%{out_str_id} = OpVariable %{ptr_t_out_id.strip('%')} Output\"\n            )\n\n\n            # print(f\"return {node.value.body.id} if {node.value.test.left.id} {node.value.test.ops[0].__class__.__name__} {self._extract_content(node.value.test.comparators[0])} else {self._extract_content(node.value.orelse)}\")\n        # elif isinstance(node.value, ast.BinOp):\n            # logging.exception(f\"TODO implement handling binops for return values\", exc_info=False)\n            # raise Exception(\"TODO implement handling binops for return values\")\n\n            # id, ctx = self._eval_line(node.value)\n            # print(f\"returning binop val ({id})\")\n\n            # if self.symbol_exists(id):\n            #     print(\"this was a symbol\")\n            # elif self.intermediate_id_exists(id):\n            #     print(\"this was a temp id\")\n            # else:\n            #     raise Exception(\"idk\")\n\n        else:\n            logging.exception(f\"unhandled type during return node evaluation {node}\", exc_info=False)\n            raise Exception(f\"unhandled type during return node evaluation {node} {type(node)}\")\n\n\n    def visit_Name(self, node): pass\n\n    def _get_id_of_node(self, node):\n        if isinstance(node, ast.Name):\n            if self.symbol_exists(node.id):\n                return node.id\n            else:\n                logging.exception(f\"symbol referenced but does not exist: {node.id}\", exc_info=False)\n                raise Exception(f\"symbol referenced but does not exist: {node.id}\")\n        elif isinstance(node, ast.Constant):\n\n            c_ctx = self.ConstContext(DataType(type(node.value)), node.value)\n            if self.const_exists(c_ctx):\n                return self.get_const_id_with_ctx(c_ctx)\n            else:\n                # TODO: does not account for negative numbers, probably need an UnaryOp section \n                c_id = self.add_const_if_nonexistant(\n                    c_ctx, False\n                )\n                return c_id\n            # return self.spirv_helper.get_const_id(node.value, titan_type.DataType(type(node.value)))\n        else:\n            logging.exception(f\"unhandled node {node}\", exc_info=False)\n            raise Exception(f\"unhandled node {node} {type(node)}\")\n\n    def visit_IfExp(self, node):\n        logging.debug(f\"{node} {node._fields}\")\n\n\n        # this should take care of the comparison node\n        # --- only if IfExp is visited by this function, and not _eval_line\n        super().generic_visit(node)\n\n        # TODO: probably should check if both types match, but as a hack we check only the left one and pray\n        t_id = self.get_primative_type_id(self.get_symbol_type(node.test.left.id))\n\n        body_id = self._get_id_of_node(node.body)\n        orelse_id = self._get_id_of_node(node.orelse)\n\n        intermediate_id = self.get_new_intermediate_id()\n\n        self.add_line(\n            self.Sections.FUNCTIONS,\n            #TODO:                                                              vvv should this just be always -1 of the current id?\n            f\"%{intermediate_id} = OpSelect {t_id} {self._latest_compare_id} %{body_id} %{orelse_id}\"\n        )\n\n        # add id and set it as latest\n        self.add_intermediate_id(f\"{intermediate_id}\", DataType.BOOLEAN)\n        self._latest_ifexp_selector_id = intermediate_id\n\n    # comparison only, do not need to worry about the \"orelse\" value\n    def visit_Compare(self, node):\n        # also fails to do a &gt; b -- \"failed to unpack evaluation, unhandled instance when checking Name object\"\n\n        # if len(node.ops) &gt; 1:\n            # TODO: will probably need recursive function to evaluate all comparisons?\n            # logging.exception(f\"TODO: cannot handle multiple comparisons yet\", exc_info=False)\n            # raise Exception(\"TODO: cannot handle multiple comparisons yet\")\n\n        assert len(node.ops) == 1, \"TODO: cannot handle multiple comparisons\"\n\n        t_id = self.add_type_if_nonexistant(\n            self.TypeContext(\n                DataType.BOOLEAN\n            ),\n            f\"%type_{DataType.BOOLEAN.name.lower()}\"\n        )\n\n        # fails to do 1 &gt; b -- \"constant object has no attribute id\"\n        # TODO: needs typechecking to determine correct type of node\n        # target_type = self.spirv_helper.get_symbol_type(node.left.id) # this will need to be changed to whatever object the left operand is\n\n        eval_left_id, left_ctx = self._eval_line(node.left)\n        eval_right_id, right_ctx = self._eval_line(node.comparators[0])\n\n        left_type = self._extract_type(left_ctx)\n        right_type = self._extract_type(right_ctx)\n\n        assert left_type is right_type, f\"type mismatch, left is {left_type}, right is {right_type}\"\n\n        # big chance that this will have to get changed since it may cause issues if you're not super specific with types\n        # if left_type is not right_type:\n            # logging.exception(f\"{errors.TitanErrors.TYPE_MISMATCH.value}, L: {left_type} R: {right_type} ({errors.TitanErrors.TYPE_MISMATCH.name})\")\n            # raise Exception(f\"{errors.TitanErrors.TYPE_MISMATCH.value}, L: {left_type} R: {right_type} ({errors.TitanErrors.TYPE_MISMATCH.name})\")\n        # else:\n\n        target_type = left_type\n        target_type_id = self.get_primative_type_id(target_type)\n\n\n        # handle left node\n        if isinstance(node.left, ast.Name):\n            # if name, that means symbol, so we have to load it\n            load_str = f\"temp_{node.left.id}\"\n            self.add_line(\n                self.Sections.FUNCTIONS,\n                f\"%{load_str} = OpLoad {target_type_id} %{node.left.id}\"\n            )\n            eval_left_id = load_str # use updated id\n\n        elif isinstance(node.left, ast.Constant):\n            # possibly do nothing, or simply set variables? although we already have info from _eval_line\n            pass\n        else:\n            logging.exception(f\"possibly unhandled left node when evaluating comparison: {node.left} {type(node.left)}\")\n            raise Exception(f\"possibly unhandled left node when evaluating comparison: {node.left} {type(node.left)}\")\n\n\n        # handle comparators\n        # - at the moment this can only handle 1 comparator, so dont do nesting\n        # - might need some recursive function to handle various depths of comparisons i.e. for each comparison, call _eval_line?\n        if isinstance(node.comparators[0], ast.Name):\n            load_str = f\"temp_{node.comparators[0].id}\"\n            self.add_line(\n                self.Sections.FUNCTIONS,\n                f\"%{load_str} = OpLoad {target_type_id} %{node.comparators[0].id}\"\n            )\n            eval_right_id = load_str\n\n        # node.ops contains a list of operators (as ast.LtE, ast.Gt etc etc), we take the zeroth one since atm we can only do 1 comparison\n        opcode = self.__return_correct_opcode(target_type, node.ops[0])\n\n        intermediate_id = self.get_new_intermediate_id()\n        self.add_intermediate_id(f\"{intermediate_id}\", target_type)\n        self.add_line(\n            self.Sections.FUNCTIONS,\n            f\"%{intermediate_id} = {opcode} {t_id} %{eval_left_id.strip('%')} %{eval_right_id.strip('%')}\"\n        )\n\n        self._latest_compare_id = f\"%{intermediate_id}\"\n\n    # TODO: figure out exactly what info is needed from here, if any\n    def visit_arguments(self, node): pass\n\n    def visit_Constant(self, node): pass\n\n    def generic_visit(self, node):\n        logging.debug(f\"generic visit {node.__class__.__name__} {node._fields}\")\n\n    def _extract_content(self, node):\n        \"\"\" Extract the relevant content from a given node type.\n\n            TODO:\n                Better explanation\n\n            Returns:\n                value if node is ``ast.Constant``, if if node is ``ast.Name``\n        \"\"\"\n\n        if isinstance(node, ast.Constant):\n            return node.value\n        elif isinstance(node, ast.Name):\n            return node.id\n        else:\n            logging.exception(f\"idk what to do for {type(node)}\", exc_info=False)\n            raise Exception(f\"idk what to do for {type(node)}\")\n\n    def _extract_type(self, context):\n        \"\"\"\n        attempts to extract the primative type from a given context\n\n        - handles TypeContext, ConstContext, DataType, bool and int\n        \"\"\"\n        if isinstance(context, self.TypeContext):\n            return context.primative_type\n        elif isinstance(context, self.ConstContext):\n            return context.primative_type\n        elif isinstance(context, DataType):\n            return DataType(context.value)\n        elif context is bool or int:\n            return context\n        else:\n            logging.exception(f\"unable to extract type from context - {context} {type(context)}\", exc_info=False)\n            raise Exception(f\"unable to extract type from context - {context} {type(context)}\")\n\n    def __return_correct_opcode(self, chosen_type, operation):\n        logging.debug(f\"determining opcode for {operation} (type: {chosen_type})\")\n\n        if isinstance(chosen_type, DataType):\n            chosen_type = chosen_type.value\n\n        opcode_dict = {\n            (ast.Add, int) : \"OpIAdd\",\n            (ast.Sub, int) : \"OpISub\",\n            (ast.Mult, int) : \"OpIMul\",\n            (ast.Div, int) : \"OpSDiv\",\n            (ast.LShift, int) : \"OpShiftLeftLogical\",\n            (ast.RShift, int) : \"OpShiftRightLogical\",\n            (ast.Eq, int) : \"OpIEqual\",\n            (ast.NotEq, int) : \"OpINotEqual\",\n            (ast.Lt, int) : \"OpSLessThan\",\n            (ast.LtE, int) : \"OpSLessThanEqual\",\n            (ast.Gt, int) : \"OpSGreaterThan\",\n            (ast.GtE, int) : \"OpSGreaterThanEqual\",\n\n            (ast.Add, float) : \"OpFAdd\",\n            (ast.Sub, float) : \"OpFSub\",\n            (ast.Div, float) : \"OpFDiv\",\n            (ast.Mult, float) : \"OpFMult\",\n            (ast.Eq, float) : \"OpFOrdEqual\",\n            (ast.NotEq, float) : \"OpFOrdNotEqual\",\n            (ast.Lt, float) : \"OpFOrdLessThan\",\n            (ast.LtE, float) : \"OpFOrdLessThanEqual\",\n            (ast.Gt, float) : \"OpFOrdGreaterThan\",\n            (ast.GtE, float) : \"OpFOrdGreaterThanEqual\"\n        }\n\n        try:\n            # need __class__ to avoid indexing with object instance\n            return opcode_dict[(operation.__class__, chosen_type)]\n        except KeyError:\n            logging.exception(f\"unable to index opcode: ({operation.__class__}, {chosen_type})\")\n            raise\n        except Exception as e:\n            logging.exception(f\"{e}\")\n            raise\n\n    def _eval_line(self, node):\n        \"\"\" Recursively evaluates a line\n\n            Returns:\n                Final line id\n                Line context\n        \"\"\"\n        logging.debug(f\"evaluating node: {node.__class__}, {node}\")\n\n        if isinstance(node, ast.BinOp):\n\n            left_id, left_ctx = self._eval_line(node.left)\n            right_id, right_ctx = self._eval_line(node.right)\n\n            return_ctx = None\n            chosen_type = None\n\n            left_type = self._extract_type(left_ctx)\n            left_type_id = self.get_primative_type_id(left_type)\n\n            right_type = self._extract_type(right_ctx)\n            right_type_id = self.get_primative_type_id(right_type)\n\n\n            assert left_type is right_type, f\"type mismatch, left is {left_type}, right is {right_type}\"\n\n            # if left_type is not right_type:\n                # logging.exception(f\"mismatched types l: {left_type} r: {right_type}\", exc_info=False)\n                # raise Exception(f\"mismatched types l: {left_type}  r: {right_type}\")\n\n            if left_type is None:\n                return_ctx = right_ctx\n                chosen_type = right_type\n            elif right_type is None:\n                return_ctx = left_ctx\n                chosen_type = left_type\n            elif left_type is right_type:\n                return_ctx = left_ctx\n                chosen_type = left_type\n            else:\n                logging.exception(f\"unable to determine return type (L: {left_type} , R: {right_type})\", exc_info=False)\n                raise Exception(f\"unable to determine return type (L: {left_type} , R: {right_type})\")\n\n            left_id = self.add_temp_load_op_if_needed(left_id, left_type_id)\n            right_id = self.add_temp_load_op_if_needed(right_id, right_type_id)\n\n            chosen_type_id = self.get_primative_type_id(DataType(chosen_type))\n\n            # set the appropriate opcode\n            opcode = None\n            opcode = self.__return_correct_opcode(chosen_type, node.op)\n\n            assert not opcode is None, f\"opcode is still none after attempting to determine it, why?\"\n\n            # if opcode is None:\n                # logging.exception(f\"opcode was not updated, why? {node.op} {chosen_type} {left_id} {right_id} {left_type} {right_type}\", exc_info=False)\n                # raise Exception(f\"opcode was not updated, why? {node.op} {chosen_type} {left_id} {right_id} {left_type} {right_type}\")\n\n            # spirv_line_str = f\"titan_id_{self.get_and_increment_intermediate_id()}\"\n            spirv_line_str = self.get_new_intermediate_id()\n            self.add_line(\n                self.Sections.FUNCTIONS,\n                f\"%{spirv_line_str} = {opcode} {chosen_type_id} %{left_id.strip('%')} %{right_id.strip('%')}\"\n            )\n            self.add_intermediate_id(f\"{spirv_line_str}\", chosen_type)\n\n            # TODO: check which type is not None, and propagate that back up\n            # TODO: should we change the type for a symbol?\n            return spirv_line_str, return_ctx\n\n        elif isinstance(node, ast.UnaryOp):\n\n            if isinstance(node.op, ast.USub):\n                value = node.operand.value\n\n                # if type(value) not in [int, float, bool]:\n                    # logging.exception(f\"got unexpected constant value type {type(value)}\", exc_info=False)\n                    # raise Exception(f\"got unexpected constant value type {type(value)}\")\n\n                assert type(value) in [int, float, bool], f\"got unexpected constant value type: {type(value)}\"\n\n                c_ctx = self.ConstContext(type(value), value * -1)\n\n                if not self.const_exists(c_ctx):\n                    # id = f\"%const_{self._return_string_from_type(type(value))}_n{str(value).replace('.', '_')}\"\n                    id = f\"%const_{DataType(type(value)).name.lower()}_n{str(value).replace('.', '_')}\"\n                    self.add_const_if_nonexistant(c_ctx, True)\n                    return id, c_ctx\n                else:\n                    return self.get_const_id(value*-1, type(value)), c_ctx\n\n            else:\n                logging.exception(f\"unhandled additional operator in unaryop class {node.op}\", exc_info=False)\n                raise Exception(f\"unhandled additional operator in unaryop class {node.op}\")\n                # return f\"{node.op.__class__.__name__} {node.operand.value} {type(node.operand.value)} ({isinstance(node.op,ast.USub)})\"\n\n        elif isinstance(node, ast.Name):\n            # if not self.symbol_exists(node.id):\n                # logging.exception(f\"symbol '{node.id}' does not exist\", exc_info=False)\n                # raise Exception(f\"symbol '{node.id}' does not exist\")\n\n            assert self.symbol_exists(node.id), f\"symbol '{node.id}' does not exist\"\n\n            return f\"{node.id}\", self.get_symbol_type(node.id)\n\n        elif isinstance(node, ast.Constant):\n\n            # TODO: maybe use titan_types instead of python types?\n            # BUG: if using DataType, _eval_line will fail with type mismatch error\n            #      but if left alone, it sometimes creates duplicate constant lines?\n            #      reproduce with simple_neuron -&gt; duplicate \"%const_integer_0\"\n            #      may be worth switching over to using bidicts?\n            c_ctx = self.ConstContext(DataType(type(node.value)), node.value)\n            # c_ctx = self.ConstContext(type(node.value), node.value)\n\n            if not self.const_exists(c_ctx):\n                # TODO: check if type also exists?\n                # id = f\"%const_{self._return_string_from_type(type(node.value))}_{node.value}\"\n                id = f\"%const_{DataType(type(node.value)).name.lower()}_{str(node.value).replace('.', '_')}\"\n                # self.spirv_helper.add_const(c_ctx, id)\n                self.add_const_if_nonexistant(c_ctx)\n                return id, c_ctx\n            else:\n                return self.get_const_id(node.value, DataType(type(node.value))), c_ctx\n\n        elif isinstance(node, ast.IfExp):\n            self.visit_IfExp(node)\n\n            # return the context of the comparison node, because that'll indicate the type\n            # whereas the the ifexp_selector would only be bool due to the comparison condition\n            ctx = self.get_type_of_intermediate_id(self._latest_compare_id[1:])\n            return self._latest_ifexp_selector_id, ctx\n\n        elif isinstance(node, ast.Compare):\n            self.visit_Compare(node)\n\n            ctx = self.get_type_of_intermediate_id(self._latest_compare_id[1:])\n            return self._latest_compare_id, ctx\n\n        elif isinstance(node, ast.Call):\n\n            module_name = node.func.value.id\n            function_name = node.func.attr\n\n            exists_in_normal_mapping = module_name in self._import_mapping\n            exists_in_inverse_mapping = module_name in self._import_mapping.inverse\n\n            # check if explicitly using numpy for arrays etc\n            module_is_numpy = False\n            if exists_in_normal_mapping:\n                module_is_numpy = True if self._import_mapping[module_name] == \"numpy\" else False\n            elif exists_in_inverse_mapping:\n                module_is_numpy = True if self._import_mapping.inverse[module_name] == \"numpy\" else False\n\n\n            assert module_is_numpy, f\"unhandled call object for {module_name}, probably incompatible\"\n            assert function_name in [\"empty\", \"zeroes\", \"ones\"], f\"unhandled/unimplemented numpy function being accessed: {function_name}\"\n\n            logging.warn(\"initialisation of arrays with a specific value/values is not supported, do not rely on this behaviour\")\n\n            type_as_str = None\n            for keyword in node.keywords:\n                if keyword.arg == \"dtype\":\n                    type_as_str = keyword.value.id\n\n            assert not type_as_str is None, f\"unable to set type for array\"\n\n            # add just in case\n            type_as_datatype = DataType(self._get_python_type_from_string(type_as_str))\n            primative_type_id = self.add_type_if_nonexistant(\n                self.TypeContext(type_as_datatype),\n                f\"%type_{type_as_datatype.name.lower()}\"\n            )\n\n            array_size = node.args[0]            \n            assert not isinstance(array_size, tuple), f\"TODO: tuples not supported for defining array shapes\"\n\n            array_size_id, array_size_ctx = self._eval_line(array_size)\n            assert array_size_ctx.value &gt; 0, f\"array size cannot be less than or equal to 0, got {array_size_ctx.value} instead\"\n\n            t_ctx_array = self.TypeContext(\n                primative_type=DataType(self._get_python_type_from_string(type_as_str)),\n                is_array=True,\n                is_pointer=False,\n                array_size=array_size_ctx.value\n            )\n\n            t_id_array = self.add_type_if_nonexistant(t_ctx_array, f\"%array_{type_as_str}_{array_size_ctx.value}\")\n\n            # making the assumtion that any arrays being defined in here will defined inside the function\n            # and therefore will have the Function storage location\n\n            t_ctx_array_ptr = self.TypeContext(\n                primative_type= DataType(self._get_python_type_from_string(type_as_str)),\n                storage_type= StorageType.FUNCTION_VAR,\n                is_pointer= True,\n                is_array= True,\n                array_size= array_size_ctx.value\n            )\n\n            # NOTE: need to handle different storage locations? or will that be done somewhere else?\n            t_id_array_ptr = self.add_type_if_nonexistant(t_ctx_array_ptr, f\"%array_ptr_{type_as_str}_{array_size_ctx.value}_{StorageType.FUNCTION_VAR.name.lower()}\")\n\n            return t_id_array_ptr, t_ctx_array_ptr\n\n        elif isinstance(node, ast.Assign):\n            type_id, type_ctx = self._eval_line(node.value)\n\n            # special case: array definition\n            if isinstance(node.value, ast.Call):\n                symbol_name = node.targets[0].id\n\n                # if the symbol doesn't already exist, we can be confident that it hasn't been declared yet\n                # can define as StorageType.FUNCTION_VAR because arrays in parameters will be handled differently\n                self.add_symbol_if_nonexistant(symbol_name, type_ctx.primative_type, StorageType.FUNCTION_VAR, type_id, type_ctx.array_size)\n\n                return \"%\" + symbol_name, type_ctx\n\n            else:\n                raise Exception(f\"unexpected node: {type(node.value)}\")\n\n\n        elif isinstance(node, ast.Subscript):\n            \"\"\" this stage will return a temporary ID related to the OpAccessChain operand\"\"\"\n\n            assert self.symbol_exists(node.value.id), f\"symbol '{node.value.id}' doesn't exist\"\n\n            index_id, _ = self._eval_line(node.slice)\n            array_ctx = self.get_symbol_info(node.value.id)\n\n            element_ctx = self.TypeContext(\n                array_ctx.type,\n                array_ctx.location,\n                is_pointer=True\n            )\n            element_type_id = self.get_type_id(element_ctx)\n\n            temp_id = self.get_new_intermediate_id()\n\n            self.add_line(\n                self.Sections.FUNCTIONS,\n                f\"%{temp_id} = OpAccessChain {element_type_id} %{node.value.id} %{index_id.strip('%')}\"\n            )\n\n            # function does not account for pointer, potential fix needed?\n            self.add_intermediate_id(temp_id, DataType(array_ctx.type), is_accessing_array=True)\n\n            return temp_id, element_ctx\n\n        elif isinstance(node, ast.Slice):\n            raise Exception(f\"slicing not implemented: {node}\")\n\n        else:\n            logging.exception(f\"unexpected {type(node)} to parse in eval_line, probably not implemented yet\", exc_info=False)\n            raise Exception(f\"unexpected {type(node)} to parse in eval_line, probably not implemented yet\")\n\n    def _eval_line_wrap(self, node):\n        \"\"\" Works on ast.Assign or ast.AnnAssign nodes\n        \"\"\"\n\n        # this will call _eval_line on various nodes, including IfExp instead of going through visit_IfExp\n        # is this going to be an issue?\n\n        if isinstance(node, ast.Assign):\n            assert len(node.targets) == 1, f\"multiple assignments not supported\"\n\n            # if we're assinging via a call specifically\n            if isinstance(node.value, ast.Call):\n                evaluated = self._eval_line(node)\n                # logging.debug(f\" = {evaluated}\")\n                return evaluated\n\n            # for target in node.targets:\n            target = node.targets[0]\n            # logging.debug(f\"{target.id}\")\n\n            evaluated = self._eval_line(node.value)\n            # logging.debug(f\" = {evaluated}\")\n            return evaluated\n\n        elif isinstance(node, ast.AnnAssign):\n            # logging.debug(f\"{node.target.id}\")\n\n            evaluated = self._eval_line(node.value)\n            # logging.debug(f\" = {evaluated}\")\n            return evaluated\n</code></pre>"},{"location":"reference-docs/compiler/compiler/spirv/#titan.compiler.spirv.SPIRVAssembler.ConstContext","title":"<code>ConstContext</code>","text":"<p>             Bases: <code>NamedTuple</code></p> <p>Tuple that provides context about a given constant.</p> <p>Attributes:</p> Name Type Description <code>primative_type</code> <code>DataType</code> <p>Base/primative (python) type.</p> <code>value</code> <code>Union[int, float, bool, None]</code> <p>Value of the constant. Can be int, float, bool or None.</p> <code>declared_id</code> <code>str</code> <p>SPIR-V ID associated to the particular constant.</p> Source code in <code>titan/compiler/spirv.py</code> <pre><code>class ConstContext(NamedTuple):\n    \"\"\" Tuple that provides context about a given constant.\n\n        Attributes:\n            primative_type (titan.common.type.DataType): Base/primative (python) type.\n            value: Value of the constant. Can be int, float, bool or None.\n            declared_id: SPIR-V ID associated to the particular constant.\n    \"\"\"\n    primative_type: DataType\n    value: Union[int, float, bool, None]\n    declared_id: str = None\n</code></pre>"},{"location":"reference-docs/compiler/compiler/spirv/#titan.compiler.spirv.SPIRVAssembler.IntermediateIDContext","title":"<code>IntermediateIDContext</code>","text":"<p>             Bases: <code>NamedTuple</code></p> <p>Tuple to store information about an intermediate ID. </p> <p>Attributes:</p> Name Type Description <code>type</code> <code>DataType</code> <p>Base/primative type.</p> <code>is_accessing_array</code> <code>bool</code> <p>Whether the ID is accessing an array or not (i.e represents OpAccessChain).</p> Source code in <code>titan/compiler/spirv.py</code> <pre><code>class IntermediateIDContext(NamedTuple):\n    \"\"\" Tuple to store information about an intermediate ID. \n\n        Attributes:\n            type: Base/primative type.\n            is_accessing_array: Whether the ID is accessing an array or not (i.e represents OpAccessChain).\n    \"\"\"\n    type: DataType\n    is_accessing_array: bool = False\n</code></pre>"},{"location":"reference-docs/compiler/compiler/spirv/#titan.compiler.spirv.SPIRVAssembler.Sections","title":"<code>Sections</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Enum containing sections that are present in the final SPIR-V assembly file.</p> <p>Dividing the SPIR-V file into sections helps with ensuring that the code is placed in the right spot, and can be easily altered if needed.</p> Source code in <code>titan/compiler/spirv.py</code> <pre><code>class Sections(Enum):\n    \"\"\" Enum containing sections that are present in the final SPIR-V assembly file.\n\n        Dividing the SPIR-V file into sections helps with ensuring that the code is\n        placed in the right spot, and can be easily altered if needed.\n    \"\"\"\n    CAPABILITY_AND_EXTENSION = auto()\n    ENTRY_AND_EXEC_MODES = auto()\n    DEBUG_STATEMENTS = auto()\n    ANNOTATIONS = auto()\n    TYPES = auto()\n    VAR_CONST_DECLARATIONS = auto()\n    ARRAY_TYPES = auto()\n    ARRAY_DECLARATIONS = auto()\n    FUNCTIONS = auto()\n</code></pre>"},{"location":"reference-docs/compiler/compiler/spirv/#titan.compiler.spirv.SPIRVAssembler.SymbolInfo","title":"<code>SymbolInfo</code>","text":"<p>             Bases: <code>NamedTuple</code></p> <p>Tuple that associates a primative type with a storage location.</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>DataType</code> <p>Base/primative (python) type.</p> <code>location</code> <code>StorageType</code> <p>Storage type in SPIR-V.</p> <code>is_array</code> <code>bool</code> <p>Is the symbol an array type?</p> <code>declared_type_id</code> <code>str</code> <p>SPIR-V type ID associated to the particular symbol.</p> Source code in <code>titan/compiler/spirv.py</code> <pre><code>class SymbolInfo(NamedTuple):\n    \"\"\" Tuple that associates a primative type with a storage location.\n\n        Attributes:\n            type (titan.common.type.DataType): Base/primative (python) type.\n            location (titan.common.type.StorageType): Storage type in SPIR-V.\n            is_array (bool): Is the symbol an array type?\n            declared_type_id (str): SPIR-V type ID associated to the particular symbol.\n    \"\"\"\n    type: DataType\n    location: StorageType\n    is_array: bool = False\n    declared_type_id: str = None\n</code></pre>"},{"location":"reference-docs/compiler/compiler/spirv/#titan.compiler.spirv.SPIRVAssembler.TypeContext","title":"<code>TypeContext</code>","text":"<p>             Bases: <code>NamedTuple</code></p> <p>Tuple that provides context about a given type. Used to align Python types with SPIR-V.</p> <p>Attributes:</p> Name Type Description <code>primative_type</code> <code>DataType</code> <p>Base/primative (python) type.</p> <code>storage_type</code> <code>StorageType</code> <p>Storage type in SPIR-V.</p> <code>is_constant</code> <code>bool</code> <p>Type describes a constant.</p> <code>is_pointer</code> <code>bool</code> <p>Type describes a pointer.</p> <code>is_function_typedef</code> <code>bool</code> <p>Type describes a function definition. </p> <code>is_array</code> <code>bool</code> <p>Type describes array.</p> <code>array_size</code> <code>int</code> <p>Stores size of array.</p> Source code in <code>titan/compiler/spirv.py</code> <pre><code>class TypeContext(NamedTuple):\n    \"\"\" Tuple that provides context about a given type. Used to align Python types with SPIR-V.\n\n        Attributes:\n            primative_type (titan.common.type.DataType): Base/primative (python) type.\n            storage_type (titan.common.type.StorageType): Storage type in SPIR-V.\n            is_constant (bool): Type describes a constant.\n            is_pointer (bool): Type describes a pointer.\n            is_function_typedef (bool): Type describes a function definition. \n            is_array (bool): Type describes array.\n            array_size (int): Stores size of array.\n    \"\"\"\n    primative_type: DataType\n    storage_type: StorageType = StorageType.NONE\n    is_constant: bool = False\n    is_pointer: bool = False\n    is_function_typedef: bool = False\n    is_array: bool = False\n    array_size: int = 0\n</code></pre>"},{"location":"reference-docs/compiler/compiler/spirv/#titan.compiler.spirv.SPIRVAssembler.__init__","title":"<code>__init__(target_file, disable_debug=True)</code>","text":"<p>Init function for _SPIRVHelperGenerator.</p> <p>Creates various attributes and allows for helper function access.</p> <p>Parameters:</p> Name Type Description Default <code>disable_debug</code> <code>bool</code> <p>Disable debug output.</p> <code>True</code> <code>target_file</code> <code>str</code> <p>File to read.</p> required <p>Attributes:</p> Name Type Description <code>entry_point</code> <code>string</code> <p>TODO</p> <code>_disable_debug</code> <code>bool</code> <p>Disables debug. Set to value of parameter.</p> <code>_latest_ifexp_selector_id</code> <code>None</code> <p>Last known ID for an if-expression selector.</p> <code>_latest_compare_id</code> <code>None</code> <p>Last known ID for a compare expression.</p> <code>_latest_function_name</code> <code>None</code> <p>TODO</p> <code>_decorator_dict</code> <code>None</code> <p>Stores information regarding decorators are used on which functions.</p> <code>input_port_list</code> <code>TypedDict</code> <p>List of input port names and their primative types.</p> <code>output_port_lsit</code> <code>TypedDict</code> <p>List of output port names and their primative types.</p> <code>_internal_output_port_list_counter</code> <code>None</code> <p>TODO</p> <code>output_type_list</code> <code>None</code> <p>TODO</p> <code>symbol_info</code> <code>None</code> <p>TODO</p> <code>location_id</code> <code>None</code> <p>TODO</p> <code>intermediate_id</code> <code>int</code> <p>Keep track of latest intermediate ID (used by unrolled expressions).</p> <code>return_id</code> <code>int</code> <p>TODO</p> <code>intermediate_ids</code> <code>int</code> <p>List of used intermediate IDs. Stores ID as string and primative type.</p> <code>declared_constants</code> <code>int</code> <p>List of declared constants. Stores ConstContext and string ID of constant.</p> <code>declared_types</code> <code>int</code> <p>List of declared types. Stores primative type and string ID.</p> <code>body</code> <code>int</code> <p>TODO</p> <code>generated_spirv</code> <code>dict</code> <p>Dictionary indexed with Sections enum, and stores generated lines in a list.</p> <code>_import_mapping</code> <code>bidict</code> <p>Bi-directional dictionary to store import names &amp; aliases</p> Source code in <code>titan/compiler/spirv.py</code> <pre><code>def __init__(self, target_file: str, disable_debug=True):\n    \"\"\" Init function for _SPIRVHelperGenerator.\n\n        Creates various attributes and allows for helper function access.\n\n        Args:\n            disable_debug (bool): Disable debug output.\n            target_file: File to read.\n\n        Attributes:\n            entry_point (string): TODO\n            _disable_debug (bool): Disables debug. Set to value of parameter.\n            _latest_ifexp_selector_id (None): Last known ID for an if-expression selector.\n            _latest_compare_id (None): Last known ID for a compare expression.\n            _latest_function_name (None): TODO\n            _decorator_dict: Stores information regarding decorators are used on which functions.\n            input_port_list (TypedDict): List of input port names and their primative types.\n            output_port_lsit (TypedDict): List of output port names and their primative types.\n            _internal_output_port_list_counter (None): TODO\n            output_type_list: TODO\n            symbol_info: TODO\n            location_id: TODO\n            intermediate_id (int): Keep track of latest intermediate ID (used by unrolled expressions).\n            return_id (int): TODO\n            intermediate_ids: List of used intermediate IDs. Stores ID as string and primative type.\n            declared_constants: List of declared constants. Stores ConstContext and string ID of constant.\n            declared_types: List of declared types. Stores primative type and string ID.\n            body: TODO\n            generated_spirv (dict): Dictionary indexed with Sections enum, and stores generated lines in a list.\n            _import_mapping (bidict): Bi-directional dictionary to store import names &amp; aliases\n    \"\"\"\n\n    self._disable_debug = disable_debug\n    self._target_file = target_file\n    self._tree = ast.parse(open(self._target_file, \"r\").read())\n</code></pre>"},{"location":"reference-docs/compiler/compiler/spirv/#titan.compiler.spirv.SPIRVAssembler._eval_line","title":"<code>_eval_line(node)</code>","text":"<p>Recursively evaluates a line</p> <p>Returns:</p> Type Description <p>Final line id</p> <p>Line context</p> Source code in <code>titan/compiler/spirv.py</code> <pre><code>def _eval_line(self, node):\n    \"\"\" Recursively evaluates a line\n\n        Returns:\n            Final line id\n            Line context\n    \"\"\"\n    logging.debug(f\"evaluating node: {node.__class__}, {node}\")\n\n    if isinstance(node, ast.BinOp):\n\n        left_id, left_ctx = self._eval_line(node.left)\n        right_id, right_ctx = self._eval_line(node.right)\n\n        return_ctx = None\n        chosen_type = None\n\n        left_type = self._extract_type(left_ctx)\n        left_type_id = self.get_primative_type_id(left_type)\n\n        right_type = self._extract_type(right_ctx)\n        right_type_id = self.get_primative_type_id(right_type)\n\n\n        assert left_type is right_type, f\"type mismatch, left is {left_type}, right is {right_type}\"\n\n        # if left_type is not right_type:\n            # logging.exception(f\"mismatched types l: {left_type} r: {right_type}\", exc_info=False)\n            # raise Exception(f\"mismatched types l: {left_type}  r: {right_type}\")\n\n        if left_type is None:\n            return_ctx = right_ctx\n            chosen_type = right_type\n        elif right_type is None:\n            return_ctx = left_ctx\n            chosen_type = left_type\n        elif left_type is right_type:\n            return_ctx = left_ctx\n            chosen_type = left_type\n        else:\n            logging.exception(f\"unable to determine return type (L: {left_type} , R: {right_type})\", exc_info=False)\n            raise Exception(f\"unable to determine return type (L: {left_type} , R: {right_type})\")\n\n        left_id = self.add_temp_load_op_if_needed(left_id, left_type_id)\n        right_id = self.add_temp_load_op_if_needed(right_id, right_type_id)\n\n        chosen_type_id = self.get_primative_type_id(DataType(chosen_type))\n\n        # set the appropriate opcode\n        opcode = None\n        opcode = self.__return_correct_opcode(chosen_type, node.op)\n\n        assert not opcode is None, f\"opcode is still none after attempting to determine it, why?\"\n\n        # if opcode is None:\n            # logging.exception(f\"opcode was not updated, why? {node.op} {chosen_type} {left_id} {right_id} {left_type} {right_type}\", exc_info=False)\n            # raise Exception(f\"opcode was not updated, why? {node.op} {chosen_type} {left_id} {right_id} {left_type} {right_type}\")\n\n        # spirv_line_str = f\"titan_id_{self.get_and_increment_intermediate_id()}\"\n        spirv_line_str = self.get_new_intermediate_id()\n        self.add_line(\n            self.Sections.FUNCTIONS,\n            f\"%{spirv_line_str} = {opcode} {chosen_type_id} %{left_id.strip('%')} %{right_id.strip('%')}\"\n        )\n        self.add_intermediate_id(f\"{spirv_line_str}\", chosen_type)\n\n        # TODO: check which type is not None, and propagate that back up\n        # TODO: should we change the type for a symbol?\n        return spirv_line_str, return_ctx\n\n    elif isinstance(node, ast.UnaryOp):\n\n        if isinstance(node.op, ast.USub):\n            value = node.operand.value\n\n            # if type(value) not in [int, float, bool]:\n                # logging.exception(f\"got unexpected constant value type {type(value)}\", exc_info=False)\n                # raise Exception(f\"got unexpected constant value type {type(value)}\")\n\n            assert type(value) in [int, float, bool], f\"got unexpected constant value type: {type(value)}\"\n\n            c_ctx = self.ConstContext(type(value), value * -1)\n\n            if not self.const_exists(c_ctx):\n                # id = f\"%const_{self._return_string_from_type(type(value))}_n{str(value).replace('.', '_')}\"\n                id = f\"%const_{DataType(type(value)).name.lower()}_n{str(value).replace('.', '_')}\"\n                self.add_const_if_nonexistant(c_ctx, True)\n                return id, c_ctx\n            else:\n                return self.get_const_id(value*-1, type(value)), c_ctx\n\n        else:\n            logging.exception(f\"unhandled additional operator in unaryop class {node.op}\", exc_info=False)\n            raise Exception(f\"unhandled additional operator in unaryop class {node.op}\")\n            # return f\"{node.op.__class__.__name__} {node.operand.value} {type(node.operand.value)} ({isinstance(node.op,ast.USub)})\"\n\n    elif isinstance(node, ast.Name):\n        # if not self.symbol_exists(node.id):\n            # logging.exception(f\"symbol '{node.id}' does not exist\", exc_info=False)\n            # raise Exception(f\"symbol '{node.id}' does not exist\")\n\n        assert self.symbol_exists(node.id), f\"symbol '{node.id}' does not exist\"\n\n        return f\"{node.id}\", self.get_symbol_type(node.id)\n\n    elif isinstance(node, ast.Constant):\n\n        # TODO: maybe use titan_types instead of python types?\n        # BUG: if using DataType, _eval_line will fail with type mismatch error\n        #      but if left alone, it sometimes creates duplicate constant lines?\n        #      reproduce with simple_neuron -&gt; duplicate \"%const_integer_0\"\n        #      may be worth switching over to using bidicts?\n        c_ctx = self.ConstContext(DataType(type(node.value)), node.value)\n        # c_ctx = self.ConstContext(type(node.value), node.value)\n\n        if not self.const_exists(c_ctx):\n            # TODO: check if type also exists?\n            # id = f\"%const_{self._return_string_from_type(type(node.value))}_{node.value}\"\n            id = f\"%const_{DataType(type(node.value)).name.lower()}_{str(node.value).replace('.', '_')}\"\n            # self.spirv_helper.add_const(c_ctx, id)\n            self.add_const_if_nonexistant(c_ctx)\n            return id, c_ctx\n        else:\n            return self.get_const_id(node.value, DataType(type(node.value))), c_ctx\n\n    elif isinstance(node, ast.IfExp):\n        self.visit_IfExp(node)\n\n        # return the context of the comparison node, because that'll indicate the type\n        # whereas the the ifexp_selector would only be bool due to the comparison condition\n        ctx = self.get_type_of_intermediate_id(self._latest_compare_id[1:])\n        return self._latest_ifexp_selector_id, ctx\n\n    elif isinstance(node, ast.Compare):\n        self.visit_Compare(node)\n\n        ctx = self.get_type_of_intermediate_id(self._latest_compare_id[1:])\n        return self._latest_compare_id, ctx\n\n    elif isinstance(node, ast.Call):\n\n        module_name = node.func.value.id\n        function_name = node.func.attr\n\n        exists_in_normal_mapping = module_name in self._import_mapping\n        exists_in_inverse_mapping = module_name in self._import_mapping.inverse\n\n        # check if explicitly using numpy for arrays etc\n        module_is_numpy = False\n        if exists_in_normal_mapping:\n            module_is_numpy = True if self._import_mapping[module_name] == \"numpy\" else False\n        elif exists_in_inverse_mapping:\n            module_is_numpy = True if self._import_mapping.inverse[module_name] == \"numpy\" else False\n\n\n        assert module_is_numpy, f\"unhandled call object for {module_name}, probably incompatible\"\n        assert function_name in [\"empty\", \"zeroes\", \"ones\"], f\"unhandled/unimplemented numpy function being accessed: {function_name}\"\n\n        logging.warn(\"initialisation of arrays with a specific value/values is not supported, do not rely on this behaviour\")\n\n        type_as_str = None\n        for keyword in node.keywords:\n            if keyword.arg == \"dtype\":\n                type_as_str = keyword.value.id\n\n        assert not type_as_str is None, f\"unable to set type for array\"\n\n        # add just in case\n        type_as_datatype = DataType(self._get_python_type_from_string(type_as_str))\n        primative_type_id = self.add_type_if_nonexistant(\n            self.TypeContext(type_as_datatype),\n            f\"%type_{type_as_datatype.name.lower()}\"\n        )\n\n        array_size = node.args[0]            \n        assert not isinstance(array_size, tuple), f\"TODO: tuples not supported for defining array shapes\"\n\n        array_size_id, array_size_ctx = self._eval_line(array_size)\n        assert array_size_ctx.value &gt; 0, f\"array size cannot be less than or equal to 0, got {array_size_ctx.value} instead\"\n\n        t_ctx_array = self.TypeContext(\n            primative_type=DataType(self._get_python_type_from_string(type_as_str)),\n            is_array=True,\n            is_pointer=False,\n            array_size=array_size_ctx.value\n        )\n\n        t_id_array = self.add_type_if_nonexistant(t_ctx_array, f\"%array_{type_as_str}_{array_size_ctx.value}\")\n\n        # making the assumtion that any arrays being defined in here will defined inside the function\n        # and therefore will have the Function storage location\n\n        t_ctx_array_ptr = self.TypeContext(\n            primative_type= DataType(self._get_python_type_from_string(type_as_str)),\n            storage_type= StorageType.FUNCTION_VAR,\n            is_pointer= True,\n            is_array= True,\n            array_size= array_size_ctx.value\n        )\n\n        # NOTE: need to handle different storage locations? or will that be done somewhere else?\n        t_id_array_ptr = self.add_type_if_nonexistant(t_ctx_array_ptr, f\"%array_ptr_{type_as_str}_{array_size_ctx.value}_{StorageType.FUNCTION_VAR.name.lower()}\")\n\n        return t_id_array_ptr, t_ctx_array_ptr\n\n    elif isinstance(node, ast.Assign):\n        type_id, type_ctx = self._eval_line(node.value)\n\n        # special case: array definition\n        if isinstance(node.value, ast.Call):\n            symbol_name = node.targets[0].id\n\n            # if the symbol doesn't already exist, we can be confident that it hasn't been declared yet\n            # can define as StorageType.FUNCTION_VAR because arrays in parameters will be handled differently\n            self.add_symbol_if_nonexistant(symbol_name, type_ctx.primative_type, StorageType.FUNCTION_VAR, type_id, type_ctx.array_size)\n\n            return \"%\" + symbol_name, type_ctx\n\n        else:\n            raise Exception(f\"unexpected node: {type(node.value)}\")\n\n\n    elif isinstance(node, ast.Subscript):\n        \"\"\" this stage will return a temporary ID related to the OpAccessChain operand\"\"\"\n\n        assert self.symbol_exists(node.value.id), f\"symbol '{node.value.id}' doesn't exist\"\n\n        index_id, _ = self._eval_line(node.slice)\n        array_ctx = self.get_symbol_info(node.value.id)\n\n        element_ctx = self.TypeContext(\n            array_ctx.type,\n            array_ctx.location,\n            is_pointer=True\n        )\n        element_type_id = self.get_type_id(element_ctx)\n\n        temp_id = self.get_new_intermediate_id()\n\n        self.add_line(\n            self.Sections.FUNCTIONS,\n            f\"%{temp_id} = OpAccessChain {element_type_id} %{node.value.id} %{index_id.strip('%')}\"\n        )\n\n        # function does not account for pointer, potential fix needed?\n        self.add_intermediate_id(temp_id, DataType(array_ctx.type), is_accessing_array=True)\n\n        return temp_id, element_ctx\n\n    elif isinstance(node, ast.Slice):\n        raise Exception(f\"slicing not implemented: {node}\")\n\n    else:\n        logging.exception(f\"unexpected {type(node)} to parse in eval_line, probably not implemented yet\", exc_info=False)\n        raise Exception(f\"unexpected {type(node)} to parse in eval_line, probably not implemented yet\")\n</code></pre>"},{"location":"reference-docs/compiler/compiler/spirv/#titan.compiler.spirv.SPIRVAssembler._eval_line_wrap","title":"<code>_eval_line_wrap(node)</code>","text":"<p>Works on ast.Assign or ast.AnnAssign nodes</p> Source code in <code>titan/compiler/spirv.py</code> <pre><code>def _eval_line_wrap(self, node):\n    \"\"\" Works on ast.Assign or ast.AnnAssign nodes\n    \"\"\"\n\n    # this will call _eval_line on various nodes, including IfExp instead of going through visit_IfExp\n    # is this going to be an issue?\n\n    if isinstance(node, ast.Assign):\n        assert len(node.targets) == 1, f\"multiple assignments not supported\"\n\n        # if we're assinging via a call specifically\n        if isinstance(node.value, ast.Call):\n            evaluated = self._eval_line(node)\n            # logging.debug(f\" = {evaluated}\")\n            return evaluated\n\n        # for target in node.targets:\n        target = node.targets[0]\n        # logging.debug(f\"{target.id}\")\n\n        evaluated = self._eval_line(node.value)\n        # logging.debug(f\" = {evaluated}\")\n        return evaluated\n\n    elif isinstance(node, ast.AnnAssign):\n        # logging.debug(f\"{node.target.id}\")\n\n        evaluated = self._eval_line(node.value)\n        # logging.debug(f\" = {evaluated}\")\n        return evaluated\n</code></pre>"},{"location":"reference-docs/compiler/compiler/spirv/#titan.compiler.spirv.SPIRVAssembler._extract_content","title":"<code>_extract_content(node)</code>","text":"<p>Extract the relevant content from a given node type.</p> TODO <p>Better explanation</p> <p>Returns:</p> Type Description <p>value if node is <code>ast.Constant</code>, if if node is <code>ast.Name</code></p> Source code in <code>titan/compiler/spirv.py</code> <pre><code>def _extract_content(self, node):\n    \"\"\" Extract the relevant content from a given node type.\n\n        TODO:\n            Better explanation\n\n        Returns:\n            value if node is ``ast.Constant``, if if node is ``ast.Name``\n    \"\"\"\n\n    if isinstance(node, ast.Constant):\n        return node.value\n    elif isinstance(node, ast.Name):\n        return node.id\n    else:\n        logging.exception(f\"idk what to do for {type(node)}\", exc_info=False)\n        raise Exception(f\"idk what to do for {type(node)}\")\n</code></pre>"},{"location":"reference-docs/compiler/compiler/spirv/#titan.compiler.spirv.SPIRVAssembler._extract_type","title":"<code>_extract_type(context)</code>","text":"<p>attempts to extract the primative type from a given context</p> <ul> <li>handles TypeContext, ConstContext, DataType, bool and int</li> </ul> Source code in <code>titan/compiler/spirv.py</code> <pre><code>def _extract_type(self, context):\n    \"\"\"\n    attempts to extract the primative type from a given context\n\n    - handles TypeContext, ConstContext, DataType, bool and int\n    \"\"\"\n    if isinstance(context, self.TypeContext):\n        return context.primative_type\n    elif isinstance(context, self.ConstContext):\n        return context.primative_type\n    elif isinstance(context, DataType):\n        return DataType(context.value)\n    elif context is bool or int:\n        return context\n    else:\n        logging.exception(f\"unable to extract type from context - {context} {type(context)}\", exc_info=False)\n        raise Exception(f\"unable to extract type from context - {context} {type(context)}\")\n</code></pre>"},{"location":"reference-docs/compiler/compiler/spirv/#titan.compiler.spirv.SPIRVAssembler._get_python_type_from_string","title":"<code>_get_python_type_from_string(type)</code>","text":"<p>Returns the Python type by extracting the string from the type, and evaluating it.</p> Warning <p>This is probably bad, and should be replaced when possible.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>str</code> <p>Python type as a string, i.e. \"\" required <p>Returns:</p> Type Description <p>Type as an object.</p> Source code in <code>titan/compiler/spirv.py</code> <pre><code>def _get_python_type_from_string(self, type: str):\n    \"\"\" Returns the Python type by extracting the string from the type, and evaluating it.\n\n        Warning:\n            This is probably bad, and should be replaced when possible.\n\n        Args:\n            type: Python type as a string, i.e. \"&lt;class 'int'&gt;\"\n\n        Returns:\n            Type as an object.\n    \"\"\"\n    # returns python type from &lt;class 'x'&gt; string\n    return eval(type.split(\"'\")[0])\n</code></pre>"},{"location":"reference-docs/compiler/compiler/spirv/#titan.compiler.spirv.SPIRVAssembler.add_const_if_nonexistant","title":"<code>add_const_if_nonexistant(const, negative_val=False)</code>","text":"<p>Add a constant, only if it does not exist already.</p> <p>Checks if the constant exists, and if not, the method will generate the corresponding SPIR-V.</p> <p>Parameters:</p> Name Type Description Default <code>const</code> <code>ConstContext</code> <p>Constant to add.</p> required <code>negative_val</code> <code>bool</code> <p>Flag the value as a negative constant. Needed to generate the SPIR-V assembly correctly.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>constant_id</code> <code>str</code> <p>Returns the ID of the constant.</p> Source code in <code>titan/compiler/spirv.py</code> <pre><code>def add_const_if_nonexistant(self, const: ConstContext, negative_val: bool = False) -&gt; str:\n    \"\"\" Add a constant, only if it does not exist already.\n\n        Checks if the constant exists, and if not, the method will generate the corresponding SPIR-V.\n\n        Args:\n            const: Constant to add.\n            negative_val: Flag the value as a negative constant. Needed to generate the SPIR-V assembly correctly.\n\n        Returns:\n            constant_id: Returns the ID of the constant.\n    \"\"\"\n\n    if const not in self.declared_constants:\n        txt_val = str(const.value)\n        const_str = f\"const_{DataType(const.primative_type).name.lower()}\"\n\n        # format the string properly\n        if negative_val:\n            txt_val = txt_val.replace(\"-\", \"n\")\n\n        if const.primative_type is float:\n            txt_val = txt_val.replace(\".\", \"_\")\n\n        const_str += f\"_{txt_val}\"\n\n        self.declared_constants[const] = const_str\n\n        # check if type has been declared\n        self.add_type_if_nonexistant(self.TypeContext(DataType(const.primative_type)),f\"%type_{(DataType(const.primative_type).name).lower()}\")\n\n        self.add_line(\n            self.Sections.VAR_CONST_DECLARATIONS,\n            f\"%{const_str} = OpConstant {self.get_primative_type_id(DataType(const.primative_type))} {const.value}\"\n        )\n\n        return const_str\n    else:\n        return self.declared_constants[const]\n</code></pre>"},{"location":"reference-docs/compiler/compiler/spirv/#titan.compiler.spirv.SPIRVAssembler.add_intermediate_id","title":"<code>add_intermediate_id(intermediate_id, type, is_accessing_array=False)</code>","text":"<p>Add an intermediate ID.</p> <p>Parameters:</p> Name Type Description Default <code>intermediate_id</code> <code>str</code> <p>Intermediate ID to add.</p> required <code>type</code> <code>DataType</code> <p>Type to associate with the intermediate ID.</p> required Source code in <code>titan/compiler/spirv.py</code> <pre><code>def add_intermediate_id(self, intermediate_id: str, type: DataType, is_accessing_array: bool = False):\n    \"\"\" Add an intermediate ID.\n\n        Args:\n            intermediate_id: Intermediate ID to add.\n            type: Type to associate with the intermediate ID.\n    \"\"\"\n    # self.intermediate_ids[intermediate_id] = type\n    self.intermediate_ids[intermediate_id] = self.IntermediateIDContext(type, is_accessing_array)\n</code></pre>"},{"location":"reference-docs/compiler/compiler/spirv/#titan.compiler.spirv.SPIRVAssembler.add_line","title":"<code>add_line(section, line)</code>","text":"<p>Add a generated line of SPIR-V to a given section.</p> <p>Parameters:</p> Name Type Description Default <code>section</code> <code>Sections</code> <p>The section to append the line to.</p> required <code>line</code> <code>str</code> <p>The line to add.</p> required Source code in <code>titan/compiler/spirv.py</code> <pre><code>def add_line(self, section: Sections, line: str):\n    \"\"\" Add a generated line of SPIR-V to a given section.\n\n        Args:\n            section (titan.compiler.spirv.SPIRVAssembler.Sections): The section to append the line to.\n            line (str): The line to add.\n    \"\"\"\n    self.generated_spirv[section.name].append(line)\n</code></pre>"},{"location":"reference-docs/compiler/compiler/spirv/#titan.compiler.spirv.SPIRVAssembler.add_output_symbol","title":"<code>add_output_symbol(symbol)</code>","text":"<p>Add an output symbol to the output_port_list.</p> <p>Also increments an internal counter.</p> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>The symbol to be added.</p> required Source code in <code>titan/compiler/spirv.py</code> <pre><code>def add_output_symbol(self, symbol: str):\n    \"\"\" Add an output symbol to the output_port_list.\n\n        Also increments an internal counter.\n\n        Args:\n            symbol (str): The symbol to be added. \n    \"\"\"\n    # HACK: what is the point of this line\n    self.output_port_list[symbol] = self.output_type_list[self._internal_output_port_list_counter]\n    self._internal_output_port_list_counter += 1\n</code></pre>"},{"location":"reference-docs/compiler/compiler/spirv/#titan.compiler.spirv.SPIRVAssembler.add_output_type","title":"<code>add_output_type(type)</code>","text":"<p>Add an output type.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <p>The type to add.</p> required Warning <p>This function may be removed in the future. It's not clear what specifically it is adding. Could possibly cause issues with the rest of the program.</p> Source code in <code>titan/compiler/spirv.py</code> <pre><code>def add_output_type(self, type):\n    \"\"\" Add an output type.\n\n        Args:\n            type: The type to add.\n\n        Warning:\n            This function may be removed in the future. It's not clear _what_ specifically it is adding.\n            Could possibly cause issues with the rest of the program.\n    \"\"\"\n    self.output_type_list.append(type)\n</code></pre>"},{"location":"reference-docs/compiler/compiler/spirv/#titan.compiler.spirv.SPIRVAssembler.add_symbol_if_nonexistant","title":"<code>add_symbol_if_nonexistant(symbol, type, location, array_type_id=None, array_size=0)</code>","text":"<p>Add a symbol, only if it does not already exist.</p> <p>Method first checks if symbol exists or not. If not, it'll generate the corresponding SPIR-V lines depending on its type and location, and increment the <code>location_id</code> counter.</p> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>Name of the symbol to add.</p> required <code>type</code> <p>Python type of the symbol.</p> required <code>location</code> <code>StorageType</code> <p>Given storage location for the symbol. Required for SPIR-V.</p> required <code>array_type_id</code> <code>str</code> <p>SPIR-V ID (with %) of the array type.</p> <code>None</code> <code>array_size</code> <code>int</code> <p>Total elements present in the array.</p> <code>0</code> <p>Returns:</p> Name Type Description <code>symbol_added</code> <code>bool</code> <p>True if symbol has been added, else False.</p> Source code in <code>titan/compiler/spirv.py</code> <pre><code>def add_symbol_if_nonexistant(self, symbol: str, type, location: StorageType, array_type_id: str = None, array_size: int = 0) -&gt; bool:\n    \"\"\" Add a symbol, only if it does not already exist.\n\n        Method first checks if symbol exists or not. If not, it'll generate the corresponding SPIR-V\n        lines depending on its type and location, and increment the ``location_id`` counter.\n\n        Args:\n            symbol: Name of the symbol to add.\n            type: Python type of the symbol.\n            location: Given storage location for the symbol. Required for SPIR-V.\n            array_type_id: SPIR-V ID (with %) of the array type.\n            array_size: Total elements present in the array.\n\n        Returns:\n            symbol_added: True if symbol has been added, else False.\n    \"\"\"\n\n    symbol_is_array = False if array_type_id is None else True\n\n    if symbol not in self.symbol_info:\n        logging.debug(f\"updating symbol: {symbol}\")\n\n        # keeping track of which id is used to create the symbol\n        final_type_id = None\n\n        self.add_line(self.Sections.DEBUG_STATEMENTS, f\"OpName %{symbol} \\\"{symbol}\\\"\")\n\n        # if i/o\n        if location is (StorageType.IN or StorageType.OUT):\n            # add location (glsl specific i think)\n            self.add_line(self.Sections.ANNOTATIONS, f\"OpDecorate %{symbol} Location {self.location_id}\")\n\n            if location is StorageType.IN:\n                # more glsl specific stuff\n                self.add_line(self.Sections.ANNOTATIONS, f\"OpDecorate %{symbol} Flat\")\n\n                # input variable pointer type\n                ptr_id = self.add_type_if_nonexistant(\n                    self.TypeContext(primative_type=DataType(type), storage_type=StorageType.IN, is_pointer=True),\n                    f\"%pointer_input_{DataType(type).name.lower()}\"\n                )\n\n\n                if symbol_is_array:\n                    self.add_line(self.Sections.VAR_CONST_DECLARATIONS, f\"%{symbol} = OpVariable {array_type_id} Input\")\n                    final_type_id = array_type_id\n\n                else:\n                    self.add_line(self.Sections.VAR_CONST_DECLARATIONS, f\"%{symbol} = OpVariable {ptr_id} Input\")\n                    final_type_id = ptr_id\n\n\n            elif location is StorageType.OUT:\n\n                ptr_id = self.add_type_if_nonexistant(\n                    self.TypeContext(primative_type=DataType(type), storage_type=StorageType.IN, is_pointer=True),\n                    f\"%pointer_output_{DataType(type).name.lower()}\"\n                )\n\n                if symbol_is_array:\n                    self.add_line(self.Sections.VAR_CONST_DECLARATIONS, f\"%{symbol} = OpVariable {array_type_id} Output\")\n                    final_type_id = array_type_id\n                else:\n                    self.add_line(self.Sections.VAR_CONST_DECLARATIONS, f\"%{symbol} = OpVariable {ptr_id} Output\")\n                    final_type_id = ptr_id\n\n\n\n        elif location is StorageType.FUNCTION_VAR:\n\n            ptr_id = self.add_type_if_nonexistant(\n                self.TypeContext(\n                    primative_type=DataType(type), storage_type=StorageType.FUNCTION_VAR, is_pointer=True),\n                f\"%pointer_funcvar_{DataType(type).name.lower()}\"\n            )\n\n            if symbol_is_array:\n                self.add_line(self.Sections.FUNCTIONS, f\"%{symbol} = OpVariable {array_type_id} Function\")\n                final_type_id = array_type_id\n            else:\n                self.add_line(self.Sections.FUNCTIONS, f\"%{symbol} = OpVariable {ptr_id} Function\")\n                final_type_id = ptr_id\n\n        # increment by 1 for regular variables, or by element count for arrays\n        self.location_id += 1 if not symbol_is_array else array_size\n\n        symbol_info = self.SymbolInfo(DataType(type), location, is_array=symbol_is_array, declared_type_id=final_type_id)\n        logging.debug(f\"{symbol} : {symbol_info}\")\n        self.symbol_info[symbol] = symbol_info\n        return True\n    else:\n        return False\n</code></pre>"},{"location":"reference-docs/compiler/compiler/spirv/#titan.compiler.spirv.SPIRVAssembler.add_temp_load_op_if_needed","title":"<code>add_temp_load_op_if_needed(id, type_id)</code>","text":"<p>Add an OpLoad into a temporary ID if the symbol already exists, or if dealing with arrays (TODO).</p> <p>Required by SPIR-V syntax.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>ID of the symbol.</p> required <code>type_id</code> <code>str</code> <p>ID of the type of the symbol.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Returns the new temporary ID if the symbol exists, otherwise returns provided symbol_id.</p> Source code in <code>titan/compiler/spirv.py</code> <pre><code>def add_temp_load_op_if_needed(self, id: str, type_id: str) -&gt; str:\n    \"\"\" Add an OpLoad into a temporary ID if the symbol already exists, or if dealing with arrays (TODO).\n\n        Required by SPIR-V syntax.\n\n        Args:\n            id: ID of the symbol.\n            type_id: ID of the type of the symbol.\n\n        Returns:\n            Returns the new temporary ID if the symbol exists, otherwise returns provided symbol_id.\n    \"\"\"\n\n    # if id is a symbol\n    if self.symbol_exists(id):\n        temp_id = f\"temp_{id}\"\n\n        self.add_line(\n            self.Sections.FUNCTIONS,\n            f\"%{temp_id} = OpLoad {type_id} %{id}\"\n        )\n\n        return temp_id\n\n    # if constant -- no need to load anything, can use directly\n    elif self.const_exists(id.strip(\"%\")):\n        return id\n\n    # not a symbol, and not an intermediate id..? what does this line do?\n    elif (not self.symbol_exists(id) and not self.intermediate_id_exists(id)) or self.get_is_intermediate_id_accessing_array(id):\n\n        temp_id = self.get_new_intermediate_id()\n        self.add_line(\n            self.Sections.FUNCTIONS,\n            f\"%{temp_id} = OpLoad {type_id} %{id}\"\n        )\n\n        return temp_id\n    else:\n        return id\n</code></pre>"},{"location":"reference-docs/compiler/compiler/spirv/#titan.compiler.spirv.SPIRVAssembler.add_type","title":"<code>add_type(type, id)</code>","text":"<p>Add a type, using <code>TypeContext</code>. Used to generate SPIR-V types.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>TypeContext</code> <p>Type, as <code>TypeContext</code> to add.</p> required <code>id</code> <code>str</code> <p>ID to associate with the type.</p> required Source code in <code>titan/compiler/spirv.py</code> <pre><code>def add_type(self, type: TypeContext, id: str):\n    \"\"\" Add a type, using ``TypeContext``. Used to generate SPIR-V types.\n\n        Args:\n            type: Type, as ``TypeContext`` to add.\n            id: ID to associate with the type.\n    \"\"\"\n    self.declared_types[type] = id\n</code></pre>"},{"location":"reference-docs/compiler/compiler/spirv/#titan.compiler.spirv.SPIRVAssembler.add_type_if_nonexistant","title":"<code>add_type_if_nonexistant(type_ctx, id)</code>","text":"<p>Add a type, only if it does not already exist.</p> <p>If the type does not already exist, the function will generate the corresponding SPIR-V for it.</p> Currently supported types: <ul> <li>OpTypeVoid</li> <li>OpTypeInteger (32-bit signed)</li> <li>OpTypeBool</li> <li>OpTypeFloat (32-bit float)</li> <li>OpTypeArray</li> </ul> <p>Parameters:</p> Name Type Description Default <code>type</code> <p>The type to add.</p> required <code>id</code> <code>str</code> <p>The ID to associate with the type.</p> required <p>Returns:</p> Name Type Description <code>type_id</code> <code>str</code> <p>The ID of the type.</p> Source code in <code>titan/compiler/spirv.py</code> <pre><code>def add_type_if_nonexistant(self, type_ctx: TypeContext, id: str) -&gt; str:\n    \"\"\" Add a type, only if it does not already exist.\n\n        If the type does not already exist, the function will generate the corresponding SPIR-V for it.\n\n        Note: Currently supported types:\n            - OpTypeVoid\n            - OpTypeInteger (32-bit signed)\n            - OpTypeBool\n            - OpTypeFloat (32-bit float)\n            - OpTypeArray\n\n        Args:\n            type: The type to add.\n            id: The ID to associate with the type.\n\n        Returns:\n            type_id: The ID of the type.\n    \"\"\"\n    if not self.type_exists(type_ctx):\n\n        # TODO: remove\n        self.add_type(type_ctx, id)\n\n        spirv_txt = f\"{id} = \"\n\n        if type_ctx.is_function_typedef:\n            prim_tid = self.get_primative_type_id(type_ctx.primative_type)\n            spirv_txt += f\"OpTypeFunction {prim_tid}\"\n\n        elif type_ctx.is_pointer and not type_ctx.is_array:\n            prim_tid = self.get_primative_type_id(type_ctx.primative_type)\n            storage_type_str = type_ctx.storage_type.value\n\n            assert type(storage_type_str) is str, f\"did not get text for the storage type: {type_ctx.storage_type}\"\n\n            spirv_txt += f\"OpTypePointer {storage_type_str} {prim_tid}\"\n\n        elif type_ctx.is_array and not type_ctx.is_pointer:\n            prim_tid = self.get_primative_type_id(type_ctx.primative_type)\n\n            # get id for array size, may need to add if doesnt exist\n            const_size_id = self.add_const_if_nonexistant(\n                self.ConstContext(\n                    type_ctx.primative_type,\n                    type_ctx.array_size\n                )\n            )\n\n            spirv_txt += f\"OpTypeArray {prim_tid} %{const_size_id}\"\n\n        elif type_ctx.is_array and type_ctx.is_pointer:\n\n            # get base array id for this specific pointer\n            array_type_id = self.get_type_id(\n                self.TypeContext(\n                    primative_type=type_ctx.primative_type,\n                    storage_type=StorageType.NONE, # the base array id does not have storage type\n                    is_pointer=False,\n                    is_array=True,\n                    array_size=type_ctx.array_size\n                )\n            )\n\n            spirv_txt += f\"OpTypePointer {type_ctx.storage_type.value} {array_type_id}\"\n\n        # this should mean we're working with the primative types\n        elif (not type_ctx.is_constant) and (not type_ctx.is_pointer) and (not type_ctx.is_function_typedef):\n\n            match type_ctx.primative_type:\n                case DataType.VOID:\n                    spirv_txt += f\"OpTypeVoid\"\n                case DataType.INTEGER:\n                    spirv_txt += f\"OpTypeInt 32 1\"\n                case DataType.BOOLEAN:\n                    spirv_txt += f\"OpTypeBool\"\n                case DataType.FLOAT:\n                    spirv_txt += f\"OpTypeFloat 32\"\n                case _:\n                    logging.exception(f\"type text for {type_ctx} not implemented yet (did you wrap the type in a DataType() call to enum?)\", exc_info=False)\n                    raise Exception(f\"type text for {type_ctx} not implemented yet (did you wrap the type in a DataType() call to enum?)\")\n        else:\n            logging.exception(f\"unable to generate spirv text for type {id} -&gt; {type_ctx}\", exc_info=False)\n            raise Exception(f\"unable to generate spirv text for type {id} -&gt; {type_ctx}\")\n\n\n        if not type_ctx.is_array:\n            self.add_line(\n                self.Sections.TYPES,\n                spirv_txt\n        )\n        else:\n            self.add_line(\n                self.Sections.ARRAY_TYPES,\n                spirv_txt\n            )\n\n        return id\n    else:\n        return self.get_type_id(type_ctx)\n</code></pre>"},{"location":"reference-docs/compiler/compiler/spirv/#titan.compiler.spirv.SPIRVAssembler.compile","title":"<code>compile()</code>","text":"<p>Begin the AST/Python -&gt; SPIR-V compilation.</p> Source code in <code>titan/compiler/spirv.py</code> <pre><code>def compile(self):\n    \"\"\" Begin the AST/Python -&gt; SPIR-V compilation. \"\"\"\n    self.visit(self._tree)\n\n    if not self._disable_debug:\n        self.dump()\n</code></pre>"},{"location":"reference-docs/compiler/compiler/spirv/#titan.compiler.spirv.SPIRVAssembler.const_exists","title":"<code>const_exists(const)</code>","text":"<p>Check if a constant exists.</p> <p>Parameters:</p> Name Type Description Default <code>const</code> <code>ConstContext | str</code> <p>Constant to check, either with ConstContext or ID (without '%')</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if constant exists, else False.</p> Source code in <code>titan/compiler/spirv.py</code> <pre><code>def const_exists(self, const: ConstContext | str) -&gt; bool:\n    \"\"\" Check if a constant exists.\n\n        Args:\n            const: Constant to check, either with ConstContext or ID (without '%')\n\n        Returns:\n            True if constant exists, else False.\n    \"\"\"\n    return const in self.declared_constants.keys() or const in self.declared_constants.values()\n</code></pre>"},{"location":"reference-docs/compiler/compiler/spirv/#titan.compiler.spirv.SPIRVAssembler.create_file_as_string","title":"<code>create_file_as_string()</code>","text":"<p>Transforms the generated SPIR-V assembly from lists into a very long string.</p> TODO <p>Rework this function. Must be a better way to do this.</p> <p>Returns:</p> Type Description <code>str</code> <p>String containing all of the generated SPIR-V assembly code.</p> Source code in <code>titan/compiler/spirv.py</code> <pre><code>def create_file_as_string(self) -&gt; str:\n    \"\"\" Transforms the generated SPIR-V assembly from lists into a very long string.\n\n        TODO:\n            Rework this function. Must be a better way to do this.\n\n        Returns:\n            String containing all of the generated SPIR-V assembly code.\n    \"\"\"\n    fake_file = \"\"\n\n    # key=section, value=list of lines\n    for lines in self.generated_spirv.values():\n        for line in lines:\n            fake_file += f\"{line}\\n\"\n\n    return fake_file\n</code></pre>"},{"location":"reference-docs/compiler/compiler/spirv/#titan.compiler.spirv.SPIRVAssembler.get_const_id","title":"<code>get_const_id(value, type)</code>","text":"<p>Get the ID of a constant.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <p>A constant value.</p> required <code>type</code> <p>The type of the constant value.</p> required <p>Returns:</p> Type Description <code>str</code> <p>ID of the constant.</p> Source code in <code>titan/compiler/spirv.py</code> <pre><code>def get_const_id(self, value, type) -&gt; str:\n    \"\"\" Get the ID of a constant.\n\n        Args:\n            value: A constant value.\n            type: The type of the constant value.\n\n        Returns:\n            ID of the constant.\n    \"\"\"\n    temp_c_ctx = self.ConstContext(type, value)\n    return self.declared_constants[temp_c_ctx]\n</code></pre>"},{"location":"reference-docs/compiler/compiler/spirv/#titan.compiler.spirv.SPIRVAssembler.get_const_id_with_ctx","title":"<code>get_const_id_with_ctx(context)</code>","text":"<p>Get the ID of a constant, using <code>ConstContext</code>.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>ConstContext</code> <p>Context of the constant.</p> required <p>Returns:</p> Type Description <code>str</code> <p>ID of the constant.</p> Source code in <code>titan/compiler/spirv.py</code> <pre><code>def get_const_id_with_ctx(self, context: ConstContext) -&gt; str:\n    \"\"\" Get the ID of a constant, using ``ConstContext``.\n\n        Args:\n            context: Context of the constant.\n\n        Returns:\n            ID of the constant.\n    \"\"\"\n    return self.declared_constants[context]\n</code></pre>"},{"location":"reference-docs/compiler/compiler/spirv/#titan.compiler.spirv.SPIRVAssembler.get_is_intermediate_id_accessing_array","title":"<code>get_is_intermediate_id_accessing_array(intermediate_id)</code>","text":"<p>Returns true/false if intermediate ID is accessing an array.</p> <p>Parameters:</p> Name Type Description Default <code>intermediate_id</code> <code>str</code> <p>Intermediate ID to check</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if accessing array, else False</p> Source code in <code>titan/compiler/spirv.py</code> <pre><code>def get_is_intermediate_id_accessing_array(self, intermediate_id: str) -&gt; bool:\n    \"\"\" Returns true/false if intermediate ID is accessing an array.\n\n        Args:\n            intermediate_id: Intermediate ID to check\n\n        Returns:\n            True if accessing array, else False\n    \"\"\"\n    return self.intermediate_ids[intermediate_id].is_accessing_array\n</code></pre>"},{"location":"reference-docs/compiler/compiler/spirv/#titan.compiler.spirv.SPIRVAssembler.get_new_intermediate_id","title":"<code>get_new_intermediate_id()</code>","text":"<p>Gets intermediate ID string and increments the counter.</p> <p>Returns:</p> Type Description <code>str</code> <p>A (hopefully) unused intermediate ID value.</p> Source code in <code>titan/compiler/spirv.py</code> <pre><code>def get_new_intermediate_id(self) -&gt; str:\n    \"\"\" Gets intermediate ID string and increments the counter.\n\n        Returns:\n            A (hopefully) unused intermediate ID value.\n    \"\"\"\n    new_id = f\"titan_id_{self.intermediate_id}\"\n    self.intermediate_id += 1\n    return new_id\n</code></pre>"},{"location":"reference-docs/compiler/compiler/spirv/#titan.compiler.spirv.SPIRVAssembler.get_primative_type_id","title":"<code>get_primative_type_id(type)</code>","text":"<p>Get the ID of a primative type.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>DataType</code> <p>Primative type to get ID for.</p> required Return <p>ID of the type.</p> Source code in <code>titan/compiler/spirv.py</code> <pre><code>def get_primative_type_id(self, type: DataType) -&gt; str:\n    \"\"\" Get the ID of a primative type.\n\n        Args:\n            type: Primative type to get ID for.\n\n        Return:\n            ID of the type.\n    \"\"\"\n\n    # TODO: convoluted? may be a better way to do this\n    # can this just be replaced with indexing with the primative type instead of going through TypeContext?\n    return self.declared_types[\n        self.TypeContext(DataType(type))\n    ]\n</code></pre>"},{"location":"reference-docs/compiler/compiler/spirv/#titan.compiler.spirv.SPIRVAssembler.get_symbol_info","title":"<code>get_symbol_info(symbol_id)</code>","text":"<p>Get information regarding a given symbol via ID.</p> <p>Parameters:</p> Name Type Description Default <code>symbol_id</code> <code>str</code> <p>ID of the symbol to check.</p> required <p>Returns:</p> Type Description <code>SymbolInfo</code> <p>Symbol information tuple.</p> Source code in <code>titan/compiler/spirv.py</code> <pre><code>def get_symbol_info(self, symbol_id: str) -&gt; SymbolInfo:\n    \"\"\" Get information regarding a given symbol via ID.\n\n        Args:\n            symbol_id: ID of the symbol to check.\n\n        Returns:\n            Symbol information tuple.\n    \"\"\"\n    return self.symbol_info[symbol_id]\n</code></pre>"},{"location":"reference-docs/compiler/compiler/spirv/#titan.compiler.spirv.SPIRVAssembler.get_symbol_type","title":"<code>get_symbol_type(symbol)</code>","text":"<p>Get symbol type, using symbol ID.</p> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>Symbol ID</p> required <p>Returns:</p> Type Description <code>DataType</code> <p>Primative type of symbol.</p> Source code in <code>titan/compiler/spirv.py</code> <pre><code>def get_symbol_type(self, symbol: str) -&gt; DataType:\n    \"\"\" Get symbol type, using symbol ID.\n\n        Args:\n            symbol: Symbol ID\n\n        Returns:\n            Primative type of symbol.\n    \"\"\"\n    # symbol_info[symbol] -&gt; info (SymbolInfo).type\n    return self.symbol_info[symbol].type\n</code></pre>"},{"location":"reference-docs/compiler/compiler/spirv/#titan.compiler.spirv.SPIRVAssembler.get_type_id","title":"<code>get_type_id(type)</code>","text":"<p>Get the ID of a given type.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>TypeContext</code> <p>Type to get ID for.</p> required <p>Returns:</p> Type Description <code>str</code> <p>ID of the type.</p> Source code in <code>titan/compiler/spirv.py</code> <pre><code>def get_type_id(self, type: TypeContext) -&gt; str:\n    \"\"\" Get the ID of a given type.\n\n        Args:\n            type: Type to get ID for.\n\n        Returns:\n            ID of the type.\n    \"\"\"\n    # FIXME: the type hint declared for this attribute does not use TypeContext as the key.\n    #        declared_type_hint suggests to use common.type.DataType as the key!\n    return self.declared_types[type]\n</code></pre>"},{"location":"reference-docs/compiler/compiler/spirv/#titan.compiler.spirv.SPIRVAssembler.get_type_of_intermediate_id","title":"<code>get_type_of_intermediate_id(intermediate_id)</code>","text":"<p>Returns the type of an intermediate ID, not the type ID.</p> <p>Parameters:</p> Name Type Description Default <code>intermediate_id</code> <code>str</code> <p>Intermediate ID to return the type of.</p> required <p>Returns:</p> Type Description <code>DataType</code> <p>Primative intermediate ID type.</p> Source code in <code>titan/compiler/spirv.py</code> <pre><code>def get_type_of_intermediate_id(self, intermediate_id: str) -&gt; DataType:\n    \"\"\" Returns the type of an intermediate ID, _not_ the type ID.\n\n        Args:\n            intermediate_id: Intermediate ID to return the type of.\n\n        Returns:\n            Primative intermediate ID type.\n    \"\"\"\n    return self.intermediate_ids[intermediate_id].type\n</code></pre>"},{"location":"reference-docs/compiler/compiler/spirv/#titan.compiler.spirv.SPIRVAssembler.intermediate_id_exists","title":"<code>intermediate_id_exists(intermediate_id)</code>","text":"<p>Check if an intermediate ID already exists.</p> <p>Parameters:</p> Name Type Description Default <code>intermediate_id</code> <code>str</code> <p>Intermediate ID to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if intermediate ID already exists, else False.</p> Source code in <code>titan/compiler/spirv.py</code> <pre><code>def intermediate_id_exists(self, intermediate_id: str) -&gt; bool:\n    \"\"\" Check if an intermediate ID already exists.\n\n        Args:\n            intermediate_id: Intermediate ID to check.\n\n        Returns:\n            True if intermediate ID already exists, else False.\n    \"\"\"\n    return True if intermediate_id in self.intermediate_ids else False\n</code></pre>"},{"location":"reference-docs/compiler/compiler/spirv/#titan.compiler.spirv.SPIRVAssembler.output_to_file","title":"<code>output_to_file(filename)</code>","text":"<p>Write generated SPIR-V assembly into a real file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Name of the file to write to. <code>.spvasm</code> will be automatically appended.</p> required Source code in <code>titan/compiler/spirv.py</code> <pre><code>def output_to_file(self, filename:str):\n    \"\"\" Write generated SPIR-V assembly into a real file.\n\n        Args:\n            filename: Name of the file to write to. ``.spvasm`` will be automatically appended.\n    \"\"\"\n    ff = self.create_file_as_string()\n\n    with open(f\"{filename}.spvasm\", \"w\") as f:\n        for line in ff:\n            f.write(line)\n</code></pre>"},{"location":"reference-docs/compiler/compiler/spirv/#titan.compiler.spirv.SPIRVAssembler.symbol_exists","title":"<code>symbol_exists(symbol)</code>","text":"<p>Check if a symbol exists.</p> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>Given symbol name, without the SPIR-V \"%\" prefix.</p> required <p>Returns:</p> Name Type Description <code>symbol_exists</code> <code>bool</code> <p>True if symbol exists, else False.</p> Source code in <code>titan/compiler/spirv.py</code> <pre><code>def symbol_exists(self, symbol: str) -&gt; bool:\n    \"\"\" Check if a symbol exists.\n\n        Args:\n            symbol (str): Given symbol name, without the SPIR-V \"%\" prefix.\n\n        Returns:\n            symbol_exists: True if symbol exists, else False.\n    \"\"\"\n    return True if symbol in self.symbol_info else False\n</code></pre>"},{"location":"reference-docs/compiler/compiler/spirv/#titan.compiler.spirv.SPIRVAssembler.type_exists","title":"<code>type_exists(type)</code>","text":"<p>Check if a type already exists, using a <code>TypeContext</code>.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>TypeContext</code> <p>Type to check if it exists.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if type exists, else False.</p> Source code in <code>titan/compiler/spirv.py</code> <pre><code>def type_exists(self, type: TypeContext) -&gt; bool:\n    \"\"\" Check if a type already exists, using a ``TypeContext``.\n\n        Args:\n            type: Type to check if it exists.\n\n        Returns:\n            True if type exists, else False.\n    \"\"\"\n    return True if type in self.declared_types else False\n</code></pre>"},{"location":"reference-docs/compiler/compiler/spirv/#titan.compiler.spirv.SPIRVAssembler.update_symbol_info","title":"<code>update_symbol_info(symbol_id, info)</code>","text":"<p>Update the information currently stored of a given symbol.</p> Warning <p>Simply overwrites an existing entry. The symbol must have been declared before using this, otherwise you may run into a KeyError exception.</p> <p>Parameters:</p> Name Type Description Default <code>symbol_id</code> <code>str</code> <p>ID of the symbol to update.</p> required <code>info</code> <code>SymbolInfo</code> <p>Tuple to update the information with.</p> required Source code in <code>titan/compiler/spirv.py</code> <pre><code>def update_symbol_info(self, symbol_id: str, info: SymbolInfo):\n    \"\"\" Update the information currently stored of a given symbol.\n\n        Warning:\n            Simply overwrites an existing entry. The symbol _must_ have been declared before using this,\n            otherwise you may run into a KeyError exception.\n\n        Args:\n            symbol_id: ID of the symbol to update.\n            info: Tuple to update the information with.\n    \"\"\"\n    self.symbol_info[symbol_id] = info\n</code></pre>"},{"location":"reference-docs/compiler/compiler/spirv/#titan.compiler.spirv.SPIRVAssembler.visit_Assign","title":"<code>visit_Assign(node)</code>","text":"<p>Function called when performing an assignment.</p> <p>Attempts to evaluate the assignment, by calling <code>_eval_line()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <p>The current node.</p> required Source code in <code>titan/compiler/spirv.py</code> <pre><code>def visit_Assign(self, node):\n    \"\"\" Function called when performing an assignment.\n\n        Attempts to evaluate the assignment, by calling ``_eval_line()``.\n\n        Args:\n            node: The current node.\n    \"\"\"\n\n    assert len(node.targets) == 1, \"multiple assignments not supported\"\n\n\n    # special case: array initialisation\n    # will deal within _eval_line() instead\n    if isinstance(node.value, ast.Call):\n        eval_id, eval_ctx = self._eval_line_wrap(node)\n        return\n\n    # special case: array indexing, if the target is array then we are doing \"x[1] = b\"\n    elif isinstance(node.targets[0], ast.Subscript):\n        index_id, index_ctx = self._eval_line(node.value)\n        access_id, access_ctx = self._eval_line(node.targets[0])\n        value_temp_load_id = self.add_temp_load_op_if_needed(index_id, index_ctx.primative_type)\n\n        self.add_line(\n            self.Sections.FUNCTIONS,\n            f\"OpStore %{access_id.strip('%')} %{value_temp_load_id.strip('%')}\"\n        )\n        return        \n\n    # if node.value contains a subscript object, it means we're doing something like \"b = x[1]\"\n    elif isinstance(node.value, ast.Subscript):\n\n        # evaluate array access\n        access_id, access_ctx = self._eval_line(node.value)\n\n        # make symbol if non-existant\n        self.add_symbol_if_nonexistant(node.targets[0].id, access_ctx.primative_type.value, StorageType.FUNCTION_VAR)\n\n        # add opload for array\n        temp_load_id = self.add_temp_load_op_if_needed(access_id, self.get_primative_type_id(self.get_type_of_intermediate_id(access_id)))\n\n        # store\n        self.add_line(\n            self.Sections.FUNCTIONS,\n            f\"OpStore %{node.targets[0].id} %{temp_load_id}\"\n        )\n\n        return\n\n    # for all other things\n    else:\n        try:\n            eval_id, eval_ctx = self._eval_line_wrap(node)\n        except Exception as e:\n            logging.exception(f\"failed to unpack evaluation, usually a sign that the operation was not handled properly... exception: {e}\")\n            raise Exception(f\"failed to unpack evaluation, usually a sign that the operation was not handled properly... exception: {e}\")\n\n        type_class = self._extract_type(eval_ctx)\n        assert not type_class is None, f\"evaluated type as None for variable with no type declaration\"\n\n        t_id = self.add_type_if_nonexistant(\n            self.TypeContext(\n                DataType(type_class)\n            ),\n            f\"%type_{DataType(type_class).name.lower()}\"\n        )\n\n        self.add_symbol_if_nonexistant(node.targets[0].id, type_class, StorageType.FUNCTION_VAR)\n\n        self.add_line(\n            self.Sections.FUNCTIONS,\n            f\"OpStore %{node.targets[0].id} %{eval_id.strip('%')}\"\n        )\n</code></pre>"},{"location":"reference-docs/compiler/compiler/spirv/#titan.compiler.spirv.SPIRVAssembler.visit_FunctionDef","title":"<code>visit_FunctionDef(node)</code>","text":"<p>Function called when visiting a function definition.</p> <p>Method evaluates function signature, generates appropriate SPIR-V types and visits the body nodes.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <p>The current node.</p> required Source code in <code>titan/compiler/spirv.py</code> <pre><code>def visit_FunctionDef(self, node):\n    \"\"\" Function called when visiting a function definition.\n\n        Method evaluates function signature, generates appropriate SPIR-V types and visits the body nodes.\n\n        Args:\n            node: The current node.\n\n    \"\"\"\n\n    _debug_returns = None\n    if hasattr(node, \"returns\"):\n        _debug_returns = f\"returns type {node.returns.id}\"\n    else:\n        _debug_returns = \"does not hint at returning anything\"\n        logging.info(f\"'{node.name}' does not have a return type hint - is this expected?\")\n\n    logging.debug(f\"function {node.name} {_debug_returns}\")\n    self._latest_function_name = node.name\n\n    self.add_line(self.Sections.DEBUG_STATEMENTS, f\"OpName %{node.name} \\\"{node.name}\\\"\")\n\n    void_ctx = self.TypeContext(DataType.VOID, StorageType.NONE)\n    t_void_id = self.add_type_if_nonexistant(void_ctx, f\"%type_void\")\n\n    # make spirv function def for OpTypeFunction\n    fn_ctx = self.TypeContext(DataType.VOID, StorageType.NONE, False, False, True)\n    t_fn_void_id = self.add_type_if_nonexistant(fn_ctx, f\"%type_function_{(DataType.VOID.name).lower()}\")\n\n    # mark start of function\n    self.add_line(self.Sections.FUNCTIONS, f\"%{node.name} = OpFunction {t_void_id} None {t_fn_void_id}\")\n    self.add_line(self.Sections.FUNCTIONS, f\"%label_{node.name} = OpLabel\")\n\n    # process decorators - this should handle array defs etc\n    # TODO: can this be replaced with a specialised function, as to free up the visit_Call function?\n    for decorator in node.decorator_list:\n        self.visit_Call(decorator)\n\n    # iterate through each arg, make type &amp; pointer type\n    for args in node.args.args:\n\n        # args.arg == argument name\n        # args.annotation == type annotation\n        #   - seems like python types are recognised as \"ast.Name\"\n\n        if type(args.annotation) is ast.Name:\n            # potentially bad\n            type_class = eval(args.annotation.id)\n\n            # TODO: update true/false for arrays?\n            # check if generic type exists\n            t_ctx = self.TypeContext(DataType(type_class), StorageType.NONE, False, False)\n            self.add_type_if_nonexistant(t_ctx, f\"%type_{(DataType(type_class).name).lower()}\")\n\n            # dealing with args means that a special type needs to be made\n            ptr_t_ctx = self.TypeContext(DataType(type_class), StorageType.IN, False, True)\n            self.add_type_if_nonexistant(ptr_t_ctx, f\"%pointer_input_{(DataType(type_class).name).lower()}\")\n\n            self.add_symbol_if_nonexistant(args.arg, type_class, StorageType.IN)\n\n        elif type(args.annotation) is ast.Attribute:\n            logging.debug(f\"not doing anything for arg {args.arg} as annotation was ast.Attribute\")\n            pass\n        else:\n            raise Exception(f\"unexpected type of annotation for argument: {type(args.annotation)}\")\n\n\n    # TODO: needs implementation for multiple returns\n    # handle returns (types for now)\n    assert not isinstance(node.returns, ast.Call), \"multiple returns/function calls not handled\"\n\n    if isinstance(node.returns, ast.Name):\n        type_class = self._get_python_type_from_string(node.returns.id)\n        self.add_output_type(type_class)\n\n        type_as_string = DataType(type_class).name.lower()\n\n        # add primative type if it does not exist\n        self.add_type_if_nonexistant(self.TypeContext(DataType(type_class)), f\"%type_{type_as_string}\")\n\n        # add pointer type if it does not exist\n        self.add_type_if_nonexistant(self.TypeContext(DataType(type_class), StorageType.OUT, False, True, False),\n            f\"%pointer_output_{type_as_string}\"\n        )\n\n\n\n    logging.debug(f\"body start {node.name}\")\n    super().generic_visit(node)\n    logging.debug(f\"body end {node.name}\")\n\n    # spirv boilerplate for end of function\n    self.add_line(\n        self.Sections.FUNCTIONS,\n        f\"OpReturn\"\n    )\n\n    self.add_line(\n        self.Sections.FUNCTIONS,\n        f\"OpFunctionEnd\"\n    )\n</code></pre>"},{"location":"reference-docs/compiler/compiler/spirv/#titan.compiler.spirv.SPIRVAssembler.visit_Import","title":"<code>visit_Import(node)</code>","text":"<p>Function called when visiting import nodes.</p> <p>Updates an internal attribute to keep track of imported modules, as names only. Does not actually evaluate if module exists, only intended to work with Numpy for arrays.</p> Source code in <code>titan/compiler/spirv.py</code> <pre><code>def visit_Import(self, node):\n    \"\"\" Function called when visiting import nodes.\n\n        Updates an internal attribute to keep track of imported modules, as names only.\n        Does not actually evaluate if module exists, only intended to work with Numpy for arrays.\n    \"\"\"\n\n    for imported_module in node.names:\n        # cant use hasattr() because it will always return true, check against None instead\n        if imported_module.asname is None:\n            # no alternative name given\n            self._import_mapping[imported_module.name] = imported_module.name\n        else:\n            self._import_mapping[imported_module.name] = imported_module.asname\n</code></pre>"},{"location":"reference-docs/compiler/compiler/spirv/#titan.compiler.spirv.SPIRVAssembler.visit_ImportFrom","title":"<code>visit_ImportFrom(node)</code>","text":"<p>Function called when visiting import from 'x' nodes. </p> <p>Does not implement any functionality.</p> Source code in <code>titan/compiler/spirv.py</code> <pre><code>def visit_ImportFrom(self, node):\n    \"\"\" Function called when visiting import from 'x' nodes. \n\n        Does not implement any functionality.\n    \"\"\"\n    logging.error(f\"importing directly from modules not supported: {ast.dump(node)}\")\n</code></pre>"},{"location":"reference-docs/compiler/compiler/spirv/#titan.compiler.spirv.SPIRVAssembler.visit_Module","title":"<code>visit_Module(node)</code>","text":"<p>Function called when visiting a module.</p> <p>Method first sets the entry point to the name of the function inside the module. If there are multiple, the name can either be specified via a command line option, or if present, a function named \"step\" will be the entry point. If there is only one function, then it will be used instead, regardless of the name.</p> <p>Some initial boilerplate SPIR-V code is added at this stage.</p> <p>After that the method will visit all of the functions in the body, generating the equivalent SPIR-V assembly. The ports (I/O or parameters/returns) are handled after the function visits.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <p>The current node.</p> required <p>Attributes:</p> Name Type Description <code>_module_contains_step_function</code> <code>bool</code> <p>A check if the module contains a function specifically called \"step\".</p> Source code in <code>titan/compiler/spirv.py</code> <pre><code>def visit_Module(self, node):\n    \"\"\" Function called when visiting a module.\n\n        Method first sets the entry point to the name of the function inside the module. If there are multiple,\n        the name can either be specified via a command line option, or if present, a function named \"step\" will\n        be the entry point. If there is only one function, then it will be used instead, regardless of the name.\n\n        Some initial boilerplate SPIR-V code is added at this stage.\n\n        After that the method will visit all of the functions in the body, generating the equivalent SPIR-V assembly.\n        The ports (I/O or parameters/returns) are handled after the function visits.\n\n        Args:\n            node: The current node.\n\n        Attributes:\n            _module_contains_step_function (bool): A check if the module contains a function specifically called \"step\".\n\n    \"\"\"\n    _module_contains_step_function = False\n\n    logging.debug(f\"found {len(node.body)} functions\")\n\n    for i in range(len(node.body)):\n        # skip over imports in module definition\n        if node is ast.Import or ast.ImportFrom:\n            continue\n\n        if node.body[i].name == \"step\":\n            _module_contains_step_function = True\n            self.entry_point = \"step\"\n\n    if not _module_contains_step_function:\n        total_func_defs = 0\n        func_def_pos = 0\n\n        for i in range(len(node.body)):\n            operation = node.body[i]\n\n            if type(operation) is ast.FunctionDef:\n                total_func_defs += 1\n                func_def_pos = i\n\n\n        assert total_func_defs != 0, \"no function defintions found\"\n        assert not total_func_defs &gt; 1, \"multiple function defintions found, please specify top\"\n\n        self.entry_point = node.body[func_def_pos].name\n        logging.debug(f\"setting entry point as '{self.entry_point}'\")\n\n    # spirv boilerplate\n    self.add_line(\n        self.Sections.CAPABILITY_AND_EXTENSION,\n        f\"OpCapability Shader\"\n    )\n\n    self.add_line(\n        self.Sections.CAPABILITY_AND_EXTENSION,\n        f\"OpMemoryModel Logical GLSL450\"\n    )\n\n    # this makes the assumption that the module body only contains FunctionDef nodes\n    # may not always be the case...\n    # TODO: rename 'fn', misleading\n    for fn in node.body:\n\n        # deal with imports\n        if type(fn) is ast.Import:\n            self.visit_Import(fn)\n            continue\n        elif type(fn) is ast.ImportFrom:\n            self.visit_ImportFrom(fn)\n            continue\n\n        # ignore everything else\n        elif type(fn) is not ast.FunctionDef:\n            logging.debug(f\"not processing {type(fn)}\")\n            continue\n\n        # evaluate function signature\n        self.visit_FunctionDef(fn)\n\n        # if the function is our entry point, we want to capture its params\n        # TODO: this will fail if the entry point is not the first function in the list,\n        #       since the lists/dicts will contain previous function entries, messing with the names\n        if fn.name == self.entry_point:\n            # take contents of input/output ports and convert them into ids\n            ports_str = \"\"\n\n            for symbol, symbol_ctx in self.symbol_info.items():\n                if (symbol_ctx.location is StorageType.IN) or (symbol_ctx.location is StorageType.OUT):\n                    ports_str += f\"%{symbol} \"\n\n            self.add_line(\n                self.Sections.ENTRY_AND_EXEC_MODES,\n                f\"OpEntryPoint Fragment %{fn.name} \\\"{fn.name}\\\" {ports_str}\"\n            )\n\n        self.add_line(\n            self.Sections.ENTRY_AND_EXEC_MODES,\n            f\"OpExecutionMode %{fn.name} OriginUpperLeft\"\n        )\n\n        logging.debug(f\"exit function {fn.name}\")\n</code></pre>"},{"location":"reference-docs/compiler/compiler/spirv/#titan.compiler.spirv.SPIRVAssembler.visit_Return","title":"<code>visit_Return(node)</code>","text":"<p>Handle return nodes.</p> Source code in <code>titan/compiler/spirv.py</code> <pre><code>def visit_Return(self, node):\n    \"\"\" Handle return nodes. \"\"\"\n\n    # TODO: add calls to _eval_line to get proper id for node\n    # if isinstance(node.value, ast.Constant):\n        # logging.debug(f\"returning const: {node.value.value}\")\n        # logging.exception(f\"TODO: return constant value\", exc_info=False)\n        # raise Exception(\"TODO: return constant value\")\n\n    assert not isinstance(node.value, ast.Constant), f\"TODO: return constant values (returning {node.value.value})\"\n    assert not isinstance(node.value, ast.BinOp), f\"TODO: return binops\"\n\n    if isinstance(node.value, ast.Name):\n        logging.debug(f\"returning name: {node.value.id}\")\n        id, ctx = self._eval_line(node.value)\n\n        if self.symbol_exists(id):\n            s_info = self.get_symbol_info(id)\n\n            # because the symbol exists, and isn't a temporary one\n            # and if we're returning it, it must be an output\n            if s_info.location == StorageType.FUNCTION_VAR:\n                s_info_new = self.SymbolInfo(\n                    ctx, StorageType.OUT, s_info.is_array\n                )\n\n                self.update_symbol_info(id, s_info_new)\n\n                ptr_t_id = self.get_type_id(\n                    self.TypeContext(\n                        ctx, StorageType.FUNCTION_VAR, False, True\n                    )\n                )\n\n                ptr_t_out_id = self.get_type_id(\n                    self.TypeContext(\n                        ctx, StorageType.OUT, False, True\n                    )\n                )\n\n                self.add_line(\n                    self.Sections.VAR_CONST_DECLARATIONS,\n                    f\"%{id} = OpVariable {ptr_t_out_id} Output\"\n                )\n\n                str_to_match = f\"%{id} = OpVariable {ptr_t_id} Function\"\n\n                # TODO: implement better method\n                # bruteforce remove reference of symbol declaration in FUNCTIONS section\n                i = 0\n                for line in self.generated_spirv[self.Sections.FUNCTIONS.name]:\n                    if line == str_to_match:\n                        self.generated_spirv[self.Sections.FUNCTIONS.name].pop(i)\n                        break\n                    i += 1\n\n    elif isinstance(node.value, ast.IfExp):\n\n        #        v node.value.body.id\n        # return c if a &gt; 0 else 0 \n        #             ^ ^        ^ node.value.orelse\n        #             | | node.value.test.{ops|comparators}\n        #             | node.value.test.left\n\n        # TODO: need to get ID somehow, move the IfExp function to something else accessible and call it directly?\n        super().generic_visit(node)\n\n        # because this is direct return, we have to make a temp symbol into which we can return (in spirv terms)\n        # we have to also add it to the symbols list, making sure that it has the same type as the indicated return type\n        # and that it doesn't clash with the return type\n\n        out_str_id = f\"titan_return_id_{self.return_id}\"\n        self.return_id += 1\n        # TODO: make sure names don't clash?\n        self.add_symbol_if_nonexistant(\n            out_str_id, self.output_type_list[0], StorageType.OUT\n        )\n\n        self.add_output_symbol(out_str_id)\n\n        # store titan_id_x into the newly created return variable\n        self.add_line(\n            self.Sections.FUNCTIONS,\n            f\"OpStore %{out_str_id} %{self._latest_ifexp_selector_id}\"\n        )\n\n        ptr_t_out_ctx = self.TypeContext(\n            DataType(self.output_type_list[0]), StorageType.OUT,\n            False, True, False\n        )\n\n        ptr_t_out_id = self.get_type_id(ptr_t_out_ctx)\n\n        self.add_line(\n            self.Sections.VAR_CONST_DECLARATIONS,\n            f\"%{out_str_id} = OpVariable %{ptr_t_out_id.strip('%')} Output\"\n        )\n\n\n        # print(f\"return {node.value.body.id} if {node.value.test.left.id} {node.value.test.ops[0].__class__.__name__} {self._extract_content(node.value.test.comparators[0])} else {self._extract_content(node.value.orelse)}\")\n    # elif isinstance(node.value, ast.BinOp):\n        # logging.exception(f\"TODO implement handling binops for return values\", exc_info=False)\n        # raise Exception(\"TODO implement handling binops for return values\")\n\n        # id, ctx = self._eval_line(node.value)\n        # print(f\"returning binop val ({id})\")\n\n        # if self.symbol_exists(id):\n        #     print(\"this was a symbol\")\n        # elif self.intermediate_id_exists(id):\n        #     print(\"this was a temp id\")\n        # else:\n        #     raise Exception(\"idk\")\n\n    else:\n        logging.exception(f\"unhandled type during return node evaluation {node}\", exc_info=False)\n        raise Exception(f\"unhandled type during return node evaluation {node} {type(node)}\")\n</code></pre>"},{"location":"reference-docs/compiler/compiler/verilog/","title":"Documentation for <code>verilog.py</code>","text":""},{"location":"reference-docs/compiler/compiler/verilog/#titan.compiler.verilog.VerilogAssember","title":"<code>VerilogAssember</code>","text":"<p>VerilogAssembler class. </p> <p>Contains functionality to create Verilog from Nodes.</p> Source code in <code>titan/compiler/verilog.py</code> <pre><code>class VerilogAssember():\n    \"\"\" VerilogAssembler class. \n\n        Contains functionality to create Verilog from Nodes.\n    \"\"\"\n\n    class FunctionLocation(NamedTuple):\n        \"\"\" Tuple to track the start and end position of a SPIR-V function.\n\n            Attributes:\n                start_position: Start position of function.\n                end_position: End position of function.\n                name: Function name.\n        \"\"\"\n        start_position: int\n        end_position: int\n        name: str\n\n    class Sections(Enum):\n        \"\"\" Enum describing different sections of the verilog file.\"\"\"\n        MODULE_AND_PORTS = auto()\n        INTERNAL = auto()\n        ALWAYS_BLOCK = auto()\n        ASSIGNMENTS = auto()\n\n    spirv_assembly = None\n    parsed_spirv = None\n    node_assembler: NodeAssembler = None\n\n    generated_verilog_text = {\n        Sections.MODULE_AND_PORTS: [],\n        Sections.INTERNAL: [],\n        Sections.ALWAYS_BLOCK: [],\n        Sections.ASSIGNMENTS: []\n    }\n\n\n    def __init__(self, spirv_assembly: str):\n        \"\"\" \n            Params:\n                spirv_assembly: SPIR-V assembly code as one large string.\n        \"\"\"\n        self.spirv_assembly = spirv_assembly\n        self._parse_spirv_pyparsing()\n\n    def _parse_spirv_pyparsing(self):\n        \"\"\" Parses SPIR-V using ``pyparsing``.\n\n            Works on the internal ``spirv_assembly`` attribute of the class, assigning the \n            value to ``parsed_spirv``.\n        \"\"\"\n        with io.StringIO(self.spirv_assembly) as fake_file:\n            self.parsed_spirv = TitanSPIRVGrammar.spirv_body.parse_file(fake_file)\n\n    def _get_spirv_function_locations(self, parsed_spirv) -&gt; List:\n        \"\"\" Determine location of SPIR-V functions from parsed SPIR-V assembly. \"\"\"\n        # TODO: figure out how to improve this\n        line_no = fn_start = 0\n        fn_name = \"\"\n        fn_locations = []\n        _marked_start = False\n        _marked_end = False\n        for line in parsed_spirv:\n            match line.opcode:\n                case \"Function\":\n                    fn_start = line_no\n                    fn_name = line.id[1:] # slice to remove '%'\n                    _marked_start = True\n                case \"FunctionEnd\":\n                    fn_locations.append(self.FunctionLocation(fn_start, line_no, fn_name))\n                    fn_name = \"\"\n                    _marked_end = True      \n\n            line_no += 1\n\n        assert _marked_start and _marked_end, f\"failed to determine start/end point of function: start? {_marked_start}, end? {_marked_end}\"\n        return fn_locations\n\n    def append_code(self, section: Sections, code: str):\n        \"\"\" Add code.\n\n            Args:\n                section: Section to add to.\n                code: Code to add.\n        \"\"\"\n        self.generated_verilog_text[section].append(code)\n\n    def write_to_file(self, filename: str):\n        \"\"\" Write verilog content out to a file.\n\n            Args:\n                filename: Name of file to create/overwrite.\n        \"\"\"\n        logging.info(f\"Writing RTL to file ({filename}.sv)\")\n        with open(f\"{filename}.sv\", \"w\") as f:\n            for section, list_of_lines in self.generated_verilog_text.items():\n                logging.debug(f\"Writing section {section.name}\")\n\n                for line in list_of_lines:\n                    f.write(line)\n                    f.write(f\"\\n\")\n\n    def compile(self, filename: str, gen_yosys_script: bool = False):\n        \"\"\" Function to begin compiling. Calls other relevant functions. \n\n            Args:\n                filename: Name of file to create/overwrite when writing Verilog.\n                gen_yosys_script: Create a Yosys script to visualise the verilog.\n        \"\"\"\n        node_assember = self.compile_nodes()\n        self.node_assembler = node_assember\n\n        self.node_assembler.generate_dot_graph()\n        self.node_assembler.clean_graph()\n        self.node_assembler.generate_dot_graph(\"clean_nodes\")\n\n\n        self.compile_text()\n        self.write_to_file(filename)\n\n        if gen_yosys_script:\n            with open(f\"yosys_script_{filename}.txt\", \"w+\") as f:\n                f.write(f\"read_verilog -sv {filename}.sv; proc; opt; memory; opt; show;\")\n\n    def compile_nodes(self):\n        \"\"\" Generate Nodes from parsed SPIR-V assembly. \n\n            Note:\n                Verilog and SystemVerilog are used interchangeably.\n        \"\"\"\n\n        spirv_fn_name = None\n        spirv_fn_locations = self._get_spirv_function_locations(self.parsed_spirv)\n\n        node_assembler = NodeAssembler()\n\n        # deal with headers\n        logging.debug(f\"processing SPIR-V headers...\")\n        for line_no in range(0, spirv_fn_locations[0].start_position):\n            line = self.parsed_spirv[line_no]\n            logging.debug(line)\n\n            match line.opcode:\n                case \"EntryPoint\":\n                    spirv_fn_name = line.opcode_args[2][1:-1]\n                    node_assembler.create_module(spirv_fn_name)\n\n                case \"Constant\":\n                    if line.id not in node_assembler.declared_symbols:\n                        node_assembler.declared_symbols.append(line.id)\n\n                    if node_assembler.type_exists_in_module(spirv_fn_name, line.opcode_args[0]):\n\n                        node_type_context = node_assembler.get_type_context_from_module(spirv_fn_name, line.opcode_args[0])\n\n                        assert node_type_context.type != (DataType.VOID or DataType.NONE), f\"got invalid type for constant\"\n\n                        node_assembler.add_body_node_to_module(\n                            spirv_fn_name,\n                            Node(\n                                NodeContext(\n                                    line_no=line_no, id=line.id, type_id=line.opcode_args[0],\n                                    operation=Operation.GLOBAL_CONST_DECLARATION,\n\n                                    # this calls the correct conversion function to have literal value stored in data, instead of string\n                                    # node_type_context.type.value == Datatype.INTEGER/FLOAT/BOOL.value == int()/float()/bool()\n                                    data=[node_type_context.type.value(line.opcode_args[1])]\n                                )\n                            )\n                        )\n                    else:\n                        logging.exception(f\"{TitanErrors.NON_EXISTENT_SYMBOL.value} ({line.opcode_args[0]} on line {line_no}) ({TitanErrors.NON_EXISTENT_SYMBOL.name})\", exc_info=False)\n                        raise Exception(f\"{TitanErrors.NON_EXISTENT_SYMBOL.value} ({line.opcode_args[0]} on line {line_no})\", TitanErrors.NON_EXISTENT_SYMBOL.name)\n\n                case \"Variable\":\n                    if line.id not in node_assembler.declared_symbols:\n                        node_assembler.declared_symbols.append(line.id)\n\n                    match line.opcode_args[1]:\n                        case \"Output\":\n                            node_assembler.add_output_to_module(spirv_fn_name, line.id[1:])\n                            node_assembler.add_body_node_to_module(\n                                spirv_fn_name,\n                                Node(\n                                    NodeContext(\n                                        line_no=line_no, id=line.id,\n                                        type_id=node_assembler.get_primative_type_id_from_id(spirv_fn_name, line.opcode_args[0]),\n                                        operation=Operation.GLOBAL_VAR_DECLARATION,\n                                        data=[Operation.FUNCTION_OUT_VAR_PARAM]\n                                    )\n                                )\n                            )\n\n                        case \"Input\":\n                            node_assembler.add_input_to_module(spirv_fn_name, line.id[1:])\n                            node_assembler.add_body_node_to_module(\n                                spirv_fn_name,\n                                Node(\n                                    NodeContext(\n                                        line_no=line_no, id=line.id,\n                                        type_id=node_assembler.get_primative_type_id_from_id(spirv_fn_name, line.opcode_args[0]),\n                                        operation=Operation.GLOBAL_VAR_DECLARATION,\n                                        data=[Operation.FUNCTION_IN_VAR_PARAM]\n                                    )\n                                )\n                            )\n\n                case \"TypePointer\":\n                    node_assembler.add_type_context_to_module(\n                        spirv_fn_name,\n                        line.id,\n                        NodeTypeContext(\n                            type=node_assembler.get_datatype_from_id(spirv_fn_name, line.opcode_args[1]), # returns types.DataType\n                            is_pointer=True, alias=line.opcode_args[1]\n                        )\n                    )\n\n                case \"TypeInt\":\n                    node_assembler.add_type_context_to_module(\n                        spirv_fn_name, line.id,\n                        NodeTypeContext(\n                            type=DataType.INTEGER, data=line.opcode_args.as_list()\n                        )\n                    )\n\n                case \"TypeFloat\":\n                    # TODO\n                    logging.exception(f\"{TitanErrors.NOT_IMPLEMENTED.value} TypeFloat ({TitanErrors.NOT_IMPLEMENTED.name})\", exc_info=False)\n                    raise Exception(f\"{TitanErrors.NOT_IMPLEMENTED.value} TypeFloat\", TitanErrors.NOT_IMPLEMENTED.name)\n\n                case \"TypeBool\":\n                    node_assembler.add_type_context_to_module(\n                        spirv_fn_name, line.id,\n                        NodeTypeContext(type=DataType.BOOLEAN)\n                    )\n\n                case \"TypeArray\":\n                    node_assembler.add_type_context_to_module(\n                        spirv_fn_name, line.id,\n                        NodeTypeContext(\n                            type=node_assembler.get_datatype_from_id(spirv_fn_name, line.opcode_args[0]),\n                            is_array=True, array_dimension_id=line.opcode_args[1]\n                        )\n                    )\n\n                # dont do anything for these\n                case \"TypeVoid\": pass\n                case \"TypeFunction\": pass\n                case \"Capability\": pass\n                case \"MemoryModel\": pass\n                case \"ExecutionMode\": pass\n                case \"Name\": pass\n                case \"Decorate\": pass\n\n                case _:\n                    raise Exception(f\"unhandled header opcode: {line.opcode}\")\n\n\n        logging.debug(f\"processing SPIR-V function(s)...\")\n        # handle body\n        #                            v total spirv functions\n        for counter in range(0, len(spirv_fn_locations)):\n            spirv_fn = spirv_fn_locations[counter]\n\n            for position in range(spirv_fn.start_position, spirv_fn.end_position+1):\n                line = self.parsed_spirv[position]\n                logging.debug(f\"{line}\")\n\n                match line.opcode:\n                    case \"Variable\":\n                        if line.id not in node_assembler.declared_symbols:\n                            node_assembler.declared_symbols.append(line.id)\n\n                        node_assembler.add_body_node_to_module(\n                            spirv_fn_name,\n                            Node(\n                                NodeContext(\n                                    line_no=position, id=line.id,\n                                    type_id=node_assembler.get_primative_type_id_from_id(spirv_fn_name, line.opcode_args[0]),\n                                    operation=Operation.VARIABLE_DECLARATION\n                                )\n                            )\n                        )\n\n                    case \"Store\":\n\n                        assert node_assembler.node_exists(spirv_fn_name, line.opcode_args[0]), f\"node does not exist: {line.opcode_args[0]}\"\n                        assert node_assembler.node_exists(spirv_fn_name, line.opcode_args[1]), f\"node does not exist: {line.opcode_args[1]}\"\n                        assert not node_assembler.is_symbol_an_input(spirv_fn_name, line.opcode_args[0]), f\"cannot assign value to input variable\"\n                        logging.debug(f\"'{line.opcode_args[1]}' is being stored in '{line.opcode_args[0]}'\")\n\n                        target_node = node_assembler.get_node(spirv_fn_name, line.opcode_args[0])\n                        value_node = node_assembler.get_node(spirv_fn_name, line.opcode_args[1])\n\n                        store_node_ctx = NodeContext(\n                            line_no=position, id=line.opcode_args[0], \n                            type_id=target_node.type_id, input_left=value_node, operation=Operation.STORE\n                        )\n\n                        node_assembler.add_body_node_to_module(spirv_fn_name, Node(store_node_ctx))\n\n\n\n                    case \"Load\":\n                        value_node = node_assembler.get_node(spirv_fn_name, line.opcode_args[1])\n\n                        operation = Operation.ARRAY_LOAD if value_node.operation is Operation.ARRAY_INDEX else Operation.LOAD\n\n                        node_assembler.add_body_node_to_module(\n                            spirv_fn_name,\n                            Node(\n                                NodeContext(\n                                    line_no=position, id=line.id, type_id=line.opcode_args[0], \n                                    input_left=value_node, operation=operation\n                                )\n                            )\n                        )\n\n                    case \"IAdd\":\n                        left_node, right_node = node_assembler.get_left_and_right_nodes(spirv_fn_name, line)\n\n                        node_assembler.add_body_node_to_module(\n                            spirv_fn_name,\n                            Node(\n                                NodeContext(\n                                    line_no=position, id=line.id, type_id=line.opcode_args[0],\n                                    input_left=left_node, input_right=right_node, operation=Operation.ADD\n                                )\n                            )\n                        )\n\n                    case \"ISub\":\n                        left_node, right_node = node_assembler.get_left_and_right_nodes(spirv_fn_name, line)\n\n                        node_assembler.add_body_node_to_module(\n                            spirv_fn_name,\n                            Node(\n                                NodeContext(\n                                    line_no=position, id=line.id, type_id=line.opcode_args[0],\n                                    input_left=left_node, input_right=right_node, operation=Operation.SUB\n                                )\n                            )\n                        )\n\n                    case \"IMul\":\n                        left_node, right_node = node_assembler.get_left_and_right_nodes(spirv_fn_name, line)\n\n                        node_assembler.add_body_node_to_module(\n                            spirv_fn_name,\n                            Node(\n                                NodeContext(\n                                    line_no=position, id=line.id, type_id=line.opcode_args[0],\n                                    input_left=left_node, input_right=right_node, operation=Operation.MULT\n                                )\n                            )\n                        )\n\n                    case \"SDiv\":\n                        left_node, right_node = node_assembler.get_left_and_right_nodes(spirv_fn_name, line)\n\n                        node_assembler.add_body_node_to_module(\n                            spirv_fn_name,\n                            Node(\n                                NodeContext(\n                                    line_no=position, id=line.id, type_id=line.opcode_args[0],\n                                    input_left=left_node, input_right=right_node, operation=Operation.DIV\n                                )\n                            )\n                        )\n\n                    case \"Select\":\n                        #                          0           1               2             3\n                        # %result_id = OpSelect %type_id %comparison_id %true_value_id %false_value_id\n                        left_node, right_node = node_assembler.get_left_and_right_nodes(spirv_fn_name, line, [2, 3])\n\n                        compare_node = node_assembler.get_node(spirv_fn_name, line.opcode_args[1])\n\n                        node_assembler.add_body_node_to_module(\n                            spirv_fn_name,\n                            Node(\n                                NodeContext(\n                                    line_no=position, id=line.id, type_id=line.opcode_args[0],\n                                    input_left=left_node, input_right=right_node, \n                                    operation=Operation.DECISION, \n                                    data=[compare_node], \n                                    is_comparison=True\n                                )\n                            )\n                        )\n\n                    case \"IEqual\" | \"FOrdEqual\":\n                        left_node, right_node = node_assembler.get_left_and_right_nodes(spirv_fn_name, line)\n\n                        node_assembler.add_body_node_to_module(\n                            spirv_fn_name,\n                            Node(\n                                NodeContext(\n                                    line_no=position, id=line.id, type_id=line.opcode_args[0],\n                                    input_left=left_node, input_right=right_node,\n                                    operation=Operation.EQUAL_TO\n                                )\n                            )\n                        )\n\n                    case \"INotEqual\" | \"FOrdNotEqual\":\n                        left_node, right_node = node_assembler.get_left_and_right_nodes(spirv_fn_name, line)\n\n                        node_assembler.add_body_node_to_module(\n                            spirv_fn_name,\n                            Node(\n                                NodeContext(\n                                    line_no=position, id=line.id, type_id=line.opcode_args[0],\n                                    input_left=left_node, input_right=right_node,\n                                    operation=Operation.NOT_EQUAL_TO\n                                )\n                            )\n                        )\n\n                    case \"SLessThan\" | \"FOrdLessThan\":\n                        left_node, right_node = node_assembler.get_left_and_right_nodes(spirv_fn_name, line)\n\n                        node_assembler.add_body_node_to_module(\n                            spirv_fn_name,\n                            Node(\n                                NodeContext(\n                                    line_no=position, id=line.id, type_id=line.opcode_args[0],\n                                    input_left=left_node, input_right=right_node,\n                                    operation=Operation.LESS_THAN\n                                )\n                            )\n                        )\n\n                    case \"SLessThanEqual\" | \"FOrdLessThanEqual\":\n                        left_node, right_node = node_assembler.get_left_and_right_nodes(spirv_fn_name, line)\n\n                        node_assembler.add_body_node_to_module(\n                            spirv_fn_name,\n                            Node(\n                                NodeContext(\n                                    line_no=position, id=line.id, type_id=line.opcode_args[0],\n                                    input_left=left_node, input_right=right_node,\n                                    operation=Operation.LESS_OR_EQ\n                                )\n                            )\n                        )\n\n                    case \"SGreaterThan\" | \"FOrdGreaterThan\":\n                        left_node, right_node = node_assembler.get_left_and_right_nodes(spirv_fn_name, line)\n\n                        node_assembler.add_body_node_to_module(\n                            spirv_fn_name,\n                            Node(\n                                NodeContext(\n                                    line_no=position, id=line.id, type_id=line.opcode_args[0],\n                                    input_left=left_node, input_right=right_node,\n                                    operation=Operation.GREATER_THAN\n                                )\n                            )\n                        )\n\n                    case \"SGreaterThanEqual\" | \"FOrdGreaterThanEqual\":\n                        left_node, right_node = node_assembler.get_left_and_right_nodes(spirv_fn_name, line)\n\n                        node_assembler.add_body_node_to_module(\n                            spirv_fn_name,\n                            Node(\n                                NodeContext(\n                                    line_no=position, id=line.id, type_id=line.opcode_args[0],\n                                    input_left=left_node, input_right=right_node,\n                                    operation=Operation.GREATER_OR_EQ\n                                )\n                            )\n                        )\n\n                    case \"ShiftLeftLogical\":\n                        # left_node = thing to shift\n                        # right_node = how much to shift by\n                        left_node, right_node = node_assembler.get_left_and_right_nodes(spirv_fn_name, line)\n\n                        node_assembler.add_body_node_to_module(\n                            spirv_fn_name,\n                            Node(\n                                NodeContext(\n                                    line_no=position, id=line.id, type_id=line.opcode_args[0],\n                                    input_left=left_node, input_right=right_node,\n                                    operation=Operation.SHIFT_LEFT\n                                )\n                            )\n                        )\n\n                    # NOTE: this might need to handle \"OpShiftRightArithmetic\"\n                    # NOTE? why does this case statement have the \"Op\" prefix but none of the others do?\n                    case \"ShiftRightLogical\":\n                        left_node, right_node = node_assembler.get_left_and_right_nodes(spirv_fn_name, line)\n\n                        node_assembler.add_body_node_to_module(\n                            spirv_fn_name,\n                            Node(\n                                NodeContext(\n                                    line_no=position, id=line.id, type_id=line.opcode_args[0],\n                                    input_left=left_node, input_right=right_node,\n                                    operation=Operation.SHIFT_RIGHT\n                                )\n                            )\n                        )\n\n                    case \"AccessChain\":\n                        array_node = node_assembler.get_node(spirv_fn_name, line.opcode_args[1])\n                        node_assembler.add_body_node_to_module(\n                            spirv_fn_name,\n                            Node(\n                                NodeContext(\n                                    line_no=position, id=line.id, type_id=line.opcode_args[0],\n                                    operation=Operation.ARRAY_INDEX, input_left=array_node,\n                                    array_id=line.opcode_args[1], array_index_id=line.opcode_args[2]\n                                )\n                            )\n                        )\n\n                    # dont do anything with these\n                    case \"Function\": pass\n                    case \"Label\": pass\n                    case \"Return\": pass\n                    case \"FunctionEnd\": pass\n\n                    case _:\n                        raise Exception(f\"unknown SPIR-V opcode: '{line.opcode}' -- {line}\")\n\n        return node_assembler\n\n    def compile_text(self):\n        \"\"\" Generate SystemVerilog source code based on Nodes. \"\"\"\n\n        def _get_correct_id(node: Node):\n            \"\"\" Determine the correct ID/value to return.\n\n                Needed because literal constant values need to be returned\n                instead of the ID for them.\n\n                Args:\n                    node: Node to determine ID for.\n\n                TODO:\n                    Rename the function to something that describes it better.\n            \"\"\"\n            if node.operation in Operation_Type.GENERIC_CONSTANT_DECLARATION:\n                return node.data[0]\n\n            # added for handling comparison node\n            if node.operation is Operation.STORE:\n                return node.input_left.spirv_id[1:]\n            else:\n                return node.spirv_id[1:]\n\n\n        self.append_code(\n            self.Sections.MODULE_AND_PORTS,\n            f\"// automatically generated, dont modify otherwise it might break =)\"\n        )\n\n\n        for module in self.node_assembler.content.keys():\n            self.append_code(self.Sections.MODULE_AND_PORTS, f\"module {module} (\")\n            self.append_code(self.Sections.MODULE_AND_PORTS, f\"\\tinput logic clock_i,\")\n            self.append_code(self.Sections.ALWAYS_BLOCK, f\"\\talways_ff @ (posedge clock_i) begin\")\n\n            module_data = self.node_assembler.content[module]\n            sorted_nodes = self.node_assembler._sort_body_nodes_by_tick(module)\n\n            for tick in range(len(sorted_nodes.keys())):\n                logging.debug(f\"tick {tick} has {len(sorted_nodes[tick])} nodes\")\n\n                io_length_tracker = 0\n\n                for node_index in range(len(sorted_nodes[tick])):\n                    node = sorted_nodes[tick][node_index]\n\n                    logging.debug(f\"node: {node.spirv_id} {node}\")\n\n                    match node.operation:\n\n                        case Operation.GLOBAL_VAR_DECLARATION:\n                            assert tick == 0, f\"variable declaration outside of tick 0\"\n\n                            type_ctx = self.node_assembler.get_type_context_from_module(module, node.type_id)\n                            width = int(type_ctx.data[0])\n\n                            ender = \"\\n);\" if io_length_tracker == (len(module_data.inputs) + len(module_data.outputs)) - 1 else \",\"\n\n                            match node.data[0]:\n                                case Operation.FUNCTION_IN_VAR_PARAM:\n                                    self.append_code(\n                                        self.Sections.MODULE_AND_PORTS,\n                                        f\"\\tinput logic [{width-1}:0] {node.spirv_id[1:]}{ender}\"\n                                    )\n\n                                case Operation.FUNCTION_OUT_VAR_PARAM:\n                                    self.append_code(\n                                        self.Sections.MODULE_AND_PORTS,\n                                        f\"\\toutput logic [{width-1}:0] {node.spirv_id[1:]}{ender}\"\n                                    )\n\n                            io_length_tracker += 1\n\n\n                        case Operation.VARIABLE_DECLARATION:\n                            node_type_id = self.node_assembler.get_primative_type_id_from_id(module, node.type_id)\n                            type_context = self.node_assembler.get_type_context_from_module(module, node_type_id)\n\n                            if type_context.is_array:\n                                # define array in sv\n                                array_shape_node = self.node_assembler.get_node(module, type_context.array_dimension_id)\n                                array_shape = array_shape_node.data[0]\n                                assert type(array_shape) is int, f\"unexpected type for array shape, expected int but got {type(array_shape)}. (only 1d arrays supported currently)\"\n\n                                assert array_shape &gt;= 1, f\"array shape must define array of 2 or more elements\"\n                                width = int(self.node_assembler.get_primative_type_context_from_datatype(module, type_context.type).data[0])\n\n                                self.append_code(self.Sections.INTERNAL, f\"\\tlogic [{width-1}:0] {node.spirv_id[1:]} [0:{array_shape-1}];\")\n\n                            else:\n                                logging.debug(f\"not generating logic/reg for {node.spirv_id[1:]}: {node}\")\n\n\n                        case Operation.STORE:\n                            if self.node_assembler.is_symbol_an_output(module, node.spirv_id[1:]):\n                                # if the node is a constant declaration, convert the value it stores into a string, otherwise just use the SPIR-V ID\n                                rhs_text = str(node.input_left.data[0]) if node.input_left.operation is Operation.GLOBAL_CONST_DECLARATION else node.input_left.spirv_id[1:]\n                                self.append_code(self.Sections.ASSIGNMENTS, f\"\\tassign {node.spirv_id[1:]} = {rhs_text};\")\n                            else:\n                                logging.debug(f\"not creating assign statement for {node.spirv_id}: {node}\")\n\n                        case _ if node.operation in Operation_Type.ARITHMETIC:\n                            if node.spirv_id not in self.node_assembler.declared_symbols:\n                                width = int(self.node_assembler.get_type_context_from_module(module, node.type_id).data[0])\n\n                                self.append_code(self.Sections.INTERNAL, f\"\\tlogic [{width-1}:0] {node.spirv_id[1:]};\")\n\n                            assert type(node.operation.value) is str, f\"didn't get a string for operator, is it set correctly? {node.operation}\"\n                            line = f\"\\t\\t{node.spirv_id[1:]} &lt;= {_get_correct_id(node.input_left)} {node.operation.value} {_get_correct_id(node.input_right)};\"\n\n                            self.append_code(self.Sections.ALWAYS_BLOCK, line)\n\n                        case _ if node.operation in Operation_Type.COMPARISON:\n                            defer_node_creation = False\n\n                            logging.debug(f\"checking 1 tick ahead..({tick} + 1 = {tick+1})\")\n                            for future_node in sorted_nodes[tick+1]:\n                                if defer_node_creation: break\n\n                                if future_node.operation == Operation.DECISION:\n                                    if future_node.data[0].spirv_id == node.spirv_id:\n                                        logging.debug(f\"found a reference\")\n                                        defer_node_creation = True\n                                    else:\n                                        logging.debug(\"no reference found\")\n\n                            logging.debug(\"stopped checking 1 tick ahead\")\n\n                            # TODO: better variable name\n                            if not defer_node_creation:\n                                self.append_code(self.Sections.INTERNAL, f\"\\tlogic {node.spirv_id[1:]};\")\n\n                                assert type(node.operation.value) is str, f\"didn't get a string for operator, is it set correctly? {node.operation}\"\n\n                                line = f\"\\t\\t{node.spirv_id[1:]} &lt;= {_get_correct_id(node.input_left)} {node.operation.value} {_get_correct_id(node.input_right)};\"\n                                self.append_code(self.Sections.ALWAYS_BLOCK, line)\n                            else:\n                                continue\n\n                        case Operation.DECISION:\n                            logging.debug(f\"in decision: {node}\")\n                            comparison_node = node.data[0]\n\n                            # comparison node holds the comparison operator, and the comparison itself\n                            # the paried decision node holds the expected results\n\n                            # so i.e. c = a &gt;= 10 ? 5 : 0 would require the comparison node to construct a &gt;= 10\n                            # and the paried decision node for the ? 5 : 0 section\n\n                            # we dont want to create a logic value for the comparison node because that can just be abstracted away\n                            # so instead we will create the logic value for the decision node\n\n                            width = int(self.node_assembler.get_type_context_from_module(module, node.type_id).data[0])\n\n                            self.append_code(self.Sections.INTERNAL, f\"\\tlogic [{width-1}:0] {node.spirv_id[1:]};\")\n\n                            comparison_symbol = comparison_node.operation.value\n                            assert type(comparison_node.operation.value) is str, f\"didn't get a string for operator, is it set correctly? {comparison_node.operation} {comparison_node.operation.value}\"\n\n                            # TODO: __get_correct_id(node) was returning the string representation of the node instead, why?\n                            line = f\"\\t\\t{node.spirv_id[1:]} &lt;= {_get_correct_id(comparison_node.input_left)} {comparison_symbol} {_get_correct_id(comparison_node.input_right)} ? {_get_correct_id(node.input_left)} : {_get_correct_id(node.input_right)};\"\n                            self.append_code(self.Sections.ALWAYS_BLOCK, line)\n\n                        case _ if node.operation in Operation_Type.BITWISE:\n                            width = int(self.node_assembler.get_type_context_from_module(module, node.type_id).data[0])\n\n                            self.append_code(self.Sections.INTERNAL, f\"\\tlogic [{width-1}:0] {node.spirv_id[1:]}\")\n\n                            line = f\"\\t\\t{_get_correct_id(node)} &lt;= {_get_correct_id(node.input_left)} {Operation(node.operation).value} {_get_correct_id(node.input_right)};\"\n                            self.append_code(self.Sections.ALWAYS_BLOCK, line)\n\n                        case Operation.GLOBAL_CONST_DECLARATION: pass # dont need to generate any text\n\n                        case Operation.ARRAY_INDEX:\n\n                            load_store_node = None\n\n                            # look through all nodes trying to find an associated load/store node\n                            # cant only peek one tick ahead because it may not be there \n                            #   -&gt; x[1] = 1 + 2 / b is two steps, so the load/store node is actually located at tick+2 not tick+1\n                            for i in range(tick, len(sorted_nodes)):\n                                for j in range(len(sorted_nodes[i])):\n                                    future_node = sorted_nodes[i][j]\n\n                                    logging.debug(f\"checking: {future_node}\")\n\n                                    if future_node.operation == Operation.ARRAY_LOAD:\n                                        if future_node.input_left.spirv_id == node.spirv_id:\n                                            logging.debug(f\"array load, id of left input matches current node: {future_node.input_left.spirv_id} == {node.spirv_id}\")\n                                            load_store_node = future_node\n                                            break\n\n                                    # NOTE: future_node.operation == (Operation.ARRAY_STORE or Operation.STORE) doesn't work?\n                                    elif future_node.operation in [Operation.ARRAY_STORE, Operation.STORE]:\n                                        if future_node.spirv_id == node.spirv_id:\n                                            logging.debug(f\"array store, id of store node matches current node: {future_node.spirv_id} == {node.spirv_id}\")\n                                            load_store_node = future_node\n                                            break\n\n\n                            assert load_store_node != None, f\"failed to find a corresponding array load/store node\"\n\n                            # generate sv text based whether node is load/store\n\n                            match load_store_node.operation:\n                                case Operation.ARRAY_LOAD:\n                                    assert not self.node_assembler.is_symbol_an_output(module, load_store_node.input_left.spirv_id), f\"cannot load value from output port\"\n\n                                    # TODO: get width for int type, hardcoded for now\n                                    self.append_code(self.Sections.INTERNAL, f\"\\tlogic [31:0] {load_store_node.spirv_id[1:]};\")\n\n                                    array_max_size = self.node_assembler.get_array_node_dimensions(module, node.array_id)\n                                    array_index = self.node_assembler.get_node(module, node.array_index_id).data[0]\n\n                                    # TODO: tuples\n                                    assert type(array_max_size) is int, f\"array_max_size should have been int but got {type(array_max_size)} instead\"\n                                    assert array_index &lt; array_max_size, f\"array_index was not less than array_max_size: {array_index} &lt; {array_max_size}\"\n\n                                    # assign in body\n                                    self.append_code(self.Sections.ALWAYS_BLOCK, f\"\\t\\t{load_store_node.spirv_id[1:]} &lt;= {node.array_id[1:]}[{array_index}];\")\n\n                                case _ if load_store_node.operation in [Operation.ARRAY_STORE, Operation.STORE]:\n                                    array_index = self.node_assembler.get_node(module, node.array_index_id).data[0]\n                                    array_max_size = self.node_assembler.get_array_node_dimensions(module, node.array_id)\n\n                                    # TODO: tuples (as above)\n                                    assert type(array_max_size) is int, f\"array_max_size should have been int but got {type(array_max_size)} instead\"\n\n                                    # will need to change comparison so that it works with tuples\n                                    assert array_index &lt; array_max_size, f\"array_index was not less than array_max_size: {array_index} &lt; {array_max_size}\"\n\n                                    self.append_code(self.Sections.ALWAYS_BLOCK, f\"\\t\\t{node.input_left.spirv_id[1:]}[{array_index}] &lt;= {load_store_node.input_left.spirv_id[1:]};\")\n\n                                case _:\n                                    raise Exception(f\"unexpected operation: {load_store_node.operation}\")\n\n                        case Operation.ARRAY_LOAD: pass\n\n                        case _:\n                            raise Exception(f\"unhandled node during systemverilog generation: {node}\")\n\n            self.append_code(self.Sections.ALWAYS_BLOCK, f\"\\tend\")\n            self.append_code(self.Sections.ASSIGNMENTS, \"endmodule\")\n</code></pre>"},{"location":"reference-docs/compiler/compiler/verilog/#titan.compiler.verilog.VerilogAssember.FunctionLocation","title":"<code>FunctionLocation</code>","text":"<p>             Bases: <code>NamedTuple</code></p> <p>Tuple to track the start and end position of a SPIR-V function.</p> <p>Attributes:</p> Name Type Description <code>start_position</code> <code>int</code> <p>Start position of function.</p> <code>end_position</code> <code>int</code> <p>End position of function.</p> <code>name</code> <code>str</code> <p>Function name.</p> Source code in <code>titan/compiler/verilog.py</code> <pre><code>class FunctionLocation(NamedTuple):\n    \"\"\" Tuple to track the start and end position of a SPIR-V function.\n\n        Attributes:\n            start_position: Start position of function.\n            end_position: End position of function.\n            name: Function name.\n    \"\"\"\n    start_position: int\n    end_position: int\n    name: str\n</code></pre>"},{"location":"reference-docs/compiler/compiler/verilog/#titan.compiler.verilog.VerilogAssember.Sections","title":"<code>Sections</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Enum describing different sections of the verilog file.</p> Source code in <code>titan/compiler/verilog.py</code> <pre><code>class Sections(Enum):\n    \"\"\" Enum describing different sections of the verilog file.\"\"\"\n    MODULE_AND_PORTS = auto()\n    INTERNAL = auto()\n    ALWAYS_BLOCK = auto()\n    ASSIGNMENTS = auto()\n</code></pre>"},{"location":"reference-docs/compiler/compiler/verilog/#titan.compiler.verilog.VerilogAssember.__init__","title":"<code>__init__(spirv_assembly)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>spirv_assembly</code> <code>str</code> <p>SPIR-V assembly code as one large string.</p> required Source code in <code>titan/compiler/verilog.py</code> <pre><code>def __init__(self, spirv_assembly: str):\n    \"\"\" \n        Params:\n            spirv_assembly: SPIR-V assembly code as one large string.\n    \"\"\"\n    self.spirv_assembly = spirv_assembly\n    self._parse_spirv_pyparsing()\n</code></pre>"},{"location":"reference-docs/compiler/compiler/verilog/#titan.compiler.verilog.VerilogAssember._get_spirv_function_locations","title":"<code>_get_spirv_function_locations(parsed_spirv)</code>","text":"<p>Determine location of SPIR-V functions from parsed SPIR-V assembly.</p> Source code in <code>titan/compiler/verilog.py</code> <pre><code>def _get_spirv_function_locations(self, parsed_spirv) -&gt; List:\n    \"\"\" Determine location of SPIR-V functions from parsed SPIR-V assembly. \"\"\"\n    # TODO: figure out how to improve this\n    line_no = fn_start = 0\n    fn_name = \"\"\n    fn_locations = []\n    _marked_start = False\n    _marked_end = False\n    for line in parsed_spirv:\n        match line.opcode:\n            case \"Function\":\n                fn_start = line_no\n                fn_name = line.id[1:] # slice to remove '%'\n                _marked_start = True\n            case \"FunctionEnd\":\n                fn_locations.append(self.FunctionLocation(fn_start, line_no, fn_name))\n                fn_name = \"\"\n                _marked_end = True      \n\n        line_no += 1\n\n    assert _marked_start and _marked_end, f\"failed to determine start/end point of function: start? {_marked_start}, end? {_marked_end}\"\n    return fn_locations\n</code></pre>"},{"location":"reference-docs/compiler/compiler/verilog/#titan.compiler.verilog.VerilogAssember._parse_spirv_pyparsing","title":"<code>_parse_spirv_pyparsing()</code>","text":"<p>Parses SPIR-V using <code>pyparsing</code>.</p> <p>Works on the internal <code>spirv_assembly</code> attribute of the class, assigning the  value to <code>parsed_spirv</code>.</p> Source code in <code>titan/compiler/verilog.py</code> <pre><code>def _parse_spirv_pyparsing(self):\n    \"\"\" Parses SPIR-V using ``pyparsing``.\n\n        Works on the internal ``spirv_assembly`` attribute of the class, assigning the \n        value to ``parsed_spirv``.\n    \"\"\"\n    with io.StringIO(self.spirv_assembly) as fake_file:\n        self.parsed_spirv = TitanSPIRVGrammar.spirv_body.parse_file(fake_file)\n</code></pre>"},{"location":"reference-docs/compiler/compiler/verilog/#titan.compiler.verilog.VerilogAssember.append_code","title":"<code>append_code(section, code)</code>","text":"<p>Add code.</p> <p>Parameters:</p> Name Type Description Default <code>section</code> <code>Sections</code> <p>Section to add to.</p> required <code>code</code> <code>str</code> <p>Code to add.</p> required Source code in <code>titan/compiler/verilog.py</code> <pre><code>def append_code(self, section: Sections, code: str):\n    \"\"\" Add code.\n\n        Args:\n            section: Section to add to.\n            code: Code to add.\n    \"\"\"\n    self.generated_verilog_text[section].append(code)\n</code></pre>"},{"location":"reference-docs/compiler/compiler/verilog/#titan.compiler.verilog.VerilogAssember.compile","title":"<code>compile(filename, gen_yosys_script=False)</code>","text":"<p>Function to begin compiling. Calls other relevant functions. </p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Name of file to create/overwrite when writing Verilog.</p> required <code>gen_yosys_script</code> <code>bool</code> <p>Create a Yosys script to visualise the verilog.</p> <code>False</code> Source code in <code>titan/compiler/verilog.py</code> <pre><code>def compile(self, filename: str, gen_yosys_script: bool = False):\n    \"\"\" Function to begin compiling. Calls other relevant functions. \n\n        Args:\n            filename: Name of file to create/overwrite when writing Verilog.\n            gen_yosys_script: Create a Yosys script to visualise the verilog.\n    \"\"\"\n    node_assember = self.compile_nodes()\n    self.node_assembler = node_assember\n\n    self.node_assembler.generate_dot_graph()\n    self.node_assembler.clean_graph()\n    self.node_assembler.generate_dot_graph(\"clean_nodes\")\n\n\n    self.compile_text()\n    self.write_to_file(filename)\n\n    if gen_yosys_script:\n        with open(f\"yosys_script_{filename}.txt\", \"w+\") as f:\n            f.write(f\"read_verilog -sv {filename}.sv; proc; opt; memory; opt; show;\")\n</code></pre>"},{"location":"reference-docs/compiler/compiler/verilog/#titan.compiler.verilog.VerilogAssember.compile_nodes","title":"<code>compile_nodes()</code>","text":"<p>Generate Nodes from parsed SPIR-V assembly. </p> Note <p>Verilog and SystemVerilog are used interchangeably.</p> Source code in <code>titan/compiler/verilog.py</code> <pre><code>def compile_nodes(self):\n    \"\"\" Generate Nodes from parsed SPIR-V assembly. \n\n        Note:\n            Verilog and SystemVerilog are used interchangeably.\n    \"\"\"\n\n    spirv_fn_name = None\n    spirv_fn_locations = self._get_spirv_function_locations(self.parsed_spirv)\n\n    node_assembler = NodeAssembler()\n\n    # deal with headers\n    logging.debug(f\"processing SPIR-V headers...\")\n    for line_no in range(0, spirv_fn_locations[0].start_position):\n        line = self.parsed_spirv[line_no]\n        logging.debug(line)\n\n        match line.opcode:\n            case \"EntryPoint\":\n                spirv_fn_name = line.opcode_args[2][1:-1]\n                node_assembler.create_module(spirv_fn_name)\n\n            case \"Constant\":\n                if line.id not in node_assembler.declared_symbols:\n                    node_assembler.declared_symbols.append(line.id)\n\n                if node_assembler.type_exists_in_module(spirv_fn_name, line.opcode_args[0]):\n\n                    node_type_context = node_assembler.get_type_context_from_module(spirv_fn_name, line.opcode_args[0])\n\n                    assert node_type_context.type != (DataType.VOID or DataType.NONE), f\"got invalid type for constant\"\n\n                    node_assembler.add_body_node_to_module(\n                        spirv_fn_name,\n                        Node(\n                            NodeContext(\n                                line_no=line_no, id=line.id, type_id=line.opcode_args[0],\n                                operation=Operation.GLOBAL_CONST_DECLARATION,\n\n                                # this calls the correct conversion function to have literal value stored in data, instead of string\n                                # node_type_context.type.value == Datatype.INTEGER/FLOAT/BOOL.value == int()/float()/bool()\n                                data=[node_type_context.type.value(line.opcode_args[1])]\n                            )\n                        )\n                    )\n                else:\n                    logging.exception(f\"{TitanErrors.NON_EXISTENT_SYMBOL.value} ({line.opcode_args[0]} on line {line_no}) ({TitanErrors.NON_EXISTENT_SYMBOL.name})\", exc_info=False)\n                    raise Exception(f\"{TitanErrors.NON_EXISTENT_SYMBOL.value} ({line.opcode_args[0]} on line {line_no})\", TitanErrors.NON_EXISTENT_SYMBOL.name)\n\n            case \"Variable\":\n                if line.id not in node_assembler.declared_symbols:\n                    node_assembler.declared_symbols.append(line.id)\n\n                match line.opcode_args[1]:\n                    case \"Output\":\n                        node_assembler.add_output_to_module(spirv_fn_name, line.id[1:])\n                        node_assembler.add_body_node_to_module(\n                            spirv_fn_name,\n                            Node(\n                                NodeContext(\n                                    line_no=line_no, id=line.id,\n                                    type_id=node_assembler.get_primative_type_id_from_id(spirv_fn_name, line.opcode_args[0]),\n                                    operation=Operation.GLOBAL_VAR_DECLARATION,\n                                    data=[Operation.FUNCTION_OUT_VAR_PARAM]\n                                )\n                            )\n                        )\n\n                    case \"Input\":\n                        node_assembler.add_input_to_module(spirv_fn_name, line.id[1:])\n                        node_assembler.add_body_node_to_module(\n                            spirv_fn_name,\n                            Node(\n                                NodeContext(\n                                    line_no=line_no, id=line.id,\n                                    type_id=node_assembler.get_primative_type_id_from_id(spirv_fn_name, line.opcode_args[0]),\n                                    operation=Operation.GLOBAL_VAR_DECLARATION,\n                                    data=[Operation.FUNCTION_IN_VAR_PARAM]\n                                )\n                            )\n                        )\n\n            case \"TypePointer\":\n                node_assembler.add_type_context_to_module(\n                    spirv_fn_name,\n                    line.id,\n                    NodeTypeContext(\n                        type=node_assembler.get_datatype_from_id(spirv_fn_name, line.opcode_args[1]), # returns types.DataType\n                        is_pointer=True, alias=line.opcode_args[1]\n                    )\n                )\n\n            case \"TypeInt\":\n                node_assembler.add_type_context_to_module(\n                    spirv_fn_name, line.id,\n                    NodeTypeContext(\n                        type=DataType.INTEGER, data=line.opcode_args.as_list()\n                    )\n                )\n\n            case \"TypeFloat\":\n                # TODO\n                logging.exception(f\"{TitanErrors.NOT_IMPLEMENTED.value} TypeFloat ({TitanErrors.NOT_IMPLEMENTED.name})\", exc_info=False)\n                raise Exception(f\"{TitanErrors.NOT_IMPLEMENTED.value} TypeFloat\", TitanErrors.NOT_IMPLEMENTED.name)\n\n            case \"TypeBool\":\n                node_assembler.add_type_context_to_module(\n                    spirv_fn_name, line.id,\n                    NodeTypeContext(type=DataType.BOOLEAN)\n                )\n\n            case \"TypeArray\":\n                node_assembler.add_type_context_to_module(\n                    spirv_fn_name, line.id,\n                    NodeTypeContext(\n                        type=node_assembler.get_datatype_from_id(spirv_fn_name, line.opcode_args[0]),\n                        is_array=True, array_dimension_id=line.opcode_args[1]\n                    )\n                )\n\n            # dont do anything for these\n            case \"TypeVoid\": pass\n            case \"TypeFunction\": pass\n            case \"Capability\": pass\n            case \"MemoryModel\": pass\n            case \"ExecutionMode\": pass\n            case \"Name\": pass\n            case \"Decorate\": pass\n\n            case _:\n                raise Exception(f\"unhandled header opcode: {line.opcode}\")\n\n\n    logging.debug(f\"processing SPIR-V function(s)...\")\n    # handle body\n    #                            v total spirv functions\n    for counter in range(0, len(spirv_fn_locations)):\n        spirv_fn = spirv_fn_locations[counter]\n\n        for position in range(spirv_fn.start_position, spirv_fn.end_position+1):\n            line = self.parsed_spirv[position]\n            logging.debug(f\"{line}\")\n\n            match line.opcode:\n                case \"Variable\":\n                    if line.id not in node_assembler.declared_symbols:\n                        node_assembler.declared_symbols.append(line.id)\n\n                    node_assembler.add_body_node_to_module(\n                        spirv_fn_name,\n                        Node(\n                            NodeContext(\n                                line_no=position, id=line.id,\n                                type_id=node_assembler.get_primative_type_id_from_id(spirv_fn_name, line.opcode_args[0]),\n                                operation=Operation.VARIABLE_DECLARATION\n                            )\n                        )\n                    )\n\n                case \"Store\":\n\n                    assert node_assembler.node_exists(spirv_fn_name, line.opcode_args[0]), f\"node does not exist: {line.opcode_args[0]}\"\n                    assert node_assembler.node_exists(spirv_fn_name, line.opcode_args[1]), f\"node does not exist: {line.opcode_args[1]}\"\n                    assert not node_assembler.is_symbol_an_input(spirv_fn_name, line.opcode_args[0]), f\"cannot assign value to input variable\"\n                    logging.debug(f\"'{line.opcode_args[1]}' is being stored in '{line.opcode_args[0]}'\")\n\n                    target_node = node_assembler.get_node(spirv_fn_name, line.opcode_args[0])\n                    value_node = node_assembler.get_node(spirv_fn_name, line.opcode_args[1])\n\n                    store_node_ctx = NodeContext(\n                        line_no=position, id=line.opcode_args[0], \n                        type_id=target_node.type_id, input_left=value_node, operation=Operation.STORE\n                    )\n\n                    node_assembler.add_body_node_to_module(spirv_fn_name, Node(store_node_ctx))\n\n\n\n                case \"Load\":\n                    value_node = node_assembler.get_node(spirv_fn_name, line.opcode_args[1])\n\n                    operation = Operation.ARRAY_LOAD if value_node.operation is Operation.ARRAY_INDEX else Operation.LOAD\n\n                    node_assembler.add_body_node_to_module(\n                        spirv_fn_name,\n                        Node(\n                            NodeContext(\n                                line_no=position, id=line.id, type_id=line.opcode_args[0], \n                                input_left=value_node, operation=operation\n                            )\n                        )\n                    )\n\n                case \"IAdd\":\n                    left_node, right_node = node_assembler.get_left_and_right_nodes(spirv_fn_name, line)\n\n                    node_assembler.add_body_node_to_module(\n                        spirv_fn_name,\n                        Node(\n                            NodeContext(\n                                line_no=position, id=line.id, type_id=line.opcode_args[0],\n                                input_left=left_node, input_right=right_node, operation=Operation.ADD\n                            )\n                        )\n                    )\n\n                case \"ISub\":\n                    left_node, right_node = node_assembler.get_left_and_right_nodes(spirv_fn_name, line)\n\n                    node_assembler.add_body_node_to_module(\n                        spirv_fn_name,\n                        Node(\n                            NodeContext(\n                                line_no=position, id=line.id, type_id=line.opcode_args[0],\n                                input_left=left_node, input_right=right_node, operation=Operation.SUB\n                            )\n                        )\n                    )\n\n                case \"IMul\":\n                    left_node, right_node = node_assembler.get_left_and_right_nodes(spirv_fn_name, line)\n\n                    node_assembler.add_body_node_to_module(\n                        spirv_fn_name,\n                        Node(\n                            NodeContext(\n                                line_no=position, id=line.id, type_id=line.opcode_args[0],\n                                input_left=left_node, input_right=right_node, operation=Operation.MULT\n                            )\n                        )\n                    )\n\n                case \"SDiv\":\n                    left_node, right_node = node_assembler.get_left_and_right_nodes(spirv_fn_name, line)\n\n                    node_assembler.add_body_node_to_module(\n                        spirv_fn_name,\n                        Node(\n                            NodeContext(\n                                line_no=position, id=line.id, type_id=line.opcode_args[0],\n                                input_left=left_node, input_right=right_node, operation=Operation.DIV\n                            )\n                        )\n                    )\n\n                case \"Select\":\n                    #                          0           1               2             3\n                    # %result_id = OpSelect %type_id %comparison_id %true_value_id %false_value_id\n                    left_node, right_node = node_assembler.get_left_and_right_nodes(spirv_fn_name, line, [2, 3])\n\n                    compare_node = node_assembler.get_node(spirv_fn_name, line.opcode_args[1])\n\n                    node_assembler.add_body_node_to_module(\n                        spirv_fn_name,\n                        Node(\n                            NodeContext(\n                                line_no=position, id=line.id, type_id=line.opcode_args[0],\n                                input_left=left_node, input_right=right_node, \n                                operation=Operation.DECISION, \n                                data=[compare_node], \n                                is_comparison=True\n                            )\n                        )\n                    )\n\n                case \"IEqual\" | \"FOrdEqual\":\n                    left_node, right_node = node_assembler.get_left_and_right_nodes(spirv_fn_name, line)\n\n                    node_assembler.add_body_node_to_module(\n                        spirv_fn_name,\n                        Node(\n                            NodeContext(\n                                line_no=position, id=line.id, type_id=line.opcode_args[0],\n                                input_left=left_node, input_right=right_node,\n                                operation=Operation.EQUAL_TO\n                            )\n                        )\n                    )\n\n                case \"INotEqual\" | \"FOrdNotEqual\":\n                    left_node, right_node = node_assembler.get_left_and_right_nodes(spirv_fn_name, line)\n\n                    node_assembler.add_body_node_to_module(\n                        spirv_fn_name,\n                        Node(\n                            NodeContext(\n                                line_no=position, id=line.id, type_id=line.opcode_args[0],\n                                input_left=left_node, input_right=right_node,\n                                operation=Operation.NOT_EQUAL_TO\n                            )\n                        )\n                    )\n\n                case \"SLessThan\" | \"FOrdLessThan\":\n                    left_node, right_node = node_assembler.get_left_and_right_nodes(spirv_fn_name, line)\n\n                    node_assembler.add_body_node_to_module(\n                        spirv_fn_name,\n                        Node(\n                            NodeContext(\n                                line_no=position, id=line.id, type_id=line.opcode_args[0],\n                                input_left=left_node, input_right=right_node,\n                                operation=Operation.LESS_THAN\n                            )\n                        )\n                    )\n\n                case \"SLessThanEqual\" | \"FOrdLessThanEqual\":\n                    left_node, right_node = node_assembler.get_left_and_right_nodes(spirv_fn_name, line)\n\n                    node_assembler.add_body_node_to_module(\n                        spirv_fn_name,\n                        Node(\n                            NodeContext(\n                                line_no=position, id=line.id, type_id=line.opcode_args[0],\n                                input_left=left_node, input_right=right_node,\n                                operation=Operation.LESS_OR_EQ\n                            )\n                        )\n                    )\n\n                case \"SGreaterThan\" | \"FOrdGreaterThan\":\n                    left_node, right_node = node_assembler.get_left_and_right_nodes(spirv_fn_name, line)\n\n                    node_assembler.add_body_node_to_module(\n                        spirv_fn_name,\n                        Node(\n                            NodeContext(\n                                line_no=position, id=line.id, type_id=line.opcode_args[0],\n                                input_left=left_node, input_right=right_node,\n                                operation=Operation.GREATER_THAN\n                            )\n                        )\n                    )\n\n                case \"SGreaterThanEqual\" | \"FOrdGreaterThanEqual\":\n                    left_node, right_node = node_assembler.get_left_and_right_nodes(spirv_fn_name, line)\n\n                    node_assembler.add_body_node_to_module(\n                        spirv_fn_name,\n                        Node(\n                            NodeContext(\n                                line_no=position, id=line.id, type_id=line.opcode_args[0],\n                                input_left=left_node, input_right=right_node,\n                                operation=Operation.GREATER_OR_EQ\n                            )\n                        )\n                    )\n\n                case \"ShiftLeftLogical\":\n                    # left_node = thing to shift\n                    # right_node = how much to shift by\n                    left_node, right_node = node_assembler.get_left_and_right_nodes(spirv_fn_name, line)\n\n                    node_assembler.add_body_node_to_module(\n                        spirv_fn_name,\n                        Node(\n                            NodeContext(\n                                line_no=position, id=line.id, type_id=line.opcode_args[0],\n                                input_left=left_node, input_right=right_node,\n                                operation=Operation.SHIFT_LEFT\n                            )\n                        )\n                    )\n\n                # NOTE: this might need to handle \"OpShiftRightArithmetic\"\n                # NOTE? why does this case statement have the \"Op\" prefix but none of the others do?\n                case \"ShiftRightLogical\":\n                    left_node, right_node = node_assembler.get_left_and_right_nodes(spirv_fn_name, line)\n\n                    node_assembler.add_body_node_to_module(\n                        spirv_fn_name,\n                        Node(\n                            NodeContext(\n                                line_no=position, id=line.id, type_id=line.opcode_args[0],\n                                input_left=left_node, input_right=right_node,\n                                operation=Operation.SHIFT_RIGHT\n                            )\n                        )\n                    )\n\n                case \"AccessChain\":\n                    array_node = node_assembler.get_node(spirv_fn_name, line.opcode_args[1])\n                    node_assembler.add_body_node_to_module(\n                        spirv_fn_name,\n                        Node(\n                            NodeContext(\n                                line_no=position, id=line.id, type_id=line.opcode_args[0],\n                                operation=Operation.ARRAY_INDEX, input_left=array_node,\n                                array_id=line.opcode_args[1], array_index_id=line.opcode_args[2]\n                            )\n                        )\n                    )\n\n                # dont do anything with these\n                case \"Function\": pass\n                case \"Label\": pass\n                case \"Return\": pass\n                case \"FunctionEnd\": pass\n\n                case _:\n                    raise Exception(f\"unknown SPIR-V opcode: '{line.opcode}' -- {line}\")\n\n    return node_assembler\n</code></pre>"},{"location":"reference-docs/compiler/compiler/verilog/#titan.compiler.verilog.VerilogAssember.compile_text","title":"<code>compile_text()</code>","text":"<p>Generate SystemVerilog source code based on Nodes.</p> Source code in <code>titan/compiler/verilog.py</code> <pre><code>def compile_text(self):\n    \"\"\" Generate SystemVerilog source code based on Nodes. \"\"\"\n\n    def _get_correct_id(node: Node):\n        \"\"\" Determine the correct ID/value to return.\n\n            Needed because literal constant values need to be returned\n            instead of the ID for them.\n\n            Args:\n                node: Node to determine ID for.\n\n            TODO:\n                Rename the function to something that describes it better.\n        \"\"\"\n        if node.operation in Operation_Type.GENERIC_CONSTANT_DECLARATION:\n            return node.data[0]\n\n        # added for handling comparison node\n        if node.operation is Operation.STORE:\n            return node.input_left.spirv_id[1:]\n        else:\n            return node.spirv_id[1:]\n\n\n    self.append_code(\n        self.Sections.MODULE_AND_PORTS,\n        f\"// automatically generated, dont modify otherwise it might break =)\"\n    )\n\n\n    for module in self.node_assembler.content.keys():\n        self.append_code(self.Sections.MODULE_AND_PORTS, f\"module {module} (\")\n        self.append_code(self.Sections.MODULE_AND_PORTS, f\"\\tinput logic clock_i,\")\n        self.append_code(self.Sections.ALWAYS_BLOCK, f\"\\talways_ff @ (posedge clock_i) begin\")\n\n        module_data = self.node_assembler.content[module]\n        sorted_nodes = self.node_assembler._sort_body_nodes_by_tick(module)\n\n        for tick in range(len(sorted_nodes.keys())):\n            logging.debug(f\"tick {tick} has {len(sorted_nodes[tick])} nodes\")\n\n            io_length_tracker = 0\n\n            for node_index in range(len(sorted_nodes[tick])):\n                node = sorted_nodes[tick][node_index]\n\n                logging.debug(f\"node: {node.spirv_id} {node}\")\n\n                match node.operation:\n\n                    case Operation.GLOBAL_VAR_DECLARATION:\n                        assert tick == 0, f\"variable declaration outside of tick 0\"\n\n                        type_ctx = self.node_assembler.get_type_context_from_module(module, node.type_id)\n                        width = int(type_ctx.data[0])\n\n                        ender = \"\\n);\" if io_length_tracker == (len(module_data.inputs) + len(module_data.outputs)) - 1 else \",\"\n\n                        match node.data[0]:\n                            case Operation.FUNCTION_IN_VAR_PARAM:\n                                self.append_code(\n                                    self.Sections.MODULE_AND_PORTS,\n                                    f\"\\tinput logic [{width-1}:0] {node.spirv_id[1:]}{ender}\"\n                                )\n\n                            case Operation.FUNCTION_OUT_VAR_PARAM:\n                                self.append_code(\n                                    self.Sections.MODULE_AND_PORTS,\n                                    f\"\\toutput logic [{width-1}:0] {node.spirv_id[1:]}{ender}\"\n                                )\n\n                        io_length_tracker += 1\n\n\n                    case Operation.VARIABLE_DECLARATION:\n                        node_type_id = self.node_assembler.get_primative_type_id_from_id(module, node.type_id)\n                        type_context = self.node_assembler.get_type_context_from_module(module, node_type_id)\n\n                        if type_context.is_array:\n                            # define array in sv\n                            array_shape_node = self.node_assembler.get_node(module, type_context.array_dimension_id)\n                            array_shape = array_shape_node.data[0]\n                            assert type(array_shape) is int, f\"unexpected type for array shape, expected int but got {type(array_shape)}. (only 1d arrays supported currently)\"\n\n                            assert array_shape &gt;= 1, f\"array shape must define array of 2 or more elements\"\n                            width = int(self.node_assembler.get_primative_type_context_from_datatype(module, type_context.type).data[0])\n\n                            self.append_code(self.Sections.INTERNAL, f\"\\tlogic [{width-1}:0] {node.spirv_id[1:]} [0:{array_shape-1}];\")\n\n                        else:\n                            logging.debug(f\"not generating logic/reg for {node.spirv_id[1:]}: {node}\")\n\n\n                    case Operation.STORE:\n                        if self.node_assembler.is_symbol_an_output(module, node.spirv_id[1:]):\n                            # if the node is a constant declaration, convert the value it stores into a string, otherwise just use the SPIR-V ID\n                            rhs_text = str(node.input_left.data[0]) if node.input_left.operation is Operation.GLOBAL_CONST_DECLARATION else node.input_left.spirv_id[1:]\n                            self.append_code(self.Sections.ASSIGNMENTS, f\"\\tassign {node.spirv_id[1:]} = {rhs_text};\")\n                        else:\n                            logging.debug(f\"not creating assign statement for {node.spirv_id}: {node}\")\n\n                    case _ if node.operation in Operation_Type.ARITHMETIC:\n                        if node.spirv_id not in self.node_assembler.declared_symbols:\n                            width = int(self.node_assembler.get_type_context_from_module(module, node.type_id).data[0])\n\n                            self.append_code(self.Sections.INTERNAL, f\"\\tlogic [{width-1}:0] {node.spirv_id[1:]};\")\n\n                        assert type(node.operation.value) is str, f\"didn't get a string for operator, is it set correctly? {node.operation}\"\n                        line = f\"\\t\\t{node.spirv_id[1:]} &lt;= {_get_correct_id(node.input_left)} {node.operation.value} {_get_correct_id(node.input_right)};\"\n\n                        self.append_code(self.Sections.ALWAYS_BLOCK, line)\n\n                    case _ if node.operation in Operation_Type.COMPARISON:\n                        defer_node_creation = False\n\n                        logging.debug(f\"checking 1 tick ahead..({tick} + 1 = {tick+1})\")\n                        for future_node in sorted_nodes[tick+1]:\n                            if defer_node_creation: break\n\n                            if future_node.operation == Operation.DECISION:\n                                if future_node.data[0].spirv_id == node.spirv_id:\n                                    logging.debug(f\"found a reference\")\n                                    defer_node_creation = True\n                                else:\n                                    logging.debug(\"no reference found\")\n\n                        logging.debug(\"stopped checking 1 tick ahead\")\n\n                        # TODO: better variable name\n                        if not defer_node_creation:\n                            self.append_code(self.Sections.INTERNAL, f\"\\tlogic {node.spirv_id[1:]};\")\n\n                            assert type(node.operation.value) is str, f\"didn't get a string for operator, is it set correctly? {node.operation}\"\n\n                            line = f\"\\t\\t{node.spirv_id[1:]} &lt;= {_get_correct_id(node.input_left)} {node.operation.value} {_get_correct_id(node.input_right)};\"\n                            self.append_code(self.Sections.ALWAYS_BLOCK, line)\n                        else:\n                            continue\n\n                    case Operation.DECISION:\n                        logging.debug(f\"in decision: {node}\")\n                        comparison_node = node.data[0]\n\n                        # comparison node holds the comparison operator, and the comparison itself\n                        # the paried decision node holds the expected results\n\n                        # so i.e. c = a &gt;= 10 ? 5 : 0 would require the comparison node to construct a &gt;= 10\n                        # and the paried decision node for the ? 5 : 0 section\n\n                        # we dont want to create a logic value for the comparison node because that can just be abstracted away\n                        # so instead we will create the logic value for the decision node\n\n                        width = int(self.node_assembler.get_type_context_from_module(module, node.type_id).data[0])\n\n                        self.append_code(self.Sections.INTERNAL, f\"\\tlogic [{width-1}:0] {node.spirv_id[1:]};\")\n\n                        comparison_symbol = comparison_node.operation.value\n                        assert type(comparison_node.operation.value) is str, f\"didn't get a string for operator, is it set correctly? {comparison_node.operation} {comparison_node.operation.value}\"\n\n                        # TODO: __get_correct_id(node) was returning the string representation of the node instead, why?\n                        line = f\"\\t\\t{node.spirv_id[1:]} &lt;= {_get_correct_id(comparison_node.input_left)} {comparison_symbol} {_get_correct_id(comparison_node.input_right)} ? {_get_correct_id(node.input_left)} : {_get_correct_id(node.input_right)};\"\n                        self.append_code(self.Sections.ALWAYS_BLOCK, line)\n\n                    case _ if node.operation in Operation_Type.BITWISE:\n                        width = int(self.node_assembler.get_type_context_from_module(module, node.type_id).data[0])\n\n                        self.append_code(self.Sections.INTERNAL, f\"\\tlogic [{width-1}:0] {node.spirv_id[1:]}\")\n\n                        line = f\"\\t\\t{_get_correct_id(node)} &lt;= {_get_correct_id(node.input_left)} {Operation(node.operation).value} {_get_correct_id(node.input_right)};\"\n                        self.append_code(self.Sections.ALWAYS_BLOCK, line)\n\n                    case Operation.GLOBAL_CONST_DECLARATION: pass # dont need to generate any text\n\n                    case Operation.ARRAY_INDEX:\n\n                        load_store_node = None\n\n                        # look through all nodes trying to find an associated load/store node\n                        # cant only peek one tick ahead because it may not be there \n                        #   -&gt; x[1] = 1 + 2 / b is two steps, so the load/store node is actually located at tick+2 not tick+1\n                        for i in range(tick, len(sorted_nodes)):\n                            for j in range(len(sorted_nodes[i])):\n                                future_node = sorted_nodes[i][j]\n\n                                logging.debug(f\"checking: {future_node}\")\n\n                                if future_node.operation == Operation.ARRAY_LOAD:\n                                    if future_node.input_left.spirv_id == node.spirv_id:\n                                        logging.debug(f\"array load, id of left input matches current node: {future_node.input_left.spirv_id} == {node.spirv_id}\")\n                                        load_store_node = future_node\n                                        break\n\n                                # NOTE: future_node.operation == (Operation.ARRAY_STORE or Operation.STORE) doesn't work?\n                                elif future_node.operation in [Operation.ARRAY_STORE, Operation.STORE]:\n                                    if future_node.spirv_id == node.spirv_id:\n                                        logging.debug(f\"array store, id of store node matches current node: {future_node.spirv_id} == {node.spirv_id}\")\n                                        load_store_node = future_node\n                                        break\n\n\n                        assert load_store_node != None, f\"failed to find a corresponding array load/store node\"\n\n                        # generate sv text based whether node is load/store\n\n                        match load_store_node.operation:\n                            case Operation.ARRAY_LOAD:\n                                assert not self.node_assembler.is_symbol_an_output(module, load_store_node.input_left.spirv_id), f\"cannot load value from output port\"\n\n                                # TODO: get width for int type, hardcoded for now\n                                self.append_code(self.Sections.INTERNAL, f\"\\tlogic [31:0] {load_store_node.spirv_id[1:]};\")\n\n                                array_max_size = self.node_assembler.get_array_node_dimensions(module, node.array_id)\n                                array_index = self.node_assembler.get_node(module, node.array_index_id).data[0]\n\n                                # TODO: tuples\n                                assert type(array_max_size) is int, f\"array_max_size should have been int but got {type(array_max_size)} instead\"\n                                assert array_index &lt; array_max_size, f\"array_index was not less than array_max_size: {array_index} &lt; {array_max_size}\"\n\n                                # assign in body\n                                self.append_code(self.Sections.ALWAYS_BLOCK, f\"\\t\\t{load_store_node.spirv_id[1:]} &lt;= {node.array_id[1:]}[{array_index}];\")\n\n                            case _ if load_store_node.operation in [Operation.ARRAY_STORE, Operation.STORE]:\n                                array_index = self.node_assembler.get_node(module, node.array_index_id).data[0]\n                                array_max_size = self.node_assembler.get_array_node_dimensions(module, node.array_id)\n\n                                # TODO: tuples (as above)\n                                assert type(array_max_size) is int, f\"array_max_size should have been int but got {type(array_max_size)} instead\"\n\n                                # will need to change comparison so that it works with tuples\n                                assert array_index &lt; array_max_size, f\"array_index was not less than array_max_size: {array_index} &lt; {array_max_size}\"\n\n                                self.append_code(self.Sections.ALWAYS_BLOCK, f\"\\t\\t{node.input_left.spirv_id[1:]}[{array_index}] &lt;= {load_store_node.input_left.spirv_id[1:]};\")\n\n                            case _:\n                                raise Exception(f\"unexpected operation: {load_store_node.operation}\")\n\n                    case Operation.ARRAY_LOAD: pass\n\n                    case _:\n                        raise Exception(f\"unhandled node during systemverilog generation: {node}\")\n\n        self.append_code(self.Sections.ALWAYS_BLOCK, f\"\\tend\")\n        self.append_code(self.Sections.ASSIGNMENTS, \"endmodule\")\n</code></pre>"},{"location":"reference-docs/compiler/compiler/verilog/#titan.compiler.verilog.VerilogAssember.write_to_file","title":"<code>write_to_file(filename)</code>","text":"<p>Write verilog content out to a file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Name of file to create/overwrite.</p> required Source code in <code>titan/compiler/verilog.py</code> <pre><code>def write_to_file(self, filename: str):\n    \"\"\" Write verilog content out to a file.\n\n        Args:\n            filename: Name of file to create/overwrite.\n    \"\"\"\n    logging.info(f\"Writing RTL to file ({filename}.sv)\")\n    with open(f\"{filename}.sv\", \"w\") as f:\n        for section, list_of_lines in self.generated_verilog_text.items():\n            logging.debug(f\"Writing section {section.name}\")\n\n            for line in list_of_lines:\n                f.write(line)\n                f.write(f\"\\n\")\n</code></pre>"},{"location":"reference-docs/compiler/tests/test_helper/","title":"Documentation for <code>test_helper.py</code>","text":""},{"location":"reference-docs/compiler/tests/test_helper/#titan.tests.test_helper._generate_dummy_args","title":"<code>_generate_dummy_args()</code>","text":"<p>Randomly generates a set of arguments.</p> <p>Returns:</p> Type Description <code>tuple[list, OptionsTuple]</code> <p>Tuple containing a list of args to overwrite sys.argv with, and <code>OptionsTuple</code>.</p> Source code in <code>titan/tests/test_helper.py</code> <pre><code>def _generate_dummy_args() -&gt; tuple[list, OptionsTuple]:\n    \"\"\" Randomly generates a set of arguments.\n\n        Returns:\n            Tuple containing a list of args to overwrite sys.argv with, and `OptionsTuple`.\n    \"\"\"\n    # no zeroth element to align with OptionsTuple\n    args_lookup = bidict({\n        1: \"-t\", 2: \"-asm\", 3: \"-s\", 4: \"-v\"\n    })\n\n    # need dummy file\n    args = [\"script.py\"]\n\n    # im sure i could just iterate through all of these instead\n    options = OptionsTuple(\n        source_file=\"file.py\",\n        # top=choice([True, False]), # unused at the moment\n        top=False,  # force to false\n        asm=choice([True, False]),\n        spirv_only=choice([True, False]),\n        verbose=choice([True, False]),\n    )\n\n    # NOTE: ignoring -t option for now, not well supported in compiler\n    # also needs additional string specified\n    for i in range(2, len(options)):\n        if options[i]:  # if option is set to true\n            args.append(args_lookup[i])\n\n    args.append(options.source_file)\n\n    return args, options\n</code></pre>"},{"location":"reference-docs/compiler/tests/test_helper/#titan.tests.test_helper.test_argparse","title":"<code>test_argparse()</code>","text":"<p>Tests <code>main.run_argparse</code></p> <p>Expecting to have correct attributes set after parsing arguments.</p> Source code in <code>titan/tests/test_helper.py</code> <pre><code>def test_argparse():\n    \"\"\" Tests `main.run_argparse`\n\n        Expecting to have correct attributes set after parsing arguments.\n    \"\"\"\n\n    args, options = _generate_dummy_args()\n\n    with patch.object(sys, \"argv\", args):\n        parsed_args = run_argparse()\n\n    assert parsed_args.source_file == options.source_file, f\"{parsed_args.source_file} != {options.source_file}\"\n    assert parsed_args.top == None, f\"{parsed_args.top} != {options.top}\"       # not set\n    assert parsed_args.asm == options.asm, f\"{parsed_args.asm} != {options.asm}\"\n    assert parsed_args.s == options.spirv_only, f\"{parsed_args.s} != {options.spirv_only}\"\n    assert parsed_args.verbose == options.verbose, f\"{parsed_args.verbose} != {options.verbose}\"\n</code></pre>"},{"location":"reference-docs/compiler/tests/test_helper/#titan.tests.test_helper.test_compiler_context","title":"<code>test_compiler_context()</code>","text":"<p>Tests <code>compiler.helper.CompilerContext</code></p> <p>Expecting to have correct attributes set and functions returning matching values.</p> Source code in <code>titan/tests/test_helper.py</code> <pre><code>def test_compiler_context():\n    \"\"\" Tests `compiler.helper.CompilerContext`\n\n        Expecting to have correct attributes set and functions returning matching values.\n    \"\"\"\n\n    args, options = _generate_dummy_args()\n\n    with patch.object(sys, \"argv\", args):\n        patched_args = run_argparse()\n\n    compiler_context = CompilerContext(patched_args)\n\n    assert compiler_context.user_wants_spirv_asm() == options.asm, f\"{compiler_context.user_wants_spirv_asm()} != {options.asm}\"\n    assert compiler_context.has_user_defined_top() == options.top, f\"{compiler_context.has_user_defined_top()} != {options.top}\"\n    assert compiler_context.get_top_module_name() == None, f\"{compiler_context.get_top_module_name()} != None\"\n    assert compiler_context.user_only_wants_spirv() == options.spirv_only, f\"{compiler_context.user_only_wants_spirv()} != {options.spirv_only}\"\n    assert compiler_context.user_wants_verbose_info() == options.verbose, f\"{compiler_context.user_wants_verbose_info()} != {options.verbose}\"\n</code></pre>"},{"location":"reference-docs/library/TitanComms.cpp/","title":"Class TitanComms","text":"<p>ClassList &gt; TitanComms</p>"},{"location":"reference-docs/library/TitanComms.cpp/#classes","title":"Classes","text":"Type Name struct u_int24"},{"location":"reference-docs/library/TitanComms.cpp/#public-types","title":"Public Types","text":"Type Name enum instruction"},{"location":"reference-docs/library/TitanComms.cpp/#public-functions","title":"Public Functions","text":"Type Name TitanComms (int cs_pin, SPISettings spi_settings)  void begin ()  void bind_address (u_int24 address)  u_int32_t read (u_int24 address)  void set_core_interrupt (u_int24 address)  void set_stream_read_address (u_int32_t address)  void set_stream_write_address (u_int32_t address)  u_int32_t stream (u_int32_t value)  void write (u_int24 address, u_int32_t value)"},{"location":"reference-docs/library/TitanComms.cpp/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"reference-docs/library/TitanComms.cpp/#enum-instruction","title":"enum instruction","text":"<pre><code>enum TitanComms::instruction {\n    NOP = 0x00,\n    WRITE = 0x01,\n    READ = 0x02,\n    STREAM = 0x03,\n    BIND_INTERRUPT = 0x04,\n    BIND_READ_ADDRESS = 0x05,\n    BIND_WRITE_ADDRESS = 0x06,\n    TRANSFER = 0x07,\n    REPEAT = 0x08,\n    GET_METADATA = 0xFF\n};\n</code></pre>"},{"location":"reference-docs/library/TitanComms.cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"reference-docs/library/TitanComms.cpp/#function-titancomms","title":"function TitanComms","text":"<pre><code>TitanComms::TitanComms (\n    int cs_pin,\n    SPISettings spi_settings\n) \n</code></pre>"},{"location":"reference-docs/library/TitanComms.cpp/#function-begin","title":"function begin","text":"<pre><code>void TitanComms::begin () \n</code></pre>"},{"location":"reference-docs/library/TitanComms.cpp/#function-bind_address","title":"function bind_address","text":"<pre><code>void TitanComms::bind_address (\n    u_int24 address\n) \n</code></pre>"},{"location":"reference-docs/library/TitanComms.cpp/#function-read","title":"function read","text":"<pre><code>u_int32_t TitanComms::read (\n    u_int24 address\n) \n</code></pre>"},{"location":"reference-docs/library/TitanComms.cpp/#function-set_core_interrupt","title":"function set_core_interrupt","text":"<pre><code>void TitanComms::set_core_interrupt (\n    u_int24 address\n) \n</code></pre>"},{"location":"reference-docs/library/TitanComms.cpp/#function-set_stream_read_address","title":"function set_stream_read_address","text":"<pre><code>void TitanComms::set_stream_read_address (\n    u_int32_t address\n) \n</code></pre>"},{"location":"reference-docs/library/TitanComms.cpp/#function-set_stream_write_address","title":"function set_stream_write_address","text":"<pre><code>void TitanComms::set_stream_write_address (\n    u_int32_t address\n) \n</code></pre>"},{"location":"reference-docs/library/TitanComms.cpp/#function-stream","title":"function stream","text":"<pre><code>u_int32_t TitanComms::stream (\n    u_int32_t value\n) \n</code></pre>"},{"location":"reference-docs/library/TitanComms.cpp/#function-write","title":"function write","text":"<pre><code>void TitanComms::write (\n    u_int24 address,\n    u_int32_t value\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>titan/comms/TitanComms/TitanComms.h</code></p>"},{"location":"user-guide/cli-options/","title":"Command Line Options Reference","text":""},{"location":"user-guide/cli-options/#available-options","title":"Available Options","text":"Option Function <code>-t</code> Specify top function if there are multiple functions in the same source file <code>-asm</code> Output SPIR-V assembly code <code>-s</code> Only run the SPIR-V generation <code>-v</code> Verbose, output debug information to console <p>To use an option simply pass it as an argument to the program: <code>python3 titan/main.py -asm my_file.py</code></p>"},{"location":"user-guide/cli-options/#source-code","title":"Source Code","text":""},{"location":"user-guide/cli-options/#titan.main.run_argparse","title":"<code>titan.main.run_argparse()</code>","text":"<p>Handles setting up and executing <code>argparse.ArgumentParser</code>.</p> <p>Returns:</p> Type Description <code>Namespace</code> <p>Parsed arguments</p> Source code in <code>titan/main.py</code> <pre><code>def run_argparse() -&gt; argparse.Namespace:\n    \"\"\" Handles setting up and executing `argparse.ArgumentParser`.\n\n        Returns:\n            Parsed arguments\n    \"\"\"\n    parser = argparse.ArgumentParser(\n        description = \"Compile a subset of Python into SystemVerilog. Visit https://titan-compiler-project.github.io/titan for more info.\"\n    )\n\n    parser.add_argument(\"source_file\", help=\"python source file to compile\")\n    parser.add_argument(\"-t\", \"--top\", help=\"specify the top function\")\n    parser.add_argument(\"-asm\", help=\"output the SPIR-V assembly code\", action=\"store_true\")\n    parser.add_argument(\"-s\", help=\"only run the SPIR-V generation\", action=\"store_true\", dest=\"run_spirv_only\")\n    parser.add_argument(\"-v\", \"--verbose\", help=\"output debug messages\", action=\"store_true\")\n\n    return parser.parse_args()\n</code></pre>"},{"location":"user-guide/comms/","title":"Communications","text":"<p>In order to interface with the generated core, we need some method to get data on and off the FPGA itself. It was decided that SPI would be a good fit - it's fairly common, especially on micrcontrollers, and relatively easy to use.</p> <p>SPI connects with a hardware module on the FPGA that is waiting for an instruction &amp; the relevant data to arrive, so that it can set the appropriate buses and coordinate data.</p> <p>An Arduino library (provided by this project) can be used to abstract the communication away into a few simple function calls, helping to improve accessibility. Currently it has been tested on a Teensy 3.2 and the Raspberry Pi Pico.</p>"},{"location":"user-guide/comms/#short-introduction-into-spi","title":"Short introduction into SPI","text":"<p>Serial Protocol Interface (SPI) is a protocol that allows devices to communicate in a synchronous, full-duplex manner. It has 4 pins: clock (CLK), chip select (CS), controller-out-peripheral-in (COPI) and peripheral-out-controller-in (POCI).</p> <p>Three wires are handled by the controller (CLK, CS, COPI) and one by the peripheral (POCI). CLK and CS coordinate the communication, whilst COPI and POCI contain the data which is being transferred across the devices.</p>"},{"location":"user-guide/comms/#custom-protocol","title":"Custom Protocol","text":"<p>Since SPI does not directly define a communications protocol, instead only how it works electrically, it is necessary to outline a protocol that will allow us to communicate with the FPGA.</p> <p>Packets of information can only be 8 bytes long at maximum, being segmented into 1 byte increments.</p> <p>The first byte must be a valid instruction (<code>READ</code>, <code>WRITE</code>, <code>STREAM</code>, <code>BIND_WRITE_ADDRESS</code>, <code>BIND_READ_ADDRESS</code>, <code>TRANSFER</code>, <code>REPEAT</code>), followed up by additional information if required. For example, if you are executing a <code>WRITE</code> instruction, you need to provide a 3-byte address and a 4-byte value which gets written to the address; whilst a <code>READ</code> instruction only requires the 3-byte address as additional data.</p> <p>In theory any device which implements this protocol will be able to communicate with the FPGA, so it isn't limited to only microcontrollers. This could be done on a PC which bit-bangs the wires, though its unlikely to be useful in that context.</p>"},{"location":"user-guide/comms/#protocol-reference","title":"Protocol Reference","text":"Mnemonic Instruction Fields Format Action <code>NOP</code> <code>0x00</code> No fields <code>NOP</code> No operation <code>WRITE</code> <code>0x01</code> <code>ADDRESS</code> (3 bytes),  <code>VALUE</code> (4 bytes) <code>WRITE ADDRESS VALUE</code> Write <code>VALUE</code> to <code>ADDRESS</code> <code>READ</code> <code>0x02</code> <code>ADDRESS</code> (3 bytes) <code>READ ADDRESS</code> Read a value from <code>ADDRESS</code>  (This only places the value in an internal register.) <code>STREAM</code> <code>0x03</code> <code>VALUE</code> (4 bytes) <code>STREAM VALUE</code> Stream a <code>VALUE</code> to a pre-determined address, and recieve a value simultaneously <code>RESERVED</code> <code>0x04</code> - - Reserved <code>BIND_READ_ADDRESS</code> <code>0x05</code> <code>ADDRESS</code> (3 bytes) <code>BIND_READ_ADDRESS ADDRESS</code> Bind to an address to read from when running a <code>STREAM</code> instruction <code>BIND_WRITE_ADDRESS</code> <code>0x06</code> <code>ADDRESS</code> (3 bytes) <code>BIND_WRITE_ADDRESS ADDRESS</code> Bind to an address to write a value to when running a <code>STREAM</code> instruction <code>TRANSFER</code> <code>0x07</code> No fields <code>TRANSFER</code> Transfer 1 byte across SPI, advancing the internal data pointer by 1 <code>REPEAT</code> <code>0x08</code> No fields <code>REPEAT</code> Reset the internal data pointer <code>N/A</code> <code>0x09 - 0xFE</code> No fields No format Unused range <code>RESERVED</code> <code>0xFF</code> - - Reserved"},{"location":"user-guide/comms/#arduino-library","title":"Arduino Library","text":"<p>Info</p> <p>The library is currently on the <code>dev</code> branch, under <code>titan/titan/comms/TitanComms</code></p> <p>A very simple Arduino library is provided for use on the Pico or Teensy 3.2 microcontrollers. It provides functionality for reading, writing and streaming to the core.</p> <p>However, it is not necessary to use this library. Any device with an SPI connection that implements the protocol is able to communicate to the core.</p>"},{"location":"user-guide/getting-started/","title":"Getting Started","text":"<p>Warning</p> <p>This is currently a work-in-progress compiler. Please be aware that there will be some bugs stil rumaging around in the code. </p>"},{"location":"user-guide/getting-started/#setting-up","title":"Setting up","text":""},{"location":"user-guide/getting-started/#cloning-installing","title":"Cloning &amp; Installing","text":"<p>To get started, clone the compiler repository. The <code>master</code> branch usually has builds which are slightly out of date, but should be functioning. The <code>dev</code> branch is more up-to-date, but could be broken.</p> <p>Clone the master repo: <pre><code>git clone -b master https://github.com/titan-compiler-project/titan\n</code></pre></p> <p>Move into the cloned directory: <code>bash cd titan</code></p> <p>Install the required Python packages as specified in <code>requirements.txt</code> by running: <pre><code>pip install -r requirements.txt\n</code></pre></p> <p>Once cloned, execute <code>titan/main.py</code> with the appropriate command line arguments to run the compiler. There are example files available in the repository, under <code>titan/sample_code/</code>.</p> <p>To execute the <code>simple_neuron.py</code> program, you can run the following in your terminal: <pre><code>python3 titan/main.py titan/sample_code/simple_neuron.py\n</code></pre></p> <p>This is the source file being compiled by the command above: simple_neuron.py<pre><code>def step(x0:int, x1:int, x2:int, x3:int) -&gt; int:\n    w0 = 3\n    w1 = 4\n    w2 = -1\n    w3 = -2\n\n    a = ((w0*x0) + (w1*x1)) + ((w2*x2) + (w3*x3))\n    r = a if a &gt; 0 else 0\n    return r\n</code></pre> It generates the following SystemVerilog code: simple_neuron.sv<pre><code>module step (\n    input logic clock_i,\n    input logic [31:0] x0,\n    input logic [31:0] x1,\n    input logic [31:0] x2,\n    input logic [31:0] x3,\n    output logic [31:0] r\n);\n    logic [31:0] titan_id_0;\n    logic [31:0] titan_id_1;\n    logic [31:0] titan_id_3;\n    logic [31:0] titan_id_4;\n    logic [31:0] titan_id_2;\n    logic [31:0] titan_id_5;\n    logic [31:0] titan_id_6;\n    logic [31:0] titan_id_8;\n    always_ff @ (posedge clock_i) begin\n        titan_id_0 &lt;= 3 * x0;\n        titan_id_1 &lt;= 4 * x1;\n        titan_id_3 &lt;= -1 * x2;\n        titan_id_4 &lt;= -2 * x3;\n        titan_id_2 &lt;= titan_id_0 + titan_id_1;\n        titan_id_5 &lt;= titan_id_3 + titan_id_4;\n        titan_id_6 &lt;= titan_id_2 + titan_id_5;\n        titan_id_8 &lt;= titan_id_6 &gt; 0 ? titan_id_6 : 0;\n    end\n    assign r = titan_id_8;\nendmodule\n</code></pre></p> <p>There are optional arguments available to modify the behaviour of the compiler. A reference is available here.</p> <p>You should then be able to import these files into an FPGA project and program your device.</p>"},{"location":"user-guide/getting-started/#flashing-running","title":"Flashing &amp; Running","text":"<p>You can use the generated SystemVerilog files and program an FPGA with it, provided that it contains enough logic elements for your design.</p> <p>Info</p> <p>The compiler currently does not automatically generate the necessary interface HDL files, these are available in <code>titan/templates/verilog</code> and can be modified to suit your module. </p>"},{"location":"user-guide/getting-started/#alteraintel","title":"Altera/Intel","text":"<ol> <li>Create a new project via the New Project Wizard in Quartus Prime.</li> <li>Import your source files.</li> <li>Assign FPGA pins - the current interface method requires 4 pins for SPI + 1 for the system clock. Make sure these are accessible and set to the correct direction.</li> <li>Run the compilation and flash onto the FPGA, or run a simulation.</li> </ol>"},{"location":"user-guide/getting-started/#xilinxamdothers","title":"Xilinx/AMD/Others","text":"<p>The process is likely to be similar for other FPGA vendors, I simply do not have access to other FPGAs to write about it.</p>"},{"location":"user-guide/getting-started/#subset","title":"Subset","text":"<p>Please ensure that your code fits within the defined subset so that it can be compiled.</p> <p>This subset can be viewed here</p>"},{"location":"user-guide/synthesised-modules/","title":"Synthesised Modules","text":"<p>The output of the Titan compiler consists of multiple SystemVerilog source files, which can then be used in conjunction with Quartus/Xilinx/other software to create a bitstream for FPGA programming, or fed through an open-source ASIC flow like OpenLane to generate chip layouts.</p> <p>The core components have been tested on an Altera Cyclone V 5CEFA2F23I7N FPGA dev board from QMTECH. The documentation for this FPGA can be found here.</p> <p>The hierarchy looks something like this: <pre><code>\u251c top\n\u2502 \u251c SPI Interface\n\u2502 \u251c Instruction Handler\n\u2502 \u2514 Core Interface\n\u2502   \u2514 User Module \n</code></pre></p>"},{"location":"user-guide/synthesised-modules/#core-modules","title":"Core Modules","text":""},{"location":"user-guide/synthesised-modules/#spi-interface","title":"SPI Interface","text":"<p>The SPI interface is provided by Coert Vonk, and is available on GitHub. This module exposes 4 wires to the user (CLK, CS, POCI, PICO) which is the only way of getting data in and out of the system. </p>"},{"location":"user-guide/synthesised-modules/#instruction-handler","title":"Instruction Handler","text":"<p>The instruction handler module is responsible for receiving bytes from the SPI interface, and interpreting them. For example, if there is no instruction currently active, then the next byte from the SPI interface must be a valid instruction for the module to perform any action. If a valid instruction byte is received, then the module will wait to receive the remaining bytes before setting any internal buses.</p> <p>Info</p> <p>Valid instructions and the SPI protocol can be found here.</p> <p>Once all of the required bytes have been received, internal buses will be set to appropriate values. For example, if we are attemping to write the value <code>0xDE</code> to the address <code>0x04</code> then the instruction handler will wait until the write opcode has been issued (<code>0x01</code>), then wait to receive an additional 7 bytes - 3 for the address, 4 for the value.</p> <p>The instruction bus will be set to <code>0x01</code>, address bus to <code>0x04</code> and the value bus to <code>0xDE</code>.</p>"},{"location":"user-guide/synthesised-modules/#core-interface","title":"Core Interface","text":"<p>The core interface is a wrapper around the user module/core that allows it to interface with the rest of the system. It interprets the current instruction on the bus and will act accordingly if it is being indexed, determined by the start and end range of its address. </p> <p>The core interface provides a memory array for both the inputs and outputs, which are written to by sending instructions. This memory array is directly connected to the inputs and ouputs of the user module, and therefore act similarly to passing parameters to a function in regular code.</p> <p>Currently only one core interface can be instanciated, as the bus does not contain a multiplexer.</p> <p>Each core interface is unique to the user module, as the memory depth must change depending on how many parameters the user wants. Furthermore, the user module is actually instanciated within this module.</p>"},{"location":"user-guide/synthesised-modules/#user-modules","title":"User Modules","text":"<p>The user module is genereated by the Titan compiler, when the user passes through a valid Python-subset source file.</p>"},{"location":"user-guide/compiler/intro/","title":"Introduction","text":"<p>The compiler is split into two sections: the \"frontend\" which takes the Python source file and converts it into SPIR-V, and the \"backend\" which takes the SPIR-V and converts it into SystemVerilog.</p> <p>The \"frontend\" makes use of Python's AST class, in order to parse the syntax into something meaningful. Using AST and its calls to relevant functions, we are able to construct the SPIR-V assembly. These functions can be seen in <code>titan/spirv.py</code>.</p> <p>The \"backend\" uses Pyparsing to parse the SPIR-V assembly file, as no existing module exists for this function. The grammar is rough, but suitable for this usecase.</p> <p>Rough intro to the project structure: - <code>titan/common/</code>  holds files relevant for common tasks, and which are not directly related to compilation - <code>titan/compiler/</code> holds files relating to the Python \u2192 SPIR-V compiler, and the SPIR-V \u2192 SystemVerilog compiler - <code>titan/comms/</code> holds files relating to the communication, such as SystemVerilog RTL and the Arduino communications library</p>"},{"location":"user-guide/compiler/python-spirv/","title":"Python to SPIR-V","text":"<p>Warning</p> <p>Compatibility with GPUs is not guaranteed!</p> <p>A Python source file is taken as an input to the compiler. It gets parsed and eventually compiled into SPIR-V assembly. The use of SPIR-V allows the frontend and backend of the compiler to be easily swapped out, and for the SPIR-V assembly to also be used on existing parallel hardware, such as GPUs.</p> <p>The parsing of the Python source file is performed by Python's AST module. This module, when supplied with Python source code will transform it into a tree which can be programmatically traversed. This feature means that when the AST module is parsing, calls will be made to various functions depending on the expression.</p> <p>Example</p> <p>If the AST module encounters a function definition, it'll call <code>visit_FunctionDef</code>, or if you have code that is something like <code>a = 4</code>, it'll call <code>visit_Assign</code>. </p> <p>More details available at the Python Docs here.</p> <p>Some additional features (once implemented), such as total functional recursion, will be made available via Python decorators.</p>"},{"location":"user-guide/compiler/python-spirv/#brief-overview-of-functionality","title":"Brief overview of functionality","text":""},{"location":"user-guide/compiler/python-spirv/#functions-calls","title":"Functions &amp; Calls","text":"<p>Calls are currently not supported, however functions can be defined. When compiling a function definition into SPIR-V, debug information and types will be created, as well as parsing of the input and output parameters.</p> <p>Multiple returns are not supported currently, however you can have an abritrary number of inputs. Both the inputs and outputs must have type hints, so that the compiler does not have to guess the type.</p> <p>Once all the information has been created, the compiler will call <code>super().generic_visit(node)</code> to procced further.</p>"},{"location":"user-guide/compiler/python-spirv/#assignments-arithmetic-comparison","title":"Assignments, Arithmetic &amp; Comparison","text":"<p>These operations are handled a recursive function that will attempt to parse anything related to arithmetic or comparison operations and return the final line ID and context about the line. During its recursion, it will create any necessary types and context structures which are available to access via the SPIR-V helper class.</p> <p>Nested arithmetic expressions are evaluated with the <code>_eval_line</code> function. On each call, it'll generate an intermediate ID that will store the value of one operation. A combination of these intermediate IDs will create the final result of the calculation.</p> <p>Example</p> <p>An expression like <code>c = a + (b / 2)</code> would first have <code>b / 2</code> evaluated and the result placed into a temporary ID, and then <code>a + temporaryID</code> would get evaluated next.</p> <p>In SPIR-V context, would look something like so: <pre><code>%1 = OpSDiv %type_int %b %const_2\n%2 = OpIAdd %type_int %a %1\nOpStore %c %2\n</code></pre></p> <p>Whilst <code>_eval_line</code> also handles comparison expressions, it does not directly perform any actions. Instead this is handed off to <code>visit_Compare</code> and <code>visit_IfExp</code>. This is done because you may perform a comparison operation outside of an if-expression, so the distinction is necessary.</p>"},{"location":"user-guide/compiler/spirv-systemverilog/","title":"SPIR-V to SystemVerilog","text":"<p>The compiled SPIR-V assembly from the previous stage is passed directly to this stage, without reading or writing to an external file first. To prase the SPIR-V assembly, the compiler makes use of PyParsing. Grammar is defined in <code>titan.common.grammar.TitanSPIRVGrammar</code>.</p> <p>SPIR-V is returned as a PyParsing object, where each line is then indexed to create a node graph, before generating the SystemVerilog. The graph step is necessary in order to coordinate everything into the correct tick.</p> <p>Within <code>titan.compiler.verilog.compile_nodes</code> the parsed SPIR-V is handled, and the nodes are constructed using the classes within <code>titan.compiler.node</code>.</p>"},{"location":"user-guide/compiler/spirv-systemverilog/#anatomy-of-the-node","title":"Anatomy of the Node","text":"<p>The Node (found in <code>titan.compiler.node</code>) is a class that contains information about the node itself, and left/right inputs. These inputs help to link the node with other operations, and will allow us to traverse the node tree once all of the SPIR-V is processed.</p> <p>The node accepts the <code>NodeContext</code> class upon construction, and this sets up all the relevant information. The tick of the node is automatically calculated by evaluating the ticks of the left and right input node, if present. If not, it is set to 0.</p>"},{"location":"TitanComms/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>class TitanComms <ul> <li>struct u_int24 </li> </ul> </li> <li>class VL_NOT_FINAL </li> <li>class Vtop__Syms </li> <li>class Vtop___024root </li> <li>class Vtop___024unit </li> </ul>"},{"location":"TitanComms/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir titan <ul> <li>dir comms <ul> <li>dir TitanComms <ul> <li>file TitanComms.cpp </li> <li>file TitanComms.h </li> <li>file TitanCommsDebug.h </li> </ul> </li> <li>dir verilog <ul> <li>dir tests <ul> <li>dir sim_build <ul> <li>file Vtop.cpp </li> <li>file Vtop.h </li> <li>file Vtop__ALL.cpp </li> <li>file Vtop__Dpi.cpp </li> <li>file Vtop__Dpi.h </li> <li>file Vtop__Syms.cpp </li> <li>file Vtop__Syms.h </li> <li>file Vtop__Trace__0.cpp </li> <li>file Vtop__Trace__0__Slow.cpp </li> <li>file Vtop___024root.h </li> <li>file Vtop___024root__DepSet_h84412442__0.cpp </li> <li>file Vtop___024root__DepSet_h84412442__0__Slow.cpp </li> <li>file Vtop___024root__DepSet_heccd7ead__0.cpp </li> <li>file Vtop___024root__DepSet_heccd7ead__0__Slow.cpp </li> <li>file Vtop___024root__Slow.cpp </li> <li>file Vtop___024unit.h </li> <li>file Vtop___024unit__DepSet_hff17caec__0__Slow.cpp </li> <li>file Vtop___024unit__Slow.cpp </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"TitanComms/classTitanComms/","title":"Class TitanComms","text":"<p>ClassList &gt; TitanComms</p>"},{"location":"TitanComms/classTitanComms/#classes","title":"Classes","text":"Type Name struct u_int24"},{"location":"TitanComms/classTitanComms/#public-types","title":"Public Types","text":"Type Name enum instruction"},{"location":"TitanComms/classTitanComms/#public-functions","title":"Public Functions","text":"Type Name TitanComms (int cs_pin, SPISettings spi_settings)  void begin ()  void bind_address (u_int24 address)  u_int32_t read (u_int24 address)  void set_core_interrupt (u_int24 address)  void set_stream_read_address (u_int32_t address)  void set_stream_write_address (u_int32_t address)  u_int32_t stream (u_int32_t value)  void write (u_int24 address, u_int32_t value)"},{"location":"TitanComms/classTitanComms/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"TitanComms/classTitanComms/#enum-instruction","title":"enum instruction","text":"<pre><code>enum TitanComms::instruction {\n    NOP = 0x00,\n    WRITE = 0x01,\n    READ = 0x02,\n    STREAM = 0x03,\n    BIND_INTERRUPT = 0x04,\n    BIND_READ_ADDRESS = 0x05,\n    BIND_WRITE_ADDRESS = 0x06,\n    TRANSFER = 0x07,\n    REPEAT = 0x08,\n    GET_METADATA = 0xFF\n};\n</code></pre>"},{"location":"TitanComms/classTitanComms/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"TitanComms/classTitanComms/#function-titancomms","title":"function TitanComms","text":"<pre><code>TitanComms::TitanComms (\n    int cs_pin,\n    SPISettings spi_settings\n) \n</code></pre>"},{"location":"TitanComms/classTitanComms/#function-begin","title":"function begin","text":"<pre><code>void TitanComms::begin () \n</code></pre>"},{"location":"TitanComms/classTitanComms/#function-bind_address","title":"function bind_address","text":"<pre><code>void TitanComms::bind_address (\n    u_int24 address\n) \n</code></pre>"},{"location":"TitanComms/classTitanComms/#function-read","title":"function read","text":"<pre><code>u_int32_t TitanComms::read (\n    u_int24 address\n) \n</code></pre>"},{"location":"TitanComms/classTitanComms/#function-set_core_interrupt","title":"function set_core_interrupt","text":"<pre><code>void TitanComms::set_core_interrupt (\n    u_int24 address\n) \n</code></pre>"},{"location":"TitanComms/classTitanComms/#function-set_stream_read_address","title":"function set_stream_read_address","text":"<pre><code>void TitanComms::set_stream_read_address (\n    u_int32_t address\n) \n</code></pre>"},{"location":"TitanComms/classTitanComms/#function-set_stream_write_address","title":"function set_stream_write_address","text":"<pre><code>void TitanComms::set_stream_write_address (\n    u_int32_t address\n) \n</code></pre>"},{"location":"TitanComms/classTitanComms/#function-stream","title":"function stream","text":"<pre><code>u_int32_t TitanComms::stream (\n    u_int32_t value\n) \n</code></pre>"},{"location":"TitanComms/classTitanComms/#function-write","title":"function write","text":"<pre><code>void TitanComms::write (\n    u_int24 address,\n    u_int32_t value\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>titan/comms/TitanComms/TitanComms.h</code></p>"},{"location":"TitanComms/structTitanComms_1_1u__int24/","title":"Struct TitanComms::u_int24","text":"<p>ClassList &gt; TitanComms &gt; u_int24</p>"},{"location":"TitanComms/structTitanComms_1_1u__int24/#public-attributes","title":"Public Attributes","text":"Type Name u_int32_t data"},{"location":"TitanComms/structTitanComms_1_1u__int24/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"TitanComms/structTitanComms_1_1u__int24/#variable-data","title":"variable data","text":"<pre><code>u_int32_t TitanComms::u_int24::data;\n</code></pre> <p>The documentation for this class was generated from the following file <code>titan/comms/TitanComms/TitanComms.h</code></p>"},{"location":"TitanComms/classVL__NOT__FINAL/","title":"Class VL_NOT_FINAL","text":"<p>ClassList &gt; VL_NOT_FINAL</p> <p>Inherits the following classes: VerilatedModel</p>"},{"location":"TitanComms/classVL__NOT__FINAL/#public-attributes","title":"Public Attributes","text":"Type Name VL_IN &amp; in1 VL_IN &amp; in2 VL_IN &amp; in3 VL_IN &amp; in4 VL_OUT &amp; mux_o Vtop___024root *const rootp VL_IN8 &amp; sel_i"},{"location":"TitanComms/classVL__NOT__FINAL/#public-functions","title":"Public Functions","text":"Type Name Vtop (VerilatedContext * contextp, const char * name=\"TOP\")  Vtop (const char * name=\"TOP\")  void eval () Evaluate the model. Application must call when inputs change. void eval_end_step ()  void eval_step () Evaluate when calling multiple units/models per time step. bool eventsPending () Are there scheduled events to handle? void final () Simulation complete, run final blocks. Application must call on completion. const char * hierName () override const const char * modelName () override const const char * name () constRetrieve name of this model instance (as passed to constructor). uint64_t nextTimeSlot () Returns time at next time slot. Aborts if !eventsPending() unsigned threads () override const void trace (VerilatedVcdC * tfp, int levels, int options=0) Trace signals in the model; called by application code. std::unique_ptr&lt; VerilatedTraceConfig &gt; traceConfig () override const virtual ~Vtop () Destroy the model; called (often implicitly) by application code."},{"location":"TitanComms/classVL__NOT__FINAL/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"TitanComms/classVL__NOT__FINAL/#variable-in1","title":"variable in1","text":"<pre><code>VL_IN&amp; VL_NOT_FINAL::in1;\n</code></pre>"},{"location":"TitanComms/classVL__NOT__FINAL/#variable-in2","title":"variable in2","text":"<pre><code>VL_IN&amp; VL_NOT_FINAL::in2;\n</code></pre>"},{"location":"TitanComms/classVL__NOT__FINAL/#variable-in3","title":"variable in3","text":"<pre><code>VL_IN&amp; VL_NOT_FINAL::in3;\n</code></pre>"},{"location":"TitanComms/classVL__NOT__FINAL/#variable-in4","title":"variable in4","text":"<pre><code>VL_IN&amp; VL_NOT_FINAL::in4;\n</code></pre>"},{"location":"TitanComms/classVL__NOT__FINAL/#variable-mux_o","title":"variable mux_o","text":"<pre><code>VL_OUT&amp; VL_NOT_FINAL::mux_o;\n</code></pre>"},{"location":"TitanComms/classVL__NOT__FINAL/#variable-rootp","title":"variable rootp","text":"<pre><code>Vtop___024root* const VL_NOT_FINAL::rootp;\n</code></pre>"},{"location":"TitanComms/classVL__NOT__FINAL/#variable-sel_i","title":"variable sel_i","text":"<pre><code>VL_IN8&amp; VL_NOT_FINAL::sel_i;\n</code></pre>"},{"location":"TitanComms/classVL__NOT__FINAL/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"TitanComms/classVL__NOT__FINAL/#function-vtop-12","title":"function Vtop [1/2]","text":"<pre><code>explicit VL_NOT_FINAL::Vtop (\n    VerilatedContext * contextp,\n    const char * name=\"TOP\"\n) \n</code></pre> <p>Construct the model; called by application code If contextp is null, then the model will use the default global context If name is \"\", then makes a wrapper with a single model invisible with respect to DPI scope names. </p>"},{"location":"TitanComms/classVL__NOT__FINAL/#function-vtop-22","title":"function Vtop [2/2]","text":"<pre><code>explicit VL_NOT_FINAL::Vtop (\n    const char * name=\"TOP\"\n) \n</code></pre>"},{"location":"TitanComms/classVL__NOT__FINAL/#function-eval","title":"function eval","text":"<pre><code>inline void VL_NOT_FINAL::eval () \n</code></pre>"},{"location":"TitanComms/classVL__NOT__FINAL/#function-eval_end_step","title":"function eval_end_step","text":"<pre><code>void VL_NOT_FINAL::eval_end_step () \n</code></pre> <p>Evaluate at end of a timestep for tracing, when using eval_step(). Application must call after all eval() and before time changes. </p>"},{"location":"TitanComms/classVL__NOT__FINAL/#function-eval_step","title":"function eval_step","text":"<pre><code>void VL_NOT_FINAL::eval_step () \n</code></pre>"},{"location":"TitanComms/classVL__NOT__FINAL/#function-eventspending","title":"function eventsPending","text":"<pre><code>bool VL_NOT_FINAL::eventsPending () \n</code></pre>"},{"location":"TitanComms/classVL__NOT__FINAL/#function-final","title":"function final","text":"<pre><code>void VL_NOT_FINAL::final () \n</code></pre>"},{"location":"TitanComms/classVL__NOT__FINAL/#function-hiername","title":"function hierName","text":"<pre><code>const char * VL_NOT_FINAL::hierName () override const\n</code></pre>"},{"location":"TitanComms/classVL__NOT__FINAL/#function-modelname","title":"function modelName","text":"<pre><code>const char * VL_NOT_FINAL::modelName () override const\n</code></pre>"},{"location":"TitanComms/classVL__NOT__FINAL/#function-name","title":"function name","text":"<pre><code>const char * VL_NOT_FINAL::name () const\n</code></pre>"},{"location":"TitanComms/classVL__NOT__FINAL/#function-nexttimeslot","title":"function nextTimeSlot","text":"<pre><code>uint64_t VL_NOT_FINAL::nextTimeSlot () \n</code></pre>"},{"location":"TitanComms/classVL__NOT__FINAL/#function-threads","title":"function threads","text":"<pre><code>unsigned VL_NOT_FINAL::threads () override const\n</code></pre>"},{"location":"TitanComms/classVL__NOT__FINAL/#function-trace","title":"function trace","text":"<pre><code>void VL_NOT_FINAL::trace (\n    VerilatedVcdC * tfp,\n    int levels,\n    int options=0\n) \n</code></pre>"},{"location":"TitanComms/classVL__NOT__FINAL/#function-traceconfig","title":"function traceConfig","text":"<pre><code>std::unique_ptr&lt; VerilatedTraceConfig &gt; VL_NOT_FINAL::traceConfig () override const\n</code></pre>"},{"location":"TitanComms/classVL__NOT__FINAL/#function-vtop","title":"function ~Vtop","text":"<pre><code>virtual VL_NOT_FINAL::~Vtop () \n</code></pre> <p>The documentation for this class was generated from the following file <code>titan/comms/verilog/tests/sim_build/Vtop.h</code></p>"},{"location":"TitanComms/classVtop____Syms/","title":"Class Vtop__Syms","text":"<p>ClassList &gt; Vtop__Syms</p> <p>Inherits the following classes: VerilatedSyms</p>"},{"location":"TitanComms/classVtop____Syms/#public-attributes","title":"Public Attributes","text":"Type Name Vtop___024root TOP VerilatedHierarchy __Vhier bool __Vm_activity   = = falseTrace class for $dump*. uint32_t __Vm_baseCode   = = 0Used by trace routines when tracing multiple models. bool __Vm_didInit   = = false VerilatedMutex __Vm_dumperMutex bool __Vm_dumping   = = false Vtop *const __Vm_modelp VerilatedScope __Vscope_TOP VerilatedScope __Vscope_dut_param_mux VerilatedScope __Vscope_dut_param_mux__uut_pmux"},{"location":"TitanComms/classVtop____Syms/#public-functions","title":"Public Functions","text":"Type Name VerilatedVcdC *__Vm_dumperp VL_GUARDED_BY (__Vm_dumperMutex)  Vtop__Syms (VerilatedContext * contextp, const char * namep, Vtop * modelp)  void _traceDump ()  void _traceDumpClose ()  void _traceDumpOpen ()  const char * name ()  ~Vtop__Syms ()"},{"location":"TitanComms/classVtop____Syms/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"TitanComms/classVtop____Syms/#variable-top","title":"variable TOP","text":"<pre><code>Vtop___024root Vtop__Syms::TOP;\n</code></pre>"},{"location":"TitanComms/classVtop____Syms/#variable-__vhier","title":"variable __Vhier","text":"<pre><code>VerilatedHierarchy Vtop__Syms::__Vhier;\n</code></pre>"},{"location":"TitanComms/classVtop____Syms/#variable-__vm_activity","title":"variable __Vm_activity","text":"<p>Trace class for $dump*. <pre><code>bool Vtop__Syms::__Vm_activity;\n</code></pre></p> <p>Used by trace routines to determine change occurred </p>"},{"location":"TitanComms/classVtop____Syms/#variable-__vm_basecode","title":"variable __Vm_baseCode","text":"<pre><code>uint32_t Vtop__Syms::__Vm_baseCode;\n</code></pre>"},{"location":"TitanComms/classVtop____Syms/#variable-__vm_didinit","title":"variable __Vm_didInit","text":"<pre><code>bool Vtop__Syms::__Vm_didInit;\n</code></pre>"},{"location":"TitanComms/classVtop____Syms/#variable-__vm_dumpermutex","title":"variable __Vm_dumperMutex","text":"<pre><code>VerilatedMutex Vtop__Syms::__Vm_dumperMutex;\n</code></pre>"},{"location":"TitanComms/classVtop____Syms/#variable-__vm_dumping","title":"variable __Vm_dumping","text":"<pre><code>bool Vtop__Syms::__Vm_dumping;\n</code></pre>"},{"location":"TitanComms/classVtop____Syms/#variable-__vm_modelp","title":"variable __Vm_modelp","text":"<pre><code>Vtop* const Vtop__Syms::__Vm_modelp;\n</code></pre>"},{"location":"TitanComms/classVtop____Syms/#variable-__vscope_top","title":"variable __Vscope_TOP","text":"<pre><code>VerilatedScope Vtop__Syms::__Vscope_TOP;\n</code></pre>"},{"location":"TitanComms/classVtop____Syms/#variable-__vscope_dut_param_mux","title":"variable __Vscope_dut_param_mux","text":"<pre><code>VerilatedScope Vtop__Syms::__Vscope_dut_param_mux;\n</code></pre>"},{"location":"TitanComms/classVtop____Syms/#variable-__vscope_dut_param_mux__uut_pmux","title":"variable __Vscope_dut_param_mux__uut_pmux","text":"<pre><code>VerilatedScope Vtop__Syms::__Vscope_dut_param_mux__uut_pmux;\n</code></pre>"},{"location":"TitanComms/classVtop____Syms/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"TitanComms/classVtop____Syms/#function-vl_guarded_by","title":"function VL_GUARDED_BY","text":"<pre><code>VerilatedVcdC *__Vm_dumperp Vtop__Syms::VL_GUARDED_BY (\n    __Vm_dumperMutex\n) \n</code></pre>"},{"location":"TitanComms/classVtop____Syms/#function-vtop__syms","title":"function Vtop__Syms","text":"<pre><code>Vtop__Syms::Vtop__Syms (\n    VerilatedContext * contextp,\n    const char * namep,\n    Vtop * modelp\n) \n</code></pre>"},{"location":"TitanComms/classVtop____Syms/#function-_tracedump","title":"function _traceDump","text":"<pre><code>void Vtop__Syms::_traceDump () \n</code></pre>"},{"location":"TitanComms/classVtop____Syms/#function-_tracedumpclose","title":"function _traceDumpClose","text":"<pre><code>void Vtop__Syms::_traceDumpClose () \n</code></pre>"},{"location":"TitanComms/classVtop____Syms/#function-_tracedumpopen","title":"function _traceDumpOpen","text":"<pre><code>void Vtop__Syms::_traceDumpOpen () \n</code></pre>"},{"location":"TitanComms/classVtop____Syms/#function-name","title":"function name","text":"<pre><code>inline const char * Vtop__Syms::name () \n</code></pre>"},{"location":"TitanComms/classVtop____Syms/#function-vtop__syms_1","title":"function ~Vtop__Syms","text":"<pre><code>Vtop__Syms::~Vtop__Syms () \n</code></pre> <p>The documentation for this class was generated from the following file <code>titan/comms/verilog/tests/sim_build/Vtop__Syms.h</code></p>"},{"location":"TitanComms/classVtop______024root/","title":"Class Vtop___024root","text":"<p>ClassList &gt; Vtop___024root</p> <p>Inherits the following classes: VerilatedModule</p>"},{"location":"TitanComms/classVtop______024root/#public-attributes","title":"Public Attributes","text":"Type Name CData __VactContinue IData __VactIterCount VlTriggerVec&lt; 1 &gt; __VactTriggered VlDelayScheduler __VdlySched IData __VicoIterCount VlTriggerVec&lt; 1 &gt; __VicoTriggered VlTriggerVec&lt; 1 &gt; __VnbaTriggered IData __VstlIterCount VlTriggerVec&lt; 1 &gt; __VstlTriggered VlUnpacked&lt; IData, 4 &gt; dut_param_mux__DOT____Vcellinp__uut_pmux__inputs IData dut_param_mux__DOT__in1 IData dut_param_mux__DOT__in2 IData dut_param_mux__DOT__in3 IData dut_param_mux__DOT__in4 IData dut_param_mux__DOT__mux_o CData dut_param_mux__DOT__sel_i VlUnpacked&lt; IData, 4 &gt; dut_param_mux__DOT__uut_pmux__DOT__inputs IData dut_param_mux__DOT__uut_pmux__DOT__out CData dut_param_mux__DOT__uut_pmux__DOT__selector Vtop__Syms *const vlSymsp"},{"location":"TitanComms/classVtop______024root/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr IData dut_param_mux__DOT__uut_pmux__DOT__INPUT_WIDTH   = = 0x00000020U constexpr IData dut_param_mux__DOT__uut_pmux__DOT__SELECTOR_WIDTH   = = 2U constexpr IData dut_param_mux__DOT__uut_pmux__DOT__SIGNAL_COUNT   = = 4U"},{"location":"TitanComms/classVtop______024root/#public-functions","title":"Public Functions","text":"Type Name VL_IN (in1, 31, 0)  VL_IN (in2, 31, 0)  VL_IN (in3, 31, 0)  VL_IN (in4, 31, 0)  VL_IN8 (sel_i, 1, 0)  VL_OUT (mux_o, 31, 0)  VL_UNCOPYABLE (Vtop___024root)  Vtop___024root (Vtop__Syms * symsp, const char * v__name)  void __Vconfigure (bool first)  ~Vtop___024root ()"},{"location":"TitanComms/classVtop______024root/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"TitanComms/classVtop______024root/#variable-__vactcontinue","title":"variable __VactContinue","text":"<pre><code>CData Vtop___024root::__VactContinue;\n</code></pre>"},{"location":"TitanComms/classVtop______024root/#variable-__vactitercount","title":"variable __VactIterCount","text":"<pre><code>IData Vtop___024root::__VactIterCount;\n</code></pre>"},{"location":"TitanComms/classVtop______024root/#variable-__vacttriggered","title":"variable __VactTriggered","text":"<pre><code>VlTriggerVec&lt;1&gt; Vtop___024root::__VactTriggered;\n</code></pre>"},{"location":"TitanComms/classVtop______024root/#variable-__vdlysched","title":"variable __VdlySched","text":"<pre><code>VlDelayScheduler Vtop___024root::__VdlySched;\n</code></pre>"},{"location":"TitanComms/classVtop______024root/#variable-__vicoitercount","title":"variable __VicoIterCount","text":"<pre><code>IData Vtop___024root::__VicoIterCount;\n</code></pre>"},{"location":"TitanComms/classVtop______024root/#variable-__vicotriggered","title":"variable __VicoTriggered","text":"<pre><code>VlTriggerVec&lt;1&gt; Vtop___024root::__VicoTriggered;\n</code></pre>"},{"location":"TitanComms/classVtop______024root/#variable-__vnbatriggered","title":"variable __VnbaTriggered","text":"<pre><code>VlTriggerVec&lt;1&gt; Vtop___024root::__VnbaTriggered;\n</code></pre>"},{"location":"TitanComms/classVtop______024root/#variable-__vstlitercount","title":"variable __VstlIterCount","text":"<pre><code>IData Vtop___024root::__VstlIterCount;\n</code></pre>"},{"location":"TitanComms/classVtop______024root/#variable-__vstltriggered","title":"variable __VstlTriggered","text":"<pre><code>VlTriggerVec&lt;1&gt; Vtop___024root::__VstlTriggered;\n</code></pre>"},{"location":"TitanComms/classVtop______024root/#variable-dut_param_mux__dot____vcellinp__uut_pmux__inputs","title":"variable dut_param_mux__DOT____Vcellinp__uut_pmux__inputs","text":"<pre><code>VlUnpacked&lt;IData, 4&gt; Vtop___024root::dut_param_mux__DOT____Vcellinp__uut_pmux__inputs;\n</code></pre>"},{"location":"TitanComms/classVtop______024root/#variable-dut_param_mux__dot__in1","title":"variable dut_param_mux__DOT__in1","text":"<pre><code>IData Vtop___024root::dut_param_mux__DOT__in1;\n</code></pre>"},{"location":"TitanComms/classVtop______024root/#variable-dut_param_mux__dot__in2","title":"variable dut_param_mux__DOT__in2","text":"<pre><code>IData Vtop___024root::dut_param_mux__DOT__in2;\n</code></pre>"},{"location":"TitanComms/classVtop______024root/#variable-dut_param_mux__dot__in3","title":"variable dut_param_mux__DOT__in3","text":"<pre><code>IData Vtop___024root::dut_param_mux__DOT__in3;\n</code></pre>"},{"location":"TitanComms/classVtop______024root/#variable-dut_param_mux__dot__in4","title":"variable dut_param_mux__DOT__in4","text":"<pre><code>IData Vtop___024root::dut_param_mux__DOT__in4;\n</code></pre>"},{"location":"TitanComms/classVtop______024root/#variable-dut_param_mux__dot__mux_o","title":"variable dut_param_mux__DOT__mux_o","text":"<pre><code>IData Vtop___024root::dut_param_mux__DOT__mux_o;\n</code></pre>"},{"location":"TitanComms/classVtop______024root/#variable-dut_param_mux__dot__sel_i","title":"variable dut_param_mux__DOT__sel_i","text":"<pre><code>CData Vtop___024root::dut_param_mux__DOT__sel_i;\n</code></pre>"},{"location":"TitanComms/classVtop______024root/#variable-dut_param_mux__dot__uut_pmux__dot__inputs","title":"variable dut_param_mux__DOT__uut_pmux__DOT__inputs","text":"<pre><code>VlUnpacked&lt;IData, 4&gt; Vtop___024root::dut_param_mux__DOT__uut_pmux__DOT__inputs;\n</code></pre>"},{"location":"TitanComms/classVtop______024root/#variable-dut_param_mux__dot__uut_pmux__dot__out","title":"variable dut_param_mux__DOT__uut_pmux__DOT__out","text":"<pre><code>IData Vtop___024root::dut_param_mux__DOT__uut_pmux__DOT__out;\n</code></pre>"},{"location":"TitanComms/classVtop______024root/#variable-dut_param_mux__dot__uut_pmux__dot__selector","title":"variable dut_param_mux__DOT__uut_pmux__DOT__selector","text":"<pre><code>CData Vtop___024root::dut_param_mux__DOT__uut_pmux__DOT__selector;\n</code></pre>"},{"location":"TitanComms/classVtop______024root/#variable-vlsymsp","title":"variable vlSymsp","text":"<pre><code>Vtop__Syms* const Vtop___024root::vlSymsp;\n</code></pre>"},{"location":"TitanComms/classVtop______024root/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"TitanComms/classVtop______024root/#variable-dut_param_mux__dot__uut_pmux__dot__input_width","title":"variable dut_param_mux__DOT__uut_pmux__DOT__INPUT_WIDTH","text":"<pre><code>constexpr IData Vtop___024root::dut_param_mux__DOT__uut_pmux__DOT__INPUT_WIDTH;\n</code></pre>"},{"location":"TitanComms/classVtop______024root/#variable-dut_param_mux__dot__uut_pmux__dot__selector_width","title":"variable dut_param_mux__DOT__uut_pmux__DOT__SELECTOR_WIDTH","text":"<pre><code>constexpr IData Vtop___024root::dut_param_mux__DOT__uut_pmux__DOT__SELECTOR_WIDTH;\n</code></pre>"},{"location":"TitanComms/classVtop______024root/#variable-dut_param_mux__dot__uut_pmux__dot__signal_count","title":"variable dut_param_mux__DOT__uut_pmux__DOT__SIGNAL_COUNT","text":"<pre><code>constexpr IData Vtop___024root::dut_param_mux__DOT__uut_pmux__DOT__SIGNAL_COUNT;\n</code></pre>"},{"location":"TitanComms/classVtop______024root/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"TitanComms/classVtop______024root/#function-vl_in-14","title":"function VL_IN [1/4]","text":"<pre><code>Vtop___024root::VL_IN (\n    in1,\n    31,\n    0\n) \n</code></pre>"},{"location":"TitanComms/classVtop______024root/#function-vl_in-24","title":"function VL_IN [2/4]","text":"<pre><code>Vtop___024root::VL_IN (\n    in2,\n    31,\n    0\n) \n</code></pre>"},{"location":"TitanComms/classVtop______024root/#function-vl_in-34","title":"function VL_IN [3/4]","text":"<pre><code>Vtop___024root::VL_IN (\n    in3,\n    31,\n    0\n) \n</code></pre>"},{"location":"TitanComms/classVtop______024root/#function-vl_in-44","title":"function VL_IN [4/4]","text":"<pre><code>Vtop___024root::VL_IN (\n    in4,\n    31,\n    0\n) \n</code></pre>"},{"location":"TitanComms/classVtop______024root/#function-vl_in8","title":"function VL_IN8","text":"<pre><code>Vtop___024root::VL_IN8 (\n    sel_i,\n    1,\n    0\n) \n</code></pre>"},{"location":"TitanComms/classVtop______024root/#function-vl_out","title":"function VL_OUT","text":"<pre><code>Vtop___024root::VL_OUT (\n    mux_o,\n    31,\n    0\n) \n</code></pre>"},{"location":"TitanComms/classVtop______024root/#function-vl_uncopyable","title":"function VL_UNCOPYABLE","text":"<pre><code>Vtop___024root::VL_UNCOPYABLE (\n    Vtop___024root\n) \n</code></pre>"},{"location":"TitanComms/classVtop______024root/#function-vtop___024root","title":"function Vtop___024root","text":"<pre><code>Vtop___024root::Vtop___024root (\n    Vtop__Syms * symsp,\n    const char * v__name\n) \n</code></pre>"},{"location":"TitanComms/classVtop______024root/#function-__vconfigure","title":"function __Vconfigure","text":"<pre><code>void Vtop___024root::__Vconfigure (\n    bool first\n) \n</code></pre>"},{"location":"TitanComms/classVtop______024root/#function-vtop___024root_1","title":"function ~Vtop___024root","text":"<pre><code>Vtop___024root::~Vtop___024root () \n</code></pre> <p>The documentation for this class was generated from the following file <code>titan/comms/verilog/tests/sim_build/Vtop___024root.h</code></p>"},{"location":"TitanComms/classVtop______024unit/","title":"Class Vtop___024unit","text":"<p>ClassList &gt; Vtop___024unit</p> <p>Inherits the following classes: VerilatedModule</p>"},{"location":"TitanComms/classVtop______024unit/#public-attributes","title":"Public Attributes","text":"Type Name Vtop__Syms *const vlSymsp"},{"location":"TitanComms/classVtop______024unit/#public-functions","title":"Public Functions","text":"Type Name VL_UNCOPYABLE (Vtop___024unit)  Vtop___024unit (Vtop__Syms * symsp, const char * v__name)  void __Vconfigure (bool first)  ~Vtop___024unit ()"},{"location":"TitanComms/classVtop______024unit/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"TitanComms/classVtop______024unit/#variable-vlsymsp","title":"variable vlSymsp","text":"<pre><code>Vtop__Syms* const Vtop___024unit::vlSymsp;\n</code></pre>"},{"location":"TitanComms/classVtop______024unit/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"TitanComms/classVtop______024unit/#function-vl_uncopyable","title":"function VL_UNCOPYABLE","text":"<pre><code>Vtop___024unit::VL_UNCOPYABLE (\n    Vtop___024unit\n) \n</code></pre>"},{"location":"TitanComms/classVtop______024unit/#function-vtop___024unit","title":"function Vtop___024unit","text":"<pre><code>Vtop___024unit::Vtop___024unit (\n    Vtop__Syms * symsp,\n    const char * v__name\n) \n</code></pre>"},{"location":"TitanComms/classVtop______024unit/#function-__vconfigure","title":"function __Vconfigure","text":"<pre><code>void Vtop___024unit::__Vconfigure (\n    bool first\n) \n</code></pre>"},{"location":"TitanComms/classVtop______024unit/#function-vtop___024unit_1","title":"function ~Vtop___024unit","text":"<pre><code>Vtop___024unit::~Vtop___024unit () \n</code></pre> <p>The documentation for this class was generated from the following file <code>titan/comms/verilog/tests/sim_build/Vtop___024unit.h</code></p>"},{"location":"TitanComms/dir_eedd3c7d49ee25ac76e1232870c4d0af/","title":"Dir titan","text":"<p>FileList &gt; titan</p>"},{"location":"TitanComms/dir_eedd3c7d49ee25ac76e1232870c4d0af/#directories","title":"Directories","text":"Type Name dir comms <p>The documentation for this class was generated from the following file <code>titan/</code></p>"},{"location":"TitanComms/dir_15e9a61cbc095141a3f886f43eb6818f/","title":"Dir titan/comms","text":"<p>FileList &gt; comms</p>"},{"location":"TitanComms/dir_15e9a61cbc095141a3f886f43eb6818f/#directories","title":"Directories","text":"Type Name dir TitanComms dir verilog <p>The documentation for this class was generated from the following file <code>titan/comms/</code></p>"},{"location":"TitanComms/dir_5bea15bd51704c26ebfcf0ce33d5c553/","title":"Dir titan/comms/TitanComms","text":"<p>FileList &gt; comms &gt; TitanComms</p>"},{"location":"TitanComms/dir_5bea15bd51704c26ebfcf0ce33d5c553/#files","title":"Files","text":"Type Name file TitanComms.cpp file TitanComms.h file TitanCommsDebug.h <p>The documentation for this class was generated from the following file <code>titan/comms/TitanComms/</code></p>"},{"location":"TitanComms/TitanComms_8cpp/","title":"File TitanComms.cpp","text":"<p>FileList &gt; comms &gt; TitanComms &gt; TitanComms.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Arduino.h\"</code></li> <li><code>#include \"TitanComms.h\"</code></li> <li><code>#include \"TitanCommsDebug.h\"</code></li> <li><code>#include \"SPI.h\"</code></li> </ul>"},{"location":"TitanComms/TitanComms_8cpp/#macros","title":"Macros","text":"Type Name define DEBUG"},{"location":"TitanComms/TitanComms_8cpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"TitanComms/TitanComms_8cpp/#define-debug","title":"define DEBUG","text":"<pre><code>#define DEBUG \n</code></pre> <p>The documentation for this class was generated from the following file <code>titan/comms/TitanComms/TitanComms.cpp</code></p>"},{"location":"TitanComms/TitanComms_8cpp_source/","title":"File TitanComms.cpp","text":"<p>File List &gt; comms &gt; TitanComms &gt; TitanComms.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n    TitanComms.cpp - Library/wrapper intended to help with communicating with\n                     Titan-created function blocks via the Titan Compiler (or \n                     any SPI-connected device that implements its protocol).\n*/\n#define DEBUG\n\n#include \"Arduino.h\"\n#include \"TitanComms.h\"\n#include \"TitanCommsDebug.h\"\n#include \"SPI.h\"\n\n// constructor\n#if defined(ARDUINO_TEENSY32)\n    TitanComms::TitanComms(int cs_pin, SPISettings spi_settings){\n        _cs_pin = cs_pin;\n        _spi_settings = spi_settings;\n        // _spi = SPI; // unneeded?\n    }\n#elif defined(ARDUINO_ARCH_RP2040)\n    TitanComms::TitanComms(int MISO, int MOSI, int CS, int SCLK, SPISettings spi_settings){\n        _cs_pin = CS;\n        _miso = MISO;\n        _mosi = MOSI;\n        _sclk = SCLK;\n        _spi_settings = spi_settings;\n\n        _spi = new arduino::MbedSPI(MISO, MOSI, SCLK);\n    }\n#endif\n\nvoid TitanComms::_chip_select(){\n    digitalWrite(_cs_pin, LOW);\n}\n\nvoid TitanComms::_chip_deselect(){\n    digitalWrite(_cs_pin, HIGH);\n}\n\nvoid TitanComms::begin(){\n    pinMode(_cs_pin, OUTPUT);\n    digitalWrite(_cs_pin, HIGH); // cs is active low, so setting to high means its disabled\n    _spi-&gt;begin();\n}\n\nvoid TitanComms::_extract_byte_from_int(u_int24 data, int byte_index, u_int8_t* storage_byte){\n    // byte_index should be either 0, 1 or 2\n    // byte_index:     2           1           0\n    // 24b number: xxxx xxxx | xxxx xxxx | xxxx xxxx\n    // byte mask:  1000 0000   0000 0000   0000 0000 -- 0x800000\n    //             0000 0000   1000 0000   0000 0000 -- 0x008000\n    //             0000 0000   0000 0000   1000 0000 -- 0x000080\n\n    u_int32_t byte_mask = 0x800000 &gt;&gt; (8 * byte_index);\n    u_int8_t new_byte;\n\n    int upper_limit = 7 + (8 * byte_index);\n    int lower_limit = 0 + (8 * byte_index);\n\n    int normal_pos = 0; // i is relative to the incoming value, it needs to be translated to the new byte\n    for (int i = lower_limit; i &lt; upper_limit + 1; i++){\n        if (bitRead(data.data, i)) {\n            bitSet(new_byte, normal_pos);\n        } else {\n            bitClear(new_byte, normal_pos);\n        }\n\n        normal_pos++;\n    }\n\n    *storage_byte = new_byte;\n}\n\nvoid TitanComms::write(u_int24 address, u_int32_t value){\n    byte addr_high, addr_mid, addr_low = 0;\n\n    _extract_byte_from_int(address, 0, &amp;addr_low);\n    _extract_byte_from_int(address, 1, &amp;addr_mid);\n    _extract_byte_from_int(address, 2, &amp;addr_high);\n\n    u_int16_t merged_instr_addr_high = (WRITE &lt;&lt; 8) + addr_high; // instruction + address high byte (16b)\n    u_int16_t addr_mid_and_low = (addr_mid &lt;&lt; 8) + addr_low; // address mid byte + address low byte (16b)\n    u_int16_t upper_data = (value &gt;&gt; 16);\n    u_int16_t lower_data = value; // auto truncated?\n\n\n    _spi-&gt;beginTransaction(_spi_settings);\n    _chip_select();\n    _spi-&gt;transfer16(merged_instr_addr_high);\n    _spi-&gt;transfer16(addr_mid_and_low);\n    _spi-&gt;transfer16(upper_data);\n    _spi-&gt;transfer16(lower_data);\n    _chip_deselect();\n    _spi-&gt;endTransaction();\n\n    // DEBUG_PRINT_STR(\"---L \"); DEBUG_PRINT_HEX(addr_low); DEBUG_PRINTLN();\n    // DEBUG_PRINT_STR(\"---M \"); DEBUG_PRINT_HEX(addr_mid); DEBUG_PRINTLN();\n    // DEBUG_PRINT_STR(\"---H \"); DEBUG_PRINT_HEX(addr_high);  DEBUG_PRINTLN();\n}\n\nbyte TitanComms::_nop_and_read8(){\n    byte temp = _spi-&gt;transfer(TRANSFER);\n    return temp;\n}\n\nu_int16_t TitanComms::_nop_and_read16(){\n    // pack byte instruction into a 2 byte one\n    // i.e. INSTRUCTION = 0x01\n    // formatted = 0x0101 etc\n    u_int16_t temp = _spi-&gt;transfer16(((TRANSFER &lt;&lt; 8) + TRANSFER));\n    return temp;\n}\n\nvoid TitanComms::_repeat() {\n    _spi-&gt;beginTransaction(_spi_settings);\n    _chip_select();\n    _spi-&gt;transfer(REPEAT);\n    _chip_deselect();\n    _spi-&gt;endTransaction();\n}\n\n\nu_int32_t TitanComms::read(u_int24 address){\n    // send: instruction + address --&gt; 8 bits + 24 bits\n    // recieve: value + checksum --&gt; 32 bits + 8 bits\n\n    u_int8_t addr_high;\n    _extract_byte_from_int(address, 2, &amp;addr_high); // should get the highest byte from address\n\n    u_int16_t merged_instr_addr_high = (READ &lt;&lt; 8) + addr_high;\n    u_int16_t addr_mid_and_low = address.data;\n\n    u_int16_t value_high, value_low;\n    u_int8_t recieved_checksum, calculated_checksum;\n\n\n    _spi-&gt;beginTransaction(_spi_settings);\n\n    _chip_select();\n    _spi-&gt;transfer16(merged_instr_addr_high);\n    _spi-&gt;transfer16(addr_mid_and_low);\n\n    value_high = _nop_and_read16();\n    value_low = _nop_and_read16();\n\n    // TODO: checksum, and repeating if necessary\n    // recieved_checksum = _nop_and_read8();\n\n    _chip_deselect();\n    _spi-&gt;endTransaction();\n\n    u_int32_t final_val = (value_high &lt;&lt; 16) + value_low;\n\n    return final_val;\n}\n\nu_int32_t TitanComms::stream(u_int32_t value){\n    u_int16_t ans1, ans2;\n\n    _spi-&gt;beginTransaction(_spi_settings);\n    _chip_select();\n    _spi-&gt;transfer((u_int8_t)STREAM);\n    ans1 = _spi-&gt;transfer16(value &gt;&gt; 16);\n    ans2 = _spi-&gt;transfer16((u_int16_t)value);\n    _chip_deselect();\n    _spi-&gt;endTransaction();\n\n    // DEBUG_PRINT_STR(\"[stream (rx)]: \");\n    // DEBUG_PRINT_HEX(ans1); DEBUG_PRINT_STR(\" \");\n    // DEBUG_PRINT_HEX(ans2); DEBUG_PRINT_STR(\" \");\n    // DEBUG_PRINT_HEX(ans3); DEBUG_PRINTLN();\n\n    return (u_int32_t) ((ans1 &lt;&lt; 16) + ans2);\n}\n\n// void TitanComms::bind_address(u_int24 address){\n//     u_int16_t instr_addr_hi = (BIND_ADDRESS) &lt;&lt; 8 + (address.data &gt;&gt; 16);\n\n//     DEBUG_PRINT_HEX(instr_addr_hi); DEBUG_PRINT_STR(\" \");\n//     DEBUG_PRINT_HEX((uint16_t)address.data); DEBUG_PRINTLN();\n\n//     _spi-&gt;beginTransaction(_spi_settings);\n//     _chip_select();\n//     _spi-&gt;transfer16(instr_addr_hi);\n//     _spi-&gt;transfer16((uint16_t)address.data);\n//     _chip_deselect();\n//     _spi-&gt;endTransaction();\n// }\n\nvoid TitanComms::set_stream_read_address(u_int32_t address){\n    u_int16_t instr_addr_hi = (BIND_READ_ADDRESS &lt;&lt; 8) + ((address &lt;&lt; 8) &gt;&gt; 24);\n    u_int16_t addr_mid_lo = address;\n\n    _spi-&gt;beginTransaction(_spi_settings);\n    _chip_select();\n    _spi-&gt;transfer16(instr_addr_hi);\n    _spi-&gt;transfer16(addr_mid_lo);\n    _chip_deselect();\n    _spi-&gt;endTransaction();\n}\n\nvoid TitanComms::set_stream_write_address(u_int32_t address){\n    u_int16_t instr_addr_hi = (BIND_WRITE_ADDRESS &lt;&lt; 8) + ((address &lt;&lt; 8) &gt;&gt; 24);\n    u_int16_t addr_mid_lo = address;\n\n    DEBUG_PRINT_STR(\"[set_stream_write_address] \");\n    DEBUG_PRINT_HEX(instr_addr_hi); DEBUG_PRINT_STR(\" \"); DEBUG_PRINT_HEX(addr_mid_lo);\n    DEBUG_PRINTLN();\n\n    _spi-&gt;beginTransaction(_spi_settings);\n    _chip_select();\n    _spi-&gt;transfer16(instr_addr_hi);\n    _spi-&gt;transfer16(addr_mid_lo);\n    _chip_deselect();\n    _spi-&gt;endTransaction();\n}\n\nvoid TitanComms::set_core_interrupt(u_int24 address){\n    u_int8_t addr_hi;\n    _extract_byte_from_int(address, 2, &amp;addr_hi);\n\n    u_int16_t merged_instr_addr_hi = (BIND_INTERRUPT &lt;&lt; 8) + addr_hi;\n    u_int16_t addr_mid_lo = address.data;\n\n    _spi-&gt;beginTransaction(_spi_settings);\n    _chip_select();\n    _spi-&gt;transfer16(merged_instr_addr_hi);\n    _spi-&gt;transfer16(addr_mid_lo);\n    _chip_deselect();\n    _spi-&gt;endTransaction();\n}\n</code></pre>"},{"location":"TitanComms/TitanComms_8h/","title":"File TitanComms.h","text":"<p>FileList &gt; comms &gt; TitanComms &gt; TitanComms.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Arduino.h\"</code></li> <li><code>#include \"SPI.h\"</code></li> </ul>"},{"location":"TitanComms/TitanComms_8h/#classes","title":"Classes","text":"Type Name class TitanComms struct u_int24 <p>The documentation for this class was generated from the following file <code>titan/comms/TitanComms/TitanComms.h</code></p>"},{"location":"TitanComms/TitanComms_8h_source/","title":"File TitanComms.h","text":"<p>File List &gt; comms &gt; TitanComms &gt; TitanComms.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n    TitanComms.h - Library/wrapper intended to help with communicating with\n                   Titan-created function blocks via the Titan Compiler (or \n                   any SPI-connected device that implements its protocol).\n*/\n#ifndef TitanComms_h\n#define TitanComms_h\n\n#include \"Arduino.h\"\n#include \"SPI.h\"\n\nclass TitanComms {\n    public:\n        #if !defined(ARDUINO_ARCH_RP2040)\n            TitanComms(int cs_pin, SPISettings spi_settings); // pass cs &amp; spi settings?\n        #elif defined(ARDUINO_ARCH_RP2040)\n            TitanComms(int MISO, int MOSI, int CS, int SCLK, SPISettings spi_settings);\n        #else\n            #error \"unsupported target\"\n        #endif\n\n        enum instruction {\n            NOP = 0x00,\n            WRITE = 0x01,\n            READ = 0x02,\n            STREAM = 0x03,\n            BIND_INTERRUPT = 0x04,\n            BIND_READ_ADDRESS = 0x05,\n            BIND_WRITE_ADDRESS = 0x06,\n            TRANSFER = 0x07,\n            REPEAT = 0x08,\n            GET_METADATA = 0xFF\n        };\n\n        struct u_int24 {\n            u_int32_t data : 24;\n        };\n        void begin(); // handles hardware config\n        u_int32_t read(u_int24 address);\n        void write(u_int24 address, u_int32_t value);\n        u_int32_t stream(u_int32_t value);\n        void set_stream_write_address(u_int32_t address);\n        void set_stream_read_address(u_int32_t address);\n\n        // do not use\n        void bind_address(u_int24 address);\n        void set_core_interrupt(u_int24 address);\n    private:\n        int _cs_pin;\n        SPISettings _spi_settings;\n        u_int8_t _nop_and_read8();\n        u_int16_t _nop_and_read16();\n        void _repeat();\n        void _extract_byte_from_int(u_int24 data, int byte_index, u_int8_t* storage_byte);\n        void _chip_select();\n        void _chip_deselect();\n        u_int8_t _xor_checksum(u_int32_t input);\n\n        // create different class depending on target architecture\n        //              v extract from verbose compilation\n        // target rpi: ARDUINO_ARCH_RP2040\n        // target teensy3.2: ARDUINO_TEENSY32\n        #if defined(ARDUINO_TEENSY32)\n            SPIClass *_spi;\n        #elif defined(ARDUINO_ARCH_RP2040)\n            arduino::MbedSPI *_spi;\n            int _miso, _mosi, _sclk;\n        #else\n            #error \"unsupported target\"\n        #endif\n};\n\n#endif\n</code></pre>"},{"location":"TitanComms/TitanCommsDebug_8h/","title":"File TitanCommsDebug.h","text":"<p>FileList &gt; comms &gt; TitanComms &gt; TitanCommsDebug.h</p> <p>Go to the source code of this file</p>"},{"location":"TitanComms/TitanCommsDebug_8h/#macros","title":"Macros","text":"Type Name define DEBUG_PRINT (x)  define DEBUG_PRINTLN ()  define DEBUG_PRINTLN_STR (x)  define DEBUG_PRINT_BIN (x)  define DEBUG_PRINT_HEX (x)  define DEBUG_PRINT_INT (x)  define DEBUG_PRINT_SIZEOF (x)  define DEBUG_PRINT_STR (x)"},{"location":"TitanComms/TitanCommsDebug_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"TitanComms/TitanCommsDebug_8h/#define-debug_print","title":"define DEBUG_PRINT","text":"<pre><code>#define DEBUG_PRINT (\n    x\n) \n</code></pre>"},{"location":"TitanComms/TitanCommsDebug_8h/#define-debug_println","title":"define DEBUG_PRINTLN","text":"<pre><code>#define DEBUG_PRINTLN (\n\n) \n</code></pre>"},{"location":"TitanComms/TitanCommsDebug_8h/#define-debug_println_str","title":"define DEBUG_PRINTLN_STR","text":"<pre><code>#define DEBUG_PRINTLN_STR (\n    x\n) \n</code></pre>"},{"location":"TitanComms/TitanCommsDebug_8h/#define-debug_print_bin","title":"define DEBUG_PRINT_BIN","text":"<pre><code>#define DEBUG_PRINT_BIN (\n    x\n) \n</code></pre>"},{"location":"TitanComms/TitanCommsDebug_8h/#define-debug_print_hex","title":"define DEBUG_PRINT_HEX","text":"<pre><code>#define DEBUG_PRINT_HEX (\n    x\n) \n</code></pre>"},{"location":"TitanComms/TitanCommsDebug_8h/#define-debug_print_int","title":"define DEBUG_PRINT_INT","text":"<pre><code>#define DEBUG_PRINT_INT (\n    x\n) \n</code></pre>"},{"location":"TitanComms/TitanCommsDebug_8h/#define-debug_print_sizeof","title":"define DEBUG_PRINT_SIZEOF","text":"<pre><code>#define DEBUG_PRINT_SIZEOF (\n    x\n) \n</code></pre>"},{"location":"TitanComms/TitanCommsDebug_8h/#define-debug_print_str","title":"define DEBUG_PRINT_STR","text":"<pre><code>#define DEBUG_PRINT_STR (\n    x\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>titan/comms/TitanComms/TitanCommsDebug.h</code></p>"},{"location":"TitanComms/TitanCommsDebug_8h_source/","title":"File TitanCommsDebug.h","text":"<p>File List &gt; comms &gt; TitanComms &gt; TitanCommsDebug.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifdef DEBUG\n    #define DEBUG_PRINT_VALUE(x) \\\n        Serial.print(x); \\\n        Serial.print(\" as hex: \"); \\\n        Serial.print(x, HEX); \\\n        Serial.print(\" , as bin: \"); \\\n        Serial.print(x, BIN); \\\n        Serial.println();\n\n    #define DEBUG_PRINT_STR(x) Serial.print(x);\n    #define DEBUG_PRINTLN() Serial.println();\n    #define DEBUG_PRINTLN_STR(x) Serial.println(x);\n    #define DEBUG_PRINT_HEX(x) Serial.print(x, HEX);\n    #define DEBUG_PRINT_INT(x) Serial.print(x);\n    #define DEBUG_PRINT_BIN(x) Serial.print(x, BIN);\n    #define DEBUG_PRINT_SIZEOF(x) Serial.print(sizeof(x));\n\n#else\n    #define DEBUG_PRINT(x)\n    #define DEBUG_PRINT_STR(x)\n    #define DEBUG_PRINTLN()\n    #define DEBUG_PRINTLN_STR(x)\n    #define DEBUG_PRINT_HEX(x)\n    #define DEBUG_PRINT_INT(x)\n    #define DEBUG_PRINT_BIN(x)\n    #define DEBUG_PRINT_SIZEOF(x)\n#endif\n</code></pre>"},{"location":"TitanComms/dir_549b42112f6dc36cf8af5f13bada3f17/","title":"Dir titan/comms/verilog","text":"<p>FileList &gt; comms &gt; verilog</p>"},{"location":"TitanComms/dir_549b42112f6dc36cf8af5f13bada3f17/#directories","title":"Directories","text":"Type Name dir tests <p>The documentation for this class was generated from the following file <code>titan/comms/verilog/</code></p>"},{"location":"TitanComms/dir_359bc3875cb3adaee3d3f269dbe0d6e4/","title":"Dir titan/comms/verilog/tests","text":"<p>FileList &gt; comms &gt; verilog &gt; tests</p>"},{"location":"TitanComms/dir_359bc3875cb3adaee3d3f269dbe0d6e4/#directories","title":"Directories","text":"Type Name dir sim_build <p>The documentation for this class was generated from the following file <code>titan/comms/verilog/tests/</code></p>"},{"location":"TitanComms/dir_816ed350c72cf5de8127e0b7e8b74e54/","title":"Dir titan/comms/verilog/tests/sim_build","text":"<p>FileList &gt; comms &gt; verilog &gt; tests &gt; sim_build</p>"},{"location":"TitanComms/dir_816ed350c72cf5de8127e0b7e8b74e54/#files","title":"Files","text":"Type Name file Vtop.cpp file Vtop.h file Vtop__ALL.cpp file Vtop__Dpi.cpp file Vtop__Dpi.h file Vtop__Syms.cpp file Vtop__Syms.h file Vtop__Trace__0.cpp file Vtop__Trace__0__Slow.cpp file Vtop___024root.h file Vtop___024root__DepSet_h84412442__0.cpp file Vtop___024root__DepSet_h84412442__0__Slow.cpp file Vtop___024root__DepSet_heccd7ead__0.cpp file Vtop___024root__DepSet_heccd7ead__0__Slow.cpp file Vtop___024root__Slow.cpp file Vtop___024unit.h file Vtop___024unit__DepSet_hff17caec__0__Slow.cpp file Vtop___024unit__Slow.cpp <p>The documentation for this class was generated from the following file <code>titan/comms/verilog/tests/sim_build/</code></p>"},{"location":"TitanComms/Vtop_8cpp/","title":"File Vtop.cpp","text":"<p>FileList &gt; comms &gt; verilog &gt; tests &gt; sim_build &gt; Vtop.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Vtop.h\"</code></li> <li><code>#include \"Vtop__Syms.h\"</code></li> <li><code>#include \"verilated_vcd_c.h\"</code></li> <li><code>#include \"verilated_dpi.h\"</code></li> </ul>"},{"location":"TitanComms/Vtop_8cpp/#public-functions","title":"Public Functions","text":"Type Name void Vtop___024root___eval (Vtop___024root * vlSelf)  void Vtop___024root___eval_final (Vtop___024root * vlSelf)  void Vtop___024root___eval_initial (Vtop___024root * vlSelf)  void Vtop___024root___eval_settle (Vtop___024root * vlSelf)  void Vtop___024root___eval_static (Vtop___024root * vlSelf)  void Vtop___024root__trace_init_top (Vtop___024root * vlSelf, VerilatedVcd * tracep)  VL_ATTR_COLD void Vtop___024root__trace_register (Vtop___024root * vlSelf, VerilatedVcd * tracep)"},{"location":"TitanComms/Vtop_8cpp/#public-static-functions","title":"Public Static Functions","text":"Type Name VL_ATTR_COLD void trace_init (void * voidSelf, VerilatedVcd * tracep, uint32_t code)"},{"location":"TitanComms/Vtop_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"TitanComms/Vtop_8cpp/#function-vtop___024root___eval","title":"function Vtop___024root___eval","text":"<pre><code>void Vtop___024root___eval (\n    Vtop___024root * vlSelf\n) \n</code></pre>"},{"location":"TitanComms/Vtop_8cpp/#function-vtop___024root___eval_final","title":"function Vtop___024root___eval_final","text":"<pre><code>void Vtop___024root___eval_final (\n    Vtop___024root * vlSelf\n) \n</code></pre>"},{"location":"TitanComms/Vtop_8cpp/#function-vtop___024root___eval_initial","title":"function Vtop___024root___eval_initial","text":"<pre><code>void Vtop___024root___eval_initial (\n    Vtop___024root * vlSelf\n) \n</code></pre>"},{"location":"TitanComms/Vtop_8cpp/#function-vtop___024root___eval_settle","title":"function Vtop___024root___eval_settle","text":"<pre><code>void Vtop___024root___eval_settle (\n    Vtop___024root * vlSelf\n) \n</code></pre>"},{"location":"TitanComms/Vtop_8cpp/#function-vtop___024root___eval_static","title":"function Vtop___024root___eval_static","text":"<pre><code>void Vtop___024root___eval_static (\n    Vtop___024root * vlSelf\n) \n</code></pre>"},{"location":"TitanComms/Vtop_8cpp/#function-vtop___024root__trace_init_top","title":"function Vtop___024root__trace_init_top","text":"<pre><code>void Vtop___024root__trace_init_top (\n    Vtop___024root * vlSelf,\n    VerilatedVcd * tracep\n) \n</code></pre>"},{"location":"TitanComms/Vtop_8cpp/#function-vtop___024root__trace_register","title":"function Vtop___024root__trace_register","text":"<pre><code>VL_ATTR_COLD void Vtop___024root__trace_register (\n    Vtop___024root * vlSelf,\n    VerilatedVcd * tracep\n) \n</code></pre>"},{"location":"TitanComms/Vtop_8cpp/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"TitanComms/Vtop_8cpp/#function-trace_init","title":"function trace_init","text":"<pre><code>static VL_ATTR_COLD void trace_init (\n    void * voidSelf,\n    VerilatedVcd * tracep,\n    uint32_t code\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>titan/comms/verilog/tests/sim_build/Vtop.cpp</code></p>"},{"location":"TitanComms/Vtop_8cpp_source/","title":"File Vtop.cpp","text":"<p>File List &gt; comms &gt; verilog &gt; tests &gt; sim_build &gt; Vtop.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// Verilated -*- C++ -*-\n// DESCRIPTION: Verilator output: Model implementation (design independent parts)\n\n#include \"Vtop.h\"\n#include \"Vtop__Syms.h\"\n#include \"verilated_vcd_c.h\"\n#include \"verilated_dpi.h\"\n\n//============================================================\n// Constructors\n\nVtop::Vtop(VerilatedContext* _vcontextp__, const char* _vcname__)\n    : VerilatedModel{*_vcontextp__}\n    , vlSymsp{new Vtop__Syms(contextp(), _vcname__, this)}\n    , sel_i{vlSymsp-&gt;TOP.sel_i}\n    , in1{vlSymsp-&gt;TOP.in1}\n    , in2{vlSymsp-&gt;TOP.in2}\n    , in3{vlSymsp-&gt;TOP.in3}\n    , in4{vlSymsp-&gt;TOP.in4}\n    , mux_o{vlSymsp-&gt;TOP.mux_o}\n    , rootp{&amp;(vlSymsp-&gt;TOP)}\n{\n    // Register model with the context\n    contextp()-&gt;addModel(this);\n}\n\nVtop::Vtop(const char* _vcname__)\n    : Vtop(Verilated::threadContextp(), _vcname__)\n{\n}\n\n//============================================================\n// Destructor\n\nVtop::~Vtop() {\n    delete vlSymsp;\n}\n\n//============================================================\n// Evaluation function\n\n#ifdef VL_DEBUG\nvoid Vtop___024root___eval_debug_assertions(Vtop___024root* vlSelf);\n#endif  // VL_DEBUG\nvoid Vtop___024root___eval_static(Vtop___024root* vlSelf);\nvoid Vtop___024root___eval_initial(Vtop___024root* vlSelf);\nvoid Vtop___024root___eval_settle(Vtop___024root* vlSelf);\nvoid Vtop___024root___eval(Vtop___024root* vlSelf);\n\nvoid Vtop::eval_step() {\n    VL_DEBUG_IF(VL_DBG_MSGF(\"+++++TOP Evaluate Vtop::eval_step\\n\"); );\n#ifdef VL_DEBUG\n    // Debug assertions\n    Vtop___024root___eval_debug_assertions(&amp;(vlSymsp-&gt;TOP));\n#endif  // VL_DEBUG\n    vlSymsp-&gt;__Vm_activity = true;\n    if (VL_UNLIKELY(!vlSymsp-&gt;__Vm_didInit)) {\n        vlSymsp-&gt;__Vm_didInit = true;\n        VL_DEBUG_IF(VL_DBG_MSGF(\"+ Initial\\n\"););\n        Vtop___024root___eval_static(&amp;(vlSymsp-&gt;TOP));\n        Vtop___024root___eval_initial(&amp;(vlSymsp-&gt;TOP));\n        Vtop___024root___eval_settle(&amp;(vlSymsp-&gt;TOP));\n    }\n    // MTask 0 start\n    VL_DEBUG_IF(VL_DBG_MSGF(\"MTask0 starting\\n\"););\n    Verilated::mtaskId(0);\n    VL_DEBUG_IF(VL_DBG_MSGF(\"+ Eval\\n\"););\n    Vtop___024root___eval(&amp;(vlSymsp-&gt;TOP));\n    // Evaluate cleanup\n    Verilated::endOfThreadMTask(vlSymsp-&gt;__Vm_evalMsgQp);\n    Verilated::endOfEval(vlSymsp-&gt;__Vm_evalMsgQp);\n}\n\nvoid Vtop::eval_end_step() {\n    VL_DEBUG_IF(VL_DBG_MSGF(\"+eval_end_step Vtop::eval_end_step\\n\"); );\n#ifdef VM_TRACE\n    // Tracing\n    if (VL_UNLIKELY(vlSymsp-&gt;__Vm_dumping)) vlSymsp-&gt;_traceDump();\n#endif  // VM_TRACE\n}\n\n//============================================================\n// Events and timing\nbool Vtop::eventsPending() { return !vlSymsp-&gt;TOP.__VdlySched.empty(); }\n\nuint64_t Vtop::nextTimeSlot() { return vlSymsp-&gt;TOP.__VdlySched.nextTimeSlot(); }\n\n//============================================================\n// Utilities\n\nconst char* Vtop::name() const {\n    return vlSymsp-&gt;name();\n}\n\n//============================================================\n// Invoke final blocks\n\nvoid Vtop___024root___eval_final(Vtop___024root* vlSelf);\n\nVL_ATTR_COLD void Vtop::final() {\n    Vtop___024root___eval_final(&amp;(vlSymsp-&gt;TOP));\n}\n\n//============================================================\n// Implementations of abstract methods from VerilatedModel\n\nconst char* Vtop::hierName() const { return vlSymsp-&gt;name(); }\nconst char* Vtop::modelName() const { return \"Vtop\"; }\nunsigned Vtop::threads() const { return 1; }\nstd::unique_ptr&lt;VerilatedTraceConfig&gt; Vtop::traceConfig() const {\n    return std::unique_ptr&lt;VerilatedTraceConfig&gt;{new VerilatedTraceConfig{false, false, false}};\n};\n\n//============================================================\n// Trace configuration\n\nvoid Vtop___024root__trace_init_top(Vtop___024root* vlSelf, VerilatedVcd* tracep);\n\nVL_ATTR_COLD static void trace_init(void* voidSelf, VerilatedVcd* tracep, uint32_t code) {\n    // Callback from tracep-&gt;open()\n    Vtop___024root* const __restrict vlSelf VL_ATTR_UNUSED = static_cast&lt;Vtop___024root*&gt;(voidSelf);\n    Vtop__Syms* const __restrict vlSymsp VL_ATTR_UNUSED = vlSelf-&gt;vlSymsp;\n    if (!vlSymsp-&gt;_vm_contextp__-&gt;calcUnusedSigs()) {\n        VL_FATAL_MT(__FILE__, __LINE__, __FILE__,\n            \"Turning on wave traces requires Verilated::traceEverOn(true) call before time 0.\");\n    }\n    vlSymsp-&gt;__Vm_baseCode = code;\n    tracep-&gt;scopeEscape(' ');\n    tracep-&gt;pushNamePrefix(std::string{vlSymsp-&gt;name()} + ' ');\n    Vtop___024root__trace_init_top(vlSelf, tracep);\n    tracep-&gt;popNamePrefix();\n    tracep-&gt;scopeEscape('.');\n}\n\nVL_ATTR_COLD void Vtop___024root__trace_register(Vtop___024root* vlSelf, VerilatedVcd* tracep);\n\nVL_ATTR_COLD void Vtop::trace(VerilatedVcdC* tfp, int levels, int options) {\n    if (tfp-&gt;isOpen()) {\n        vl_fatal(__FILE__, __LINE__, __FILE__,\"'Vtop::trace()' shall not be called after 'VerilatedVcdC::open()'.\");\n    }\n    if (false &amp;&amp; levels &amp;&amp; options) {}  // Prevent unused\n    tfp-&gt;spTrace()-&gt;addModel(this);\n    tfp-&gt;spTrace()-&gt;addInitCb(&amp;trace_init, &amp;(vlSymsp-&gt;TOP));\n    Vtop___024root__trace_register(&amp;(vlSymsp-&gt;TOP), tfp-&gt;spTrace());\n}\n</code></pre>"},{"location":"TitanComms/Vtop_8h/","title":"File Vtop.h","text":"<p>FileList &gt; comms &gt; verilog &gt; tests &gt; sim_build &gt; Vtop.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"verilated.h\"</code></li> <li><code>#include \"svdpi.h\"</code></li> </ul>"},{"location":"TitanComms/Vtop_8h/#classes","title":"Classes","text":"Type Name class VL_NOT_FINAL"},{"location":"TitanComms/Vtop_8h/#public-attributes","title":"Public Attributes","text":"Type Name VL_IN &amp; in1 VL_IN &amp; in2 VL_IN &amp; in3 VL_IN &amp; in4 VL_OUT &amp; mux_o Vtop___024root *const rootp VL_IN8 &amp; sel_i"},{"location":"TitanComms/Vtop_8h/#public-functions","title":"Public Functions","text":"Type Name VL_NOT_FINAL VerilatedModel VL_ATTR_ALIGNED (VL_CACHE_LINE_BYTES)  Vtop (VerilatedContext * contextp, const char * name=\"TOP\")  Vtop (const char * name=\"TOP\")  void eval () Evaluate the model. Application must call when inputs change. void eval_end_step ()  void eval_step () Evaluate when calling multiple units/models per time step. bool eventsPending () Are there scheduled events to handle? void final () Simulation complete, run final blocks. Application must call on completion. const char * hierName () override const const char * modelName () override const const char * name () constRetrieve name of this model instance (as passed to constructor). uint64_t nextTimeSlot () Returns time at next time slot. Aborts if !eventsPending() unsigned threads () override const void trace (VerilatedVcdC * tfp, int levels, int options=0) Trace signals in the model; called by application code. std::unique_ptr&lt; VerilatedTraceConfig &gt; traceConfig () override const virtual ~Vtop () Destroy the model; called (often implicitly) by application code."},{"location":"TitanComms/Vtop_8h/#macros","title":"Macros","text":"Type Name define VERILATED_VTOP_H_"},{"location":"TitanComms/Vtop_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"TitanComms/Vtop_8h/#variable-in1","title":"variable in1","text":"<pre><code>VL_IN&amp; in1;\n</code></pre>"},{"location":"TitanComms/Vtop_8h/#variable-in2","title":"variable in2","text":"<pre><code>VL_IN&amp; in2;\n</code></pre>"},{"location":"TitanComms/Vtop_8h/#variable-in3","title":"variable in3","text":"<pre><code>VL_IN&amp; in3;\n</code></pre>"},{"location":"TitanComms/Vtop_8h/#variable-in4","title":"variable in4","text":"<pre><code>VL_IN&amp; in4;\n</code></pre>"},{"location":"TitanComms/Vtop_8h/#variable-mux_o","title":"variable mux_o","text":"<pre><code>VL_OUT&amp; mux_o;\n</code></pre>"},{"location":"TitanComms/Vtop_8h/#variable-rootp","title":"variable rootp","text":"<pre><code>Vtop___024root* const rootp;\n</code></pre>"},{"location":"TitanComms/Vtop_8h/#variable-sel_i","title":"variable sel_i","text":"<pre><code>VL_IN8&amp; sel_i;\n</code></pre>"},{"location":"TitanComms/Vtop_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"TitanComms/Vtop_8h/#function-vl_attr_aligned","title":"function VL_ATTR_ALIGNED","text":"<pre><code>VL_NOT_FINAL VerilatedModel VL_ATTR_ALIGNED (\n    VL_CACHE_LINE_BYTES\n) \n</code></pre>"},{"location":"TitanComms/Vtop_8h/#function-vtop","title":"function Vtop","text":"<pre><code>explicit Vtop (\n    VerilatedContext * contextp,\n    const char * name=\"TOP\"\n) \n</code></pre> <p>Construct the model; called by application code If contextp is null, then the model will use the default global context If name is \"\", then makes a wrapper with a single model invisible with respect to DPI scope names. </p>"},{"location":"TitanComms/Vtop_8h/#function-vtop_1","title":"function Vtop","text":"<pre><code>explicit Vtop (\n    const char * name=\"TOP\"\n) \n</code></pre>"},{"location":"TitanComms/Vtop_8h/#function-eval","title":"function eval","text":"<pre><code>void eval () \n</code></pre>"},{"location":"TitanComms/Vtop_8h/#function-eval_end_step","title":"function eval_end_step","text":"<pre><code>void eval_end_step () \n</code></pre> <p>Evaluate at end of a timestep for tracing, when using eval_step(). Application must call after all eval() and before time changes. </p>"},{"location":"TitanComms/Vtop_8h/#function-eval_step","title":"function eval_step","text":"<pre><code>void eval_step () \n</code></pre>"},{"location":"TitanComms/Vtop_8h/#function-eventspending","title":"function eventsPending","text":"<pre><code>bool eventsPending () \n</code></pre>"},{"location":"TitanComms/Vtop_8h/#function-final","title":"function final","text":"<pre><code>void final () \n</code></pre>"},{"location":"TitanComms/Vtop_8h/#function-hiername","title":"function hierName","text":"<pre><code>const char * hierName () override const\n</code></pre>"},{"location":"TitanComms/Vtop_8h/#function-modelname","title":"function modelName","text":"<pre><code>const char * modelName () override const\n</code></pre>"},{"location":"TitanComms/Vtop_8h/#function-name","title":"function name","text":"<pre><code>const char * name () const\n</code></pre>"},{"location":"TitanComms/Vtop_8h/#function-nexttimeslot","title":"function nextTimeSlot","text":"<pre><code>uint64_t nextTimeSlot () \n</code></pre>"},{"location":"TitanComms/Vtop_8h/#function-threads","title":"function threads","text":"<pre><code>unsigned threads () override const\n</code></pre>"},{"location":"TitanComms/Vtop_8h/#function-trace","title":"function trace","text":"<pre><code>void trace (\n    VerilatedVcdC * tfp,\n    int levels,\n    int options=0\n) \n</code></pre>"},{"location":"TitanComms/Vtop_8h/#function-traceconfig","title":"function traceConfig","text":"<pre><code>std::unique_ptr&lt; VerilatedTraceConfig &gt; traceConfig () override const\n</code></pre>"},{"location":"TitanComms/Vtop_8h/#function-vtop_2","title":"function ~Vtop","text":"<pre><code>virtual ~Vtop () \n</code></pre>"},{"location":"TitanComms/Vtop_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"TitanComms/Vtop_8h/#define-verilated_vtop_h_","title":"define VERILATED_VTOP_H_","text":"<pre><code>#define VERILATED_VTOP_H_ \n</code></pre> <p>The documentation for this class was generated from the following file <code>titan/comms/verilog/tests/sim_build/Vtop.h</code></p>"},{"location":"TitanComms/Vtop_8h_source/","title":"File Vtop.h","text":"<p>File List &gt; comms &gt; verilog &gt; tests &gt; sim_build &gt; Vtop.h</p> <p>Go to the documentation of this file</p> <pre><code>// Verilated -*- C++ -*-\n// DESCRIPTION: Verilator output: Primary model header\n//\n// This header should be included by all source files instantiating the design.\n// The class here is then constructed to instantiate the design.\n// See the Verilator manual for examples.\n\n#ifndef VERILATED_VTOP_H_\n#define VERILATED_VTOP_H_  // guard\n\n#include \"verilated.h\"\n#include \"svdpi.h\"\n\nclass Vtop__Syms;\nclass Vtop___024root;\nclass VerilatedVcdC;\n\n// This class is the main interface to the Verilated model\nclass Vtop VL_NOT_FINAL : public VerilatedModel {\n  private:\n    // Symbol table holding complete model state (owned by this class)\n    Vtop__Syms* const vlSymsp;\n\n  public:\n\n    // PORTS\n    // The application code writes and reads these signals to\n    // propagate new values into/out from the Verilated model.\n    VL_IN8(&amp;sel_i,1,0);\n    VL_IN(&amp;in1,31,0);\n    VL_IN(&amp;in2,31,0);\n    VL_IN(&amp;in3,31,0);\n    VL_IN(&amp;in4,31,0);\n    VL_OUT(&amp;mux_o,31,0);\n\n    // CELLS\n    // Public to allow access to /* verilator public */ items.\n    // Otherwise the application code can consider these internals.\n\n    // Root instance pointer to allow access to model internals,\n    // including inlined /* verilator public_flat_* */ items.\n    Vtop___024root* const rootp;\n\n    // CONSTRUCTORS\n    explicit Vtop(VerilatedContext* contextp, const char* name = \"TOP\");\n    explicit Vtop(const char* name = \"TOP\");\n    virtual ~Vtop();\n  private:\n    VL_UNCOPYABLE(Vtop);  \n\n  public:\n    // API METHODS\n    void eval() { eval_step(); eval_end_step(); }\n    void eval_step();\n    void eval_end_step();\n    void final();\n    bool eventsPending();\n    uint64_t nextTimeSlot();\n    void trace(VerilatedVcdC* tfp, int levels, int options = 0);\n    const char* name() const;\n\n    // Abstract methods from VerilatedModel\n    const char* hierName() const override final;\n    const char* modelName() const override final;\n    unsigned threads() const override final;\n    std::unique_ptr&lt;VerilatedTraceConfig&gt; traceConfig() const override final;\n} VL_ATTR_ALIGNED(VL_CACHE_LINE_BYTES);\n\n#endif  // guard\n</code></pre>"},{"location":"TitanComms/Vtop____ALL_8cpp/","title":"File Vtop__ALL.cpp","text":"<p>FileList &gt; comms &gt; verilog &gt; tests &gt; sim_build &gt; Vtop__ALL.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Vtop.cpp\"</code></li> <li><code>#include \"Vtop___024root__DepSet_h84412442__0.cpp\"</code></li> <li><code>#include \"Vtop___024root__DepSet_heccd7ead__0.cpp\"</code></li> <li><code>#include \"Vtop__Dpi.cpp\"</code></li> <li><code>#include \"Vtop__Trace__0.cpp\"</code></li> <li><code>#include \"Vtop___024root__Slow.cpp\"</code></li> <li><code>#include \"Vtop___024root__DepSet_h84412442__0__Slow.cpp\"</code></li> <li><code>#include \"Vtop___024root__DepSet_heccd7ead__0__Slow.cpp\"</code></li> <li><code>#include \"Vtop___024unit__Slow.cpp\"</code></li> <li><code>#include \"Vtop___024unit__DepSet_hff17caec__0__Slow.cpp\"</code></li> <li><code>#include \"Vtop__Syms.cpp\"</code></li> <li><code>#include \"Vtop__Trace__0__Slow.cpp\"</code></li> </ul>"},{"location":"TitanComms/Vtop____ALL_8cpp/#macros","title":"Macros","text":"Type Name define VL_INCLUDE_OPT  include"},{"location":"TitanComms/Vtop____ALL_8cpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"TitanComms/Vtop____ALL_8cpp/#define-vl_include_opt","title":"define VL_INCLUDE_OPT","text":"<pre><code>#define VL_INCLUDE_OPT include\n</code></pre> <p>The documentation for this class was generated from the following file <code>titan/comms/verilog/tests/sim_build/Vtop__ALL.cpp</code></p>"},{"location":"TitanComms/Vtop____ALL_8cpp_source/","title":"File Vtop__ALL.cpp","text":"<p>File List &gt; comms &gt; verilog &gt; tests &gt; sim_build &gt; Vtop__ALL.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// DESCRIPTION: Generated by verilator_includer via makefile\n#define VL_INCLUDE_OPT include\n#include \"Vtop.cpp\"\n#include \"Vtop___024root__DepSet_h84412442__0.cpp\"\n#include \"Vtop___024root__DepSet_heccd7ead__0.cpp\"\n#include \"Vtop__Dpi.cpp\"\n#include \"Vtop__Trace__0.cpp\"\n#include \"Vtop___024root__Slow.cpp\"\n#include \"Vtop___024root__DepSet_h84412442__0__Slow.cpp\"\n#include \"Vtop___024root__DepSet_heccd7ead__0__Slow.cpp\"\n#include \"Vtop___024unit__Slow.cpp\"\n#include \"Vtop___024unit__DepSet_hff17caec__0__Slow.cpp\"\n#include \"Vtop__Syms.cpp\"\n#include \"Vtop__Trace__0__Slow.cpp\"\n</code></pre>"},{"location":"TitanComms/Vtop____Dpi_8cpp/","title":"File Vtop__Dpi.cpp","text":"<p>FileList &gt; comms &gt; verilog &gt; tests &gt; sim_build &gt; Vtop__Dpi.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Vtop__Dpi.h\"</code></li> <li><code>#include \"Vtop.h\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>titan/comms/verilog/tests/sim_build/Vtop__Dpi.cpp</code></p>"},{"location":"TitanComms/Vtop____Dpi_8cpp_source/","title":"File Vtop__Dpi.cpp","text":"<p>File List &gt; comms &gt; verilog &gt; tests &gt; sim_build &gt; Vtop__Dpi.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// Verilated -*- C++ -*-\n// DESCRIPTION: Verilator output: Implementation of DPI export functions.\n//\n// Verilator compiles this file in when DPI functions are used.\n// If you have multiple Verilated designs with the same DPI exported\n// function names, you will get multiple definition link errors from here.\n// This is an unfortunate result of the DPI specification.\n// To solve this, either\n//    1. Call Vtop::{export_function} instead,\n//       and do not even bother to compile this file\n// or 2. Compile all __Dpi.cpp files in the same compiler run,\n//       and #ifdefs already inserted here will sort everything out.\n\n#include \"Vtop__Dpi.h\"\n#include \"Vtop.h\"\n</code></pre>"},{"location":"TitanComms/Vtop____Dpi_8h/","title":"File Vtop__Dpi.h","text":"<p>FileList &gt; comms &gt; verilog &gt; tests &gt; sim_build &gt; Vtop__Dpi.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"svdpi.h\"</code></li> </ul>"},{"location":"TitanComms/Vtop____Dpi_8h/#macros","title":"Macros","text":"Type Name define VERILATED_VTOP__DPI_H_"},{"location":"TitanComms/Vtop____Dpi_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"TitanComms/Vtop____Dpi_8h/#define-verilated_vtop__dpi_h_","title":"define VERILATED_VTOP__DPI_H_","text":"<pre><code>#define VERILATED_VTOP__DPI_H_ \n</code></pre> <p>The documentation for this class was generated from the following file <code>titan/comms/verilog/tests/sim_build/Vtop__Dpi.h</code></p>"},{"location":"TitanComms/Vtop____Dpi_8h_source/","title":"File Vtop__Dpi.h","text":"<p>File List &gt; comms &gt; verilog &gt; tests &gt; sim_build &gt; Vtop__Dpi.h</p> <p>Go to the documentation of this file</p> <pre><code>// Verilated -*- C++ -*-\n// DESCRIPTION: Verilator output: Prototypes for DPI import and export functions.\n//\n// Verilator includes this file in all generated .cpp files that use DPI functions.\n// Manually include this file where DPI .c import functions are declared to ensure\n// the C functions match the expectations of the DPI imports.\n\n#ifndef VERILATED_VTOP__DPI_H_\n#define VERILATED_VTOP__DPI_H_  // guard\n\n#include \"svdpi.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif  // guard\n</code></pre>"},{"location":"TitanComms/Vtop____Syms_8cpp/","title":"File Vtop__Syms.cpp","text":"<p>FileList &gt; comms &gt; verilog &gt; tests &gt; sim_build &gt; Vtop__Syms.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Vtop__Syms.h\"</code></li> <li><code>#include \"Vtop.h\"</code></li> <li><code>#include \"Vtop___024root.h\"</code></li> <li><code>#include \"Vtop___024unit.h\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>titan/comms/verilog/tests/sim_build/Vtop__Syms.cpp</code></p>"},{"location":"TitanComms/Vtop____Syms_8cpp_source/","title":"File Vtop__Syms.cpp","text":"<p>File List &gt; comms &gt; verilog &gt; tests &gt; sim_build &gt; Vtop__Syms.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// Verilated -*- C++ -*-\n// DESCRIPTION: Verilator output: Symbol table implementation internals\n\n#include \"Vtop__Syms.h\"\n#include \"Vtop.h\"\n#include \"Vtop___024root.h\"\n#include \"Vtop___024unit.h\"\n\n// FUNCTIONS\nVtop__Syms::~Vtop__Syms()\n{\n\n    // Tear down scope hierarchy\n    __Vhier.remove(0, &amp;__Vscope_dut_param_mux);\n    __Vhier.remove(&amp;__Vscope_dut_param_mux, &amp;__Vscope_dut_param_mux__uut_pmux);\n\n#ifdef VM_TRACE\n    if (__Vm_dumping) _traceDumpClose();\n#endif  // VM_TRACE\n}\n\nvoid Vtop__Syms::_traceDump() {\n    const VerilatedLockGuard lock(__Vm_dumperMutex);\n    __Vm_dumperp-&gt;dump(VL_TIME_Q());\n}\n\nvoid Vtop__Syms::_traceDumpOpen() {\n    const VerilatedLockGuard lock(__Vm_dumperMutex);\n    if (VL_UNLIKELY(!__Vm_dumperp)) {\n        __Vm_dumperp = new VerilatedVcdC();\n        __Vm_modelp-&gt;trace(__Vm_dumperp, 0, 0);\n        std::string dumpfile = _vm_contextp__-&gt;dumpfileCheck();\n        __Vm_dumperp-&gt;open(dumpfile.c_str());\n        __Vm_dumping = true;\n    }\n}\n\nvoid Vtop__Syms::_traceDumpClose() {\n    const VerilatedLockGuard lock(__Vm_dumperMutex);\n    __Vm_dumping = false;\n    VL_DO_CLEAR(delete __Vm_dumperp, __Vm_dumperp = nullptr);\n}\n\nVtop__Syms::Vtop__Syms(VerilatedContext* contextp, const char* namep, Vtop* modelp)\n    : VerilatedSyms{contextp}\n    // Setup internal state of the Syms class\n    , __Vm_modelp{modelp}\n    // Setup module instances\n    , TOP{this, namep}\n{\n    // Configure time unit / time precision\n    _vm_contextp__-&gt;timeunit(-9);\n    _vm_contextp__-&gt;timeprecision(-12);\n    // Setup each module's pointers to their submodules\n    // Setup each module's pointer back to symbol table (for public functions)\n    TOP.__Vconfigure(true);\n    // Setup scopes\n    __Vscope_TOP.configure(this, name(), \"TOP\", \"TOP\", 0, VerilatedScope::SCOPE_OTHER);\n    __Vscope_dut_param_mux.configure(this, name(), \"dut_param_mux\", \"dut_param_mux\", -9, VerilatedScope::SCOPE_MODULE);\n    __Vscope_dut_param_mux__uut_pmux.configure(this, name(), \"dut_param_mux.uut_pmux\", \"uut_pmux\", -9, VerilatedScope::SCOPE_MODULE);\n\n    // Set up scope hierarchy\n    __Vhier.add(0, &amp;__Vscope_dut_param_mux);\n    __Vhier.add(&amp;__Vscope_dut_param_mux, &amp;__Vscope_dut_param_mux__uut_pmux);\n\n    // Setup export functions\n    for (int __Vfinal = 0; __Vfinal &lt; 2; ++__Vfinal) {\n        __Vscope_TOP.varInsert(__Vfinal,\"in1\", &amp;(TOP.in1), false, VLVT_UINT32,VLVD_IN|VLVF_PUB_RW,1 ,31,0);\n        __Vscope_TOP.varInsert(__Vfinal,\"in2\", &amp;(TOP.in2), false, VLVT_UINT32,VLVD_IN|VLVF_PUB_RW,1 ,31,0);\n        __Vscope_TOP.varInsert(__Vfinal,\"in3\", &amp;(TOP.in3), false, VLVT_UINT32,VLVD_IN|VLVF_PUB_RW,1 ,31,0);\n        __Vscope_TOP.varInsert(__Vfinal,\"in4\", &amp;(TOP.in4), false, VLVT_UINT32,VLVD_IN|VLVF_PUB_RW,1 ,31,0);\n        __Vscope_TOP.varInsert(__Vfinal,\"mux_o\", &amp;(TOP.mux_o), false, VLVT_UINT32,VLVD_OUT|VLVF_PUB_RW,1 ,31,0);\n        __Vscope_TOP.varInsert(__Vfinal,\"sel_i\", &amp;(TOP.sel_i), false, VLVT_UINT8,VLVD_IN|VLVF_PUB_RW,1 ,1,0);\n        __Vscope_dut_param_mux.varInsert(__Vfinal,\"in1\", &amp;(TOP.dut_param_mux__DOT__in1), false, VLVT_UINT32,VLVD_NODIR|VLVF_PUB_RW,1 ,31,0);\n        __Vscope_dut_param_mux.varInsert(__Vfinal,\"in2\", &amp;(TOP.dut_param_mux__DOT__in2), false, VLVT_UINT32,VLVD_NODIR|VLVF_PUB_RW,1 ,31,0);\n        __Vscope_dut_param_mux.varInsert(__Vfinal,\"in3\", &amp;(TOP.dut_param_mux__DOT__in3), false, VLVT_UINT32,VLVD_NODIR|VLVF_PUB_RW,1 ,31,0);\n        __Vscope_dut_param_mux.varInsert(__Vfinal,\"in4\", &amp;(TOP.dut_param_mux__DOT__in4), false, VLVT_UINT32,VLVD_NODIR|VLVF_PUB_RW,1 ,31,0);\n        __Vscope_dut_param_mux.varInsert(__Vfinal,\"mux_o\", &amp;(TOP.dut_param_mux__DOT__mux_o), false, VLVT_UINT32,VLVD_NODIR|VLVF_PUB_RW,1 ,31,0);\n        __Vscope_dut_param_mux.varInsert(__Vfinal,\"sel_i\", &amp;(TOP.dut_param_mux__DOT__sel_i), false, VLVT_UINT8,VLVD_NODIR|VLVF_PUB_RW,1 ,1,0);\n        __Vscope_dut_param_mux__uut_pmux.varInsert(__Vfinal,\"INPUT_WIDTH\", const_cast&lt;void*&gt;(static_cast&lt;const void*&gt;(&amp;(TOP.dut_param_mux__DOT__uut_pmux__DOT__INPUT_WIDTH))), true, VLVT_UINT32,VLVD_NODIR|VLVF_PUB_RW,1 ,31,0);\n        __Vscope_dut_param_mux__uut_pmux.varInsert(__Vfinal,\"SELECTOR_WIDTH\", const_cast&lt;void*&gt;(static_cast&lt;const void*&gt;(&amp;(TOP.dut_param_mux__DOT__uut_pmux__DOT__SELECTOR_WIDTH))), true, VLVT_UINT32,VLVD_NODIR|VLVF_PUB_RW,1 ,31,0);\n        __Vscope_dut_param_mux__uut_pmux.varInsert(__Vfinal,\"SIGNAL_COUNT\", const_cast&lt;void*&gt;(static_cast&lt;const void*&gt;(&amp;(TOP.dut_param_mux__DOT__uut_pmux__DOT__SIGNAL_COUNT))), true, VLVT_UINT32,VLVD_NODIR|VLVF_PUB_RW,1 ,31,0);\n        __Vscope_dut_param_mux__uut_pmux.varInsert(__Vfinal,\"inputs\", &amp;(TOP.dut_param_mux__DOT__uut_pmux__DOT__inputs), false, VLVT_UINT32,VLVD_NODIR|VLVF_PUB_RW,2 ,31,0 ,0,3);\n        __Vscope_dut_param_mux__uut_pmux.varInsert(__Vfinal,\"out\", &amp;(TOP.dut_param_mux__DOT__uut_pmux__DOT__out), false, VLVT_UINT32,VLVD_NODIR|VLVF_PUB_RW,1 ,31,0);\n        __Vscope_dut_param_mux__uut_pmux.varInsert(__Vfinal,\"selector\", &amp;(TOP.dut_param_mux__DOT__uut_pmux__DOT__selector), false, VLVT_UINT8,VLVD_NODIR|VLVF_PUB_RW,1 ,1,0);\n    }\n}\n</code></pre>"},{"location":"TitanComms/Vtop____Syms_8h/","title":"File Vtop__Syms.h","text":"<p>FileList &gt; comms &gt; verilog &gt; tests &gt; sim_build &gt; Vtop__Syms.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"verilated.h\"</code></li> <li><code>#include \"verilated_vcd_c.h\"</code></li> <li><code>#include \"Vtop.h\"</code></li> <li><code>#include \"Vtop___024root.h\"</code></li> <li><code>#include \"Vtop___024unit.h\"</code></li> </ul>"},{"location":"TitanComms/Vtop____Syms_8h/#classes","title":"Classes","text":"Type Name class Vtop__Syms"},{"location":"TitanComms/Vtop____Syms_8h/#public-attributes","title":"Public Attributes","text":"Type Name Vtop___024root TOP VerilatedHierarchy __Vhier bool __Vm_activity   = = falseTrace class for $dump*. uint32_t __Vm_baseCode   = = 0Used by trace routines when tracing multiple models. bool __Vm_didInit   = = false VerilatedMutex __Vm_dumperMutex bool __Vm_dumping   = = false Vtop *const __Vm_modelp VerilatedScope __Vscope_TOP VerilatedScope __Vscope_dut_param_mux VerilatedScope __Vscope_dut_param_mux__uut_pmux"},{"location":"TitanComms/Vtop____Syms_8h/#public-functions","title":"Public Functions","text":"Type Name Vtop__Syms VerilatedSyms VL_ATTR_ALIGNED (VL_CACHE_LINE_BYTES)  VerilatedVcdC *__Vm_dumperp VL_GUARDED_BY (__Vm_dumperMutex)  Vtop__Syms (VerilatedContext * contextp, const char * namep, Vtop * modelp)  void _traceDump ()  void _traceDumpClose ()  void _traceDumpOpen ()  const char * name ()  ~Vtop__Syms ()"},{"location":"TitanComms/Vtop____Syms_8h/#macros","title":"Macros","text":"Type Name define VERILATED_VTOP__SYMS_H_"},{"location":"TitanComms/Vtop____Syms_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"TitanComms/Vtop____Syms_8h/#variable-top","title":"variable TOP","text":"<pre><code>Vtop___024root TOP;\n</code></pre>"},{"location":"TitanComms/Vtop____Syms_8h/#variable-__vhier","title":"variable __Vhier","text":"<pre><code>VerilatedHierarchy __Vhier;\n</code></pre>"},{"location":"TitanComms/Vtop____Syms_8h/#variable-__vm_activity","title":"variable __Vm_activity","text":"<p>Trace class for $dump*. <pre><code>bool __Vm_activity;\n</code></pre></p> <p>Used by trace routines to determine change occurred </p>"},{"location":"TitanComms/Vtop____Syms_8h/#variable-__vm_basecode","title":"variable __Vm_baseCode","text":"<pre><code>uint32_t __Vm_baseCode;\n</code></pre>"},{"location":"TitanComms/Vtop____Syms_8h/#variable-__vm_didinit","title":"variable __Vm_didInit","text":"<pre><code>bool __Vm_didInit;\n</code></pre>"},{"location":"TitanComms/Vtop____Syms_8h/#variable-__vm_dumpermutex","title":"variable __Vm_dumperMutex","text":"<pre><code>VerilatedMutex __Vm_dumperMutex;\n</code></pre>"},{"location":"TitanComms/Vtop____Syms_8h/#variable-__vm_dumping","title":"variable __Vm_dumping","text":"<pre><code>bool __Vm_dumping;\n</code></pre>"},{"location":"TitanComms/Vtop____Syms_8h/#variable-__vm_modelp","title":"variable __Vm_modelp","text":"<pre><code>Vtop* const __Vm_modelp;\n</code></pre>"},{"location":"TitanComms/Vtop____Syms_8h/#variable-__vscope_top","title":"variable __Vscope_TOP","text":"<pre><code>VerilatedScope __Vscope_TOP;\n</code></pre>"},{"location":"TitanComms/Vtop____Syms_8h/#variable-__vscope_dut_param_mux","title":"variable __Vscope_dut_param_mux","text":"<pre><code>VerilatedScope __Vscope_dut_param_mux;\n</code></pre>"},{"location":"TitanComms/Vtop____Syms_8h/#variable-__vscope_dut_param_mux__uut_pmux","title":"variable __Vscope_dut_param_mux__uut_pmux","text":"<pre><code>VerilatedScope __Vscope_dut_param_mux__uut_pmux;\n</code></pre>"},{"location":"TitanComms/Vtop____Syms_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"TitanComms/Vtop____Syms_8h/#function-vl_attr_aligned","title":"function VL_ATTR_ALIGNED","text":"<pre><code>Vtop__Syms VerilatedSyms VL_ATTR_ALIGNED (\n    VL_CACHE_LINE_BYTES\n) \n</code></pre>"},{"location":"TitanComms/Vtop____Syms_8h/#function-vl_guarded_by","title":"function VL_GUARDED_BY","text":"<pre><code>VerilatedVcdC *__Vm_dumperp VL_GUARDED_BY (\n    __Vm_dumperMutex\n) \n</code></pre>"},{"location":"TitanComms/Vtop____Syms_8h/#function-vtop__syms","title":"function Vtop__Syms","text":"<pre><code>Vtop__Syms (\n    VerilatedContext * contextp,\n    const char * namep,\n    Vtop * modelp\n) \n</code></pre>"},{"location":"TitanComms/Vtop____Syms_8h/#function-_tracedump","title":"function _traceDump","text":"<pre><code>void _traceDump () \n</code></pre>"},{"location":"TitanComms/Vtop____Syms_8h/#function-_tracedumpclose","title":"function _traceDumpClose","text":"<pre><code>void _traceDumpClose () \n</code></pre>"},{"location":"TitanComms/Vtop____Syms_8h/#function-_tracedumpopen","title":"function _traceDumpOpen","text":"<pre><code>void _traceDumpOpen () \n</code></pre>"},{"location":"TitanComms/Vtop____Syms_8h/#function-name","title":"function name","text":"<pre><code>const char * name () \n</code></pre>"},{"location":"TitanComms/Vtop____Syms_8h/#function-vtop__syms_1","title":"function ~Vtop__Syms","text":"<pre><code>~Vtop__Syms () \n</code></pre>"},{"location":"TitanComms/Vtop____Syms_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"TitanComms/Vtop____Syms_8h/#define-verilated_vtop__syms_h_","title":"define VERILATED_VTOP__SYMS_H_","text":"<pre><code>#define VERILATED_VTOP__SYMS_H_ \n</code></pre> <p>The documentation for this class was generated from the following file <code>titan/comms/verilog/tests/sim_build/Vtop__Syms.h</code></p>"},{"location":"TitanComms/Vtop____Syms_8h_source/","title":"File Vtop__Syms.h","text":"<p>File List &gt; comms &gt; verilog &gt; tests &gt; sim_build &gt; Vtop__Syms.h</p> <p>Go to the documentation of this file</p> <pre><code>// Verilated -*- C++ -*-\n// DESCRIPTION: Verilator output: Symbol table internal header\n//\n// Internal details; most calling programs do not need this header,\n// unless using verilator public meta comments.\n\n#ifndef VERILATED_VTOP__SYMS_H_\n#define VERILATED_VTOP__SYMS_H_  // guard\n\n#include \"verilated.h\"\n#include \"verilated_vcd_c.h\"\n\n// INCLUDE MODEL CLASS\n\n#include \"Vtop.h\"\n\n// INCLUDE MODULE CLASSES\n#include \"Vtop___024root.h\"\n#include \"Vtop___024unit.h\"\n\n// DPI TYPES for DPI Export callbacks (Internal use)\n\n// SYMS CLASS (contains all model state)\nclass Vtop__Syms final : public VerilatedSyms {\n  public:\n    // INTERNAL STATE\n    Vtop* const __Vm_modelp;\n    bool __Vm_dumping = false;  // Dumping is active\n    VerilatedMutex __Vm_dumperMutex;  // Protect __Vm_dumperp\n    VerilatedVcdC* __Vm_dumperp VL_GUARDED_BY(__Vm_dumperMutex) = nullptr;  \n    bool __Vm_activity = false;  \n    uint32_t __Vm_baseCode = 0;  \n    bool __Vm_didInit = false;\n\n    // MODULE INSTANCE STATE\n    Vtop___024root                 TOP;\n\n    // SCOPE NAMES\n    VerilatedScope __Vscope_TOP;\n    VerilatedScope __Vscope_dut_param_mux;\n    VerilatedScope __Vscope_dut_param_mux__uut_pmux;\n\n    // SCOPE HIERARCHY\n    VerilatedHierarchy __Vhier;\n\n    // CONSTRUCTORS\n    Vtop__Syms(VerilatedContext* contextp, const char* namep, Vtop* modelp);\n    ~Vtop__Syms();\n\n    // METHODS\n    const char* name() { return TOP.name(); }\n    void _traceDump();\n    void _traceDumpOpen();\n    void _traceDumpClose();\n} VL_ATTR_ALIGNED(VL_CACHE_LINE_BYTES);\n\n#endif  // guard\n</code></pre>"},{"location":"TitanComms/Vtop____Trace____0_8cpp/","title":"File Vtop__Trace__0.cpp","text":"<p>FileList &gt; comms &gt; verilog &gt; tests &gt; sim_build &gt; Vtop__Trace__0.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"verilated_vcd_c.h\"</code></li> <li><code>#include \"Vtop__Syms.h\"</code></li> </ul>"},{"location":"TitanComms/Vtop____Trace____0_8cpp/#public-functions","title":"Public Functions","text":"Type Name void Vtop___024root__trace_chg_sub_0 (Vtop___024root * vlSelf, VerilatedVcd::Buffer * bufp)  void Vtop___024root__trace_chg_top_0 (void * voidSelf, VerilatedVcd::Buffer * bufp)  void Vtop___024root__trace_cleanup (void * voidSelf, VerilatedVcd *)"},{"location":"TitanComms/Vtop____Trace____0_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"TitanComms/Vtop____Trace____0_8cpp/#function-vtop___024root__trace_chg_sub_0","title":"function Vtop___024root__trace_chg_sub_0","text":"<pre><code>void Vtop___024root__trace_chg_sub_0 (\n    Vtop___024root * vlSelf,\n    VerilatedVcd::Buffer * bufp\n) \n</code></pre>"},{"location":"TitanComms/Vtop____Trace____0_8cpp/#function-vtop___024root__trace_chg_top_0","title":"function Vtop___024root__trace_chg_top_0","text":"<pre><code>void Vtop___024root__trace_chg_top_0 (\n    void * voidSelf,\n    VerilatedVcd::Buffer * bufp\n) \n</code></pre>"},{"location":"TitanComms/Vtop____Trace____0_8cpp/#function-vtop___024root__trace_cleanup","title":"function Vtop___024root__trace_cleanup","text":"<pre><code>void Vtop___024root__trace_cleanup (\n    void * voidSelf,\n    VerilatedVcd *\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>titan/comms/verilog/tests/sim_build/Vtop__Trace__0.cpp</code></p>"},{"location":"TitanComms/Vtop____Trace____0_8cpp_source/","title":"File Vtop__Trace__0.cpp","text":"<p>File List &gt; comms &gt; verilog &gt; tests &gt; sim_build &gt; Vtop__Trace__0.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// Verilated -*- C++ -*-\n// DESCRIPTION: Verilator output: Tracing implementation internals\n#include \"verilated_vcd_c.h\"\n#include \"Vtop__Syms.h\"\n\n\nvoid Vtop___024root__trace_chg_sub_0(Vtop___024root* vlSelf, VerilatedVcd::Buffer* bufp);\n\nvoid Vtop___024root__trace_chg_top_0(void* voidSelf, VerilatedVcd::Buffer* bufp) {\n    VL_DEBUG_IF(VL_DBG_MSGF(\"+    Vtop___024root__trace_chg_top_0\\n\"); );\n    // Init\n    Vtop___024root* const __restrict vlSelf VL_ATTR_UNUSED = static_cast&lt;Vtop___024root*&gt;(voidSelf);\n    Vtop__Syms* const __restrict vlSymsp VL_ATTR_UNUSED = vlSelf-&gt;vlSymsp;\n    if (VL_UNLIKELY(!vlSymsp-&gt;__Vm_activity)) return;\n    // Body\n    Vtop___024root__trace_chg_sub_0((&amp;vlSymsp-&gt;TOP), bufp);\n}\n\nvoid Vtop___024root__trace_chg_sub_0(Vtop___024root* vlSelf, VerilatedVcd::Buffer* bufp) {\n    if (false &amp;&amp; vlSelf) {}  // Prevent unused\n    Vtop__Syms* const __restrict vlSymsp VL_ATTR_UNUSED = vlSelf-&gt;vlSymsp;\n    VL_DEBUG_IF(VL_DBG_MSGF(\"+    Vtop___024root__trace_chg_sub_0\\n\"); );\n    // Init\n    uint32_t* const oldp VL_ATTR_UNUSED = bufp-&gt;oldp(vlSymsp-&gt;__Vm_baseCode + 1);\n    // Body\n    bufp-&gt;chgIData(oldp+0,(vlSelf-&gt;in1),32);\n    bufp-&gt;chgIData(oldp+1,(vlSelf-&gt;in2),32);\n    bufp-&gt;chgIData(oldp+2,(vlSelf-&gt;in3),32);\n    bufp-&gt;chgIData(oldp+3,(vlSelf-&gt;in4),32);\n    bufp-&gt;chgCData(oldp+4,(vlSelf-&gt;sel_i),2);\n    bufp-&gt;chgIData(oldp+5,(vlSelf-&gt;mux_o),32);\n    bufp-&gt;chgIData(oldp+6,(vlSelf-&gt;dut_param_mux__DOT__in1),32);\n    bufp-&gt;chgIData(oldp+7,(vlSelf-&gt;dut_param_mux__DOT__in2),32);\n    bufp-&gt;chgIData(oldp+8,(vlSelf-&gt;dut_param_mux__DOT__in3),32);\n    bufp-&gt;chgIData(oldp+9,(vlSelf-&gt;dut_param_mux__DOT__in4),32);\n    bufp-&gt;chgCData(oldp+10,(vlSelf-&gt;dut_param_mux__DOT__sel_i),2);\n    bufp-&gt;chgIData(oldp+11,(vlSelf-&gt;dut_param_mux__DOT__mux_o),32);\n    bufp-&gt;chgCData(oldp+12,(vlSelf-&gt;dut_param_mux__DOT__uut_pmux__DOT__selector),2);\n    bufp-&gt;chgIData(oldp+13,(vlSelf-&gt;dut_param_mux__DOT__uut_pmux__DOT__inputs[0]),32);\n    bufp-&gt;chgIData(oldp+14,(vlSelf-&gt;dut_param_mux__DOT__uut_pmux__DOT__inputs[1]),32);\n    bufp-&gt;chgIData(oldp+15,(vlSelf-&gt;dut_param_mux__DOT__uut_pmux__DOT__inputs[2]),32);\n    bufp-&gt;chgIData(oldp+16,(vlSelf-&gt;dut_param_mux__DOT__uut_pmux__DOT__inputs[3]),32);\n    bufp-&gt;chgIData(oldp+17,(vlSelf-&gt;dut_param_mux__DOT__uut_pmux__DOT__out),32);\n}\n\nvoid Vtop___024root__trace_cleanup(void* voidSelf, VerilatedVcd* /*unused*/) {\n    VL_DEBUG_IF(VL_DBG_MSGF(\"+    Vtop___024root__trace_cleanup\\n\"); );\n    // Init\n    Vtop___024root* const __restrict vlSelf VL_ATTR_UNUSED = static_cast&lt;Vtop___024root*&gt;(voidSelf);\n    Vtop__Syms* const __restrict vlSymsp VL_ATTR_UNUSED = vlSelf-&gt;vlSymsp;\n    VlUnpacked&lt;CData/*0:0*/, 1&gt; __Vm_traceActivity;\n    for (int __Vi0 = 0; __Vi0 &lt; 1; ++__Vi0) {\n        __Vm_traceActivity[__Vi0] = 0;\n    }\n    // Body\n    vlSymsp-&gt;__Vm_activity = false;\n    __Vm_traceActivity[0U] = 0U;\n}\n</code></pre>"},{"location":"TitanComms/Vtop____Trace____0____Slow_8cpp/","title":"File Vtop__Trace__0__Slow.cpp","text":"<p>FileList &gt; comms &gt; verilog &gt; tests &gt; sim_build &gt; Vtop__Trace__0__Slow.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"verilated_vcd_c.h\"</code></li> <li><code>#include \"Vtop__Syms.h\"</code></li> </ul>"},{"location":"TitanComms/Vtop____Trace____0____Slow_8cpp/#public-functions","title":"Public Functions","text":"Type Name void Vtop___024root__trace_chg_top_0 (void * voidSelf, VerilatedVcd::Buffer * bufp)  void Vtop___024root__trace_cleanup (void * voidSelf, VerilatedVcd *)  VL_ATTR_COLD void Vtop___024root__trace_full_sub_0 (Vtop___024root * vlSelf, VerilatedVcd::Buffer * bufp)  VL_ATTR_COLD void Vtop___024root__trace_full_top_0 (void * voidSelf, VerilatedVcd::Buffer * bufp)  VL_ATTR_COLD void Vtop___024root__trace_init_sub__TOP__0 (Vtop___024root * vlSelf, VerilatedVcd * tracep)  VL_ATTR_COLD void Vtop___024root__trace_init_top (Vtop___024root * vlSelf, VerilatedVcd * tracep)  VL_ATTR_COLD void Vtop___024root__trace_register (Vtop___024root * vlSelf, VerilatedVcd * tracep)"},{"location":"TitanComms/Vtop____Trace____0____Slow_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"TitanComms/Vtop____Trace____0____Slow_8cpp/#function-vtop___024root__trace_chg_top_0","title":"function Vtop___024root__trace_chg_top_0","text":"<pre><code>void Vtop___024root__trace_chg_top_0 (\n    void * voidSelf,\n    VerilatedVcd::Buffer * bufp\n) \n</code></pre>"},{"location":"TitanComms/Vtop____Trace____0____Slow_8cpp/#function-vtop___024root__trace_cleanup","title":"function Vtop___024root__trace_cleanup","text":"<pre><code>void Vtop___024root__trace_cleanup (\n    void * voidSelf,\n    VerilatedVcd *\n) \n</code></pre>"},{"location":"TitanComms/Vtop____Trace____0____Slow_8cpp/#function-vtop___024root__trace_full_sub_0","title":"function Vtop___024root__trace_full_sub_0","text":"<pre><code>VL_ATTR_COLD void Vtop___024root__trace_full_sub_0 (\n    Vtop___024root * vlSelf,\n    VerilatedVcd::Buffer * bufp\n) \n</code></pre>"},{"location":"TitanComms/Vtop____Trace____0____Slow_8cpp/#function-vtop___024root__trace_full_top_0","title":"function Vtop___024root__trace_full_top_0","text":"<pre><code>VL_ATTR_COLD void Vtop___024root__trace_full_top_0 (\n    void * voidSelf,\n    VerilatedVcd::Buffer * bufp\n) \n</code></pre>"},{"location":"TitanComms/Vtop____Trace____0____Slow_8cpp/#function-vtop___024root__trace_init_sub__top__0","title":"function Vtop___024root__trace_init_sub__TOP__0","text":"<pre><code>VL_ATTR_COLD void Vtop___024root__trace_init_sub__TOP__0 (\n    Vtop___024root * vlSelf,\n    VerilatedVcd * tracep\n) \n</code></pre>"},{"location":"TitanComms/Vtop____Trace____0____Slow_8cpp/#function-vtop___024root__trace_init_top","title":"function Vtop___024root__trace_init_top","text":"<pre><code>VL_ATTR_COLD void Vtop___024root__trace_init_top (\n    Vtop___024root * vlSelf,\n    VerilatedVcd * tracep\n) \n</code></pre>"},{"location":"TitanComms/Vtop____Trace____0____Slow_8cpp/#function-vtop___024root__trace_register","title":"function Vtop___024root__trace_register","text":"<pre><code>VL_ATTR_COLD void Vtop___024root__trace_register (\n    Vtop___024root * vlSelf,\n    VerilatedVcd * tracep\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>titan/comms/verilog/tests/sim_build/Vtop__Trace__0__Slow.cpp</code></p>"},{"location":"TitanComms/Vtop____Trace____0____Slow_8cpp_source/","title":"File Vtop__Trace__0__Slow.cpp","text":"<p>File List &gt; comms &gt; verilog &gt; tests &gt; sim_build &gt; Vtop__Trace__0__Slow.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// Verilated -*- C++ -*-\n// DESCRIPTION: Verilator output: Tracing implementation internals\n#include \"verilated_vcd_c.h\"\n#include \"Vtop__Syms.h\"\n\n\nVL_ATTR_COLD void Vtop___024root__trace_init_sub__TOP__0(Vtop___024root* vlSelf, VerilatedVcd* tracep) {\n    if (false &amp;&amp; vlSelf) {}  // Prevent unused\n    Vtop__Syms* const __restrict vlSymsp VL_ATTR_UNUSED = vlSelf-&gt;vlSymsp;\n    VL_DEBUG_IF(VL_DBG_MSGF(\"+    Vtop___024root__trace_init_sub__TOP__0\\n\"); );\n    // Init\n    const int c = vlSymsp-&gt;__Vm_baseCode;\n    // Body\n    tracep-&gt;declBus(c+1,\"in1\", false,-1, 31,0);\n    tracep-&gt;declBus(c+2,\"in2\", false,-1, 31,0);\n    tracep-&gt;declBus(c+3,\"in3\", false,-1, 31,0);\n    tracep-&gt;declBus(c+4,\"in4\", false,-1, 31,0);\n    tracep-&gt;declBus(c+5,\"sel_i\", false,-1, 1,0);\n    tracep-&gt;declBus(c+6,\"mux_o\", false,-1, 31,0);\n    tracep-&gt;pushNamePrefix(\"dut_param_mux \");\n    tracep-&gt;declBus(c+7,\"in1\", false,-1, 31,0);\n    tracep-&gt;declBus(c+8,\"in2\", false,-1, 31,0);\n    tracep-&gt;declBus(c+9,\"in3\", false,-1, 31,0);\n    tracep-&gt;declBus(c+10,\"in4\", false,-1, 31,0);\n    tracep-&gt;declBus(c+11,\"sel_i\", false,-1, 1,0);\n    tracep-&gt;declBus(c+12,\"mux_o\", false,-1, 31,0);\n    tracep-&gt;pushNamePrefix(\"uut_pmux \");\n    tracep-&gt;declBus(c+19,\"INPUT_WIDTH\", false,-1, 31,0);\n    tracep-&gt;declBus(c+20,\"SELECTOR_WIDTH\", false,-1, 31,0);\n    tracep-&gt;declBus(c+21,\"SIGNAL_COUNT\", false,-1, 31,0);\n    tracep-&gt;declBus(c+13,\"selector\", false,-1, 1,0);\n    for (int i = 0; i &lt; 4; ++i) {\n        tracep-&gt;declBus(c+14+i*1,\"inputs\", true,(i+0), 31,0);\n    }\n    tracep-&gt;declBus(c+18,\"out\", false,-1, 31,0);\n    tracep-&gt;popNamePrefix(2);\n}\n\nVL_ATTR_COLD void Vtop___024root__trace_init_top(Vtop___024root* vlSelf, VerilatedVcd* tracep) {\n    if (false &amp;&amp; vlSelf) {}  // Prevent unused\n    Vtop__Syms* const __restrict vlSymsp VL_ATTR_UNUSED = vlSelf-&gt;vlSymsp;\n    VL_DEBUG_IF(VL_DBG_MSGF(\"+    Vtop___024root__trace_init_top\\n\"); );\n    // Body\n    Vtop___024root__trace_init_sub__TOP__0(vlSelf, tracep);\n}\n\nVL_ATTR_COLD void Vtop___024root__trace_full_top_0(void* voidSelf, VerilatedVcd::Buffer* bufp);\nvoid Vtop___024root__trace_chg_top_0(void* voidSelf, VerilatedVcd::Buffer* bufp);\nvoid Vtop___024root__trace_cleanup(void* voidSelf, VerilatedVcd* /*unused*/);\n\nVL_ATTR_COLD void Vtop___024root__trace_register(Vtop___024root* vlSelf, VerilatedVcd* tracep) {\n    if (false &amp;&amp; vlSelf) {}  // Prevent unused\n    Vtop__Syms* const __restrict vlSymsp VL_ATTR_UNUSED = vlSelf-&gt;vlSymsp;\n    VL_DEBUG_IF(VL_DBG_MSGF(\"+    Vtop___024root__trace_register\\n\"); );\n    // Body\n    tracep-&gt;addFullCb(&amp;Vtop___024root__trace_full_top_0, vlSelf);\n    tracep-&gt;addChgCb(&amp;Vtop___024root__trace_chg_top_0, vlSelf);\n    tracep-&gt;addCleanupCb(&amp;Vtop___024root__trace_cleanup, vlSelf);\n}\n\nVL_ATTR_COLD void Vtop___024root__trace_full_sub_0(Vtop___024root* vlSelf, VerilatedVcd::Buffer* bufp);\n\nVL_ATTR_COLD void Vtop___024root__trace_full_top_0(void* voidSelf, VerilatedVcd::Buffer* bufp) {\n    VL_DEBUG_IF(VL_DBG_MSGF(\"+    Vtop___024root__trace_full_top_0\\n\"); );\n    // Init\n    Vtop___024root* const __restrict vlSelf VL_ATTR_UNUSED = static_cast&lt;Vtop___024root*&gt;(voidSelf);\n    Vtop__Syms* const __restrict vlSymsp VL_ATTR_UNUSED = vlSelf-&gt;vlSymsp;\n    // Body\n    Vtop___024root__trace_full_sub_0((&amp;vlSymsp-&gt;TOP), bufp);\n}\n\nVL_ATTR_COLD void Vtop___024root__trace_full_sub_0(Vtop___024root* vlSelf, VerilatedVcd::Buffer* bufp) {\n    if (false &amp;&amp; vlSelf) {}  // Prevent unused\n    Vtop__Syms* const __restrict vlSymsp VL_ATTR_UNUSED = vlSelf-&gt;vlSymsp;\n    VL_DEBUG_IF(VL_DBG_MSGF(\"+    Vtop___024root__trace_full_sub_0\\n\"); );\n    // Init\n    uint32_t* const oldp VL_ATTR_UNUSED = bufp-&gt;oldp(vlSymsp-&gt;__Vm_baseCode);\n    // Body\n    bufp-&gt;fullIData(oldp+1,(vlSelf-&gt;in1),32);\n    bufp-&gt;fullIData(oldp+2,(vlSelf-&gt;in2),32);\n    bufp-&gt;fullIData(oldp+3,(vlSelf-&gt;in3),32);\n    bufp-&gt;fullIData(oldp+4,(vlSelf-&gt;in4),32);\n    bufp-&gt;fullCData(oldp+5,(vlSelf-&gt;sel_i),2);\n    bufp-&gt;fullIData(oldp+6,(vlSelf-&gt;mux_o),32);\n    bufp-&gt;fullIData(oldp+7,(vlSelf-&gt;dut_param_mux__DOT__in1),32);\n    bufp-&gt;fullIData(oldp+8,(vlSelf-&gt;dut_param_mux__DOT__in2),32);\n    bufp-&gt;fullIData(oldp+9,(vlSelf-&gt;dut_param_mux__DOT__in3),32);\n    bufp-&gt;fullIData(oldp+10,(vlSelf-&gt;dut_param_mux__DOT__in4),32);\n    bufp-&gt;fullCData(oldp+11,(vlSelf-&gt;dut_param_mux__DOT__sel_i),2);\n    bufp-&gt;fullIData(oldp+12,(vlSelf-&gt;dut_param_mux__DOT__mux_o),32);\n    bufp-&gt;fullCData(oldp+13,(vlSelf-&gt;dut_param_mux__DOT__uut_pmux__DOT__selector),2);\n    bufp-&gt;fullIData(oldp+14,(vlSelf-&gt;dut_param_mux__DOT__uut_pmux__DOT__inputs[0]),32);\n    bufp-&gt;fullIData(oldp+15,(vlSelf-&gt;dut_param_mux__DOT__uut_pmux__DOT__inputs[1]),32);\n    bufp-&gt;fullIData(oldp+16,(vlSelf-&gt;dut_param_mux__DOT__uut_pmux__DOT__inputs[2]),32);\n    bufp-&gt;fullIData(oldp+17,(vlSelf-&gt;dut_param_mux__DOT__uut_pmux__DOT__inputs[3]),32);\n    bufp-&gt;fullIData(oldp+18,(vlSelf-&gt;dut_param_mux__DOT__uut_pmux__DOT__out),32);\n    bufp-&gt;fullIData(oldp+19,(0x20U),32);\n    bufp-&gt;fullIData(oldp+20,(2U),32);\n    bufp-&gt;fullIData(oldp+21,(4U),32);\n}\n</code></pre>"},{"location":"TitanComms/Vtop______024root_8h/","title":"File Vtop___024root.h","text":"<p>FileList &gt; comms &gt; verilog &gt; tests &gt; sim_build &gt; Vtop___024root.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"verilated.h\"</code></li> <li><code>#include \"verilated_timing.h\"</code></li> </ul>"},{"location":"TitanComms/Vtop______024root_8h/#classes","title":"Classes","text":"Type Name class Vtop___024root"},{"location":"TitanComms/Vtop______024root_8h/#public-attributes","title":"Public Attributes","text":"Type Name CData __VactContinue IData __VactIterCount VlTriggerVec&lt; 1 &gt; __VactTriggered VlDelayScheduler __VdlySched IData __VicoIterCount VlTriggerVec&lt; 1 &gt; __VicoTriggered VlTriggerVec&lt; 1 &gt; __VnbaTriggered IData __VstlIterCount VlTriggerVec&lt; 1 &gt; __VstlTriggered VlUnpacked&lt; IData, 4 &gt; dut_param_mux__DOT____Vcellinp__uut_pmux__inputs IData dut_param_mux__DOT__in1 IData dut_param_mux__DOT__in2 IData dut_param_mux__DOT__in3 IData dut_param_mux__DOT__in4 IData dut_param_mux__DOT__mux_o CData dut_param_mux__DOT__sel_i VlUnpacked&lt; IData, 4 &gt; dut_param_mux__DOT__uut_pmux__DOT__inputs IData dut_param_mux__DOT__uut_pmux__DOT__out CData dut_param_mux__DOT__uut_pmux__DOT__selector Vtop__Syms *const vlSymsp"},{"location":"TitanComms/Vtop______024root_8h/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr IData dut_param_mux__DOT__uut_pmux__DOT__INPUT_WIDTH   = = 0x00000020U constexpr IData dut_param_mux__DOT__uut_pmux__DOT__SELECTOR_WIDTH   = = 2U constexpr IData dut_param_mux__DOT__uut_pmux__DOT__SIGNAL_COUNT   = = 4U"},{"location":"TitanComms/Vtop______024root_8h/#public-functions","title":"Public Functions","text":"Type Name Vtop___024root VerilatedModule VL_ATTR_ALIGNED (VL_CACHE_LINE_BYTES)  VL_IN (in1, 31, 0)  VL_IN (in2, 31, 0)  VL_IN (in3, 31, 0)  VL_IN (in4, 31, 0)  VL_IN8 (sel_i, 1, 0)  VL_OUT (mux_o, 31, 0)  VL_UNCOPYABLE (Vtop___024root)  Vtop___024root (Vtop__Syms * symsp, const char * v__name)  void __Vconfigure (bool first)  ~Vtop___024root ()"},{"location":"TitanComms/Vtop______024root_8h/#macros","title":"Macros","text":"Type Name define VERILATED_VTOP___024ROOT_H_"},{"location":"TitanComms/Vtop______024root_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"TitanComms/Vtop______024root_8h/#variable-__vactcontinue","title":"variable __VactContinue","text":"<pre><code>CData __VactContinue;\n</code></pre>"},{"location":"TitanComms/Vtop______024root_8h/#variable-__vactitercount","title":"variable __VactIterCount","text":"<pre><code>IData __VactIterCount;\n</code></pre>"},{"location":"TitanComms/Vtop______024root_8h/#variable-__vacttriggered","title":"variable __VactTriggered","text":"<pre><code>VlTriggerVec&lt;1&gt; __VactTriggered;\n</code></pre>"},{"location":"TitanComms/Vtop______024root_8h/#variable-__vdlysched","title":"variable __VdlySched","text":"<pre><code>VlDelayScheduler __VdlySched;\n</code></pre>"},{"location":"TitanComms/Vtop______024root_8h/#variable-__vicoitercount","title":"variable __VicoIterCount","text":"<pre><code>IData __VicoIterCount;\n</code></pre>"},{"location":"TitanComms/Vtop______024root_8h/#variable-__vicotriggered","title":"variable __VicoTriggered","text":"<pre><code>VlTriggerVec&lt;1&gt; __VicoTriggered;\n</code></pre>"},{"location":"TitanComms/Vtop______024root_8h/#variable-__vnbatriggered","title":"variable __VnbaTriggered","text":"<pre><code>VlTriggerVec&lt;1&gt; __VnbaTriggered;\n</code></pre>"},{"location":"TitanComms/Vtop______024root_8h/#variable-__vstlitercount","title":"variable __VstlIterCount","text":"<pre><code>IData __VstlIterCount;\n</code></pre>"},{"location":"TitanComms/Vtop______024root_8h/#variable-__vstltriggered","title":"variable __VstlTriggered","text":"<pre><code>VlTriggerVec&lt;1&gt; __VstlTriggered;\n</code></pre>"},{"location":"TitanComms/Vtop______024root_8h/#variable-dut_param_mux__dot____vcellinp__uut_pmux__inputs","title":"variable dut_param_mux__DOT____Vcellinp__uut_pmux__inputs","text":"<pre><code>VlUnpacked&lt;IData, 4&gt; dut_param_mux__DOT____Vcellinp__uut_pmux__inputs;\n</code></pre>"},{"location":"TitanComms/Vtop______024root_8h/#variable-dut_param_mux__dot__in1","title":"variable dut_param_mux__DOT__in1","text":"<pre><code>IData dut_param_mux__DOT__in1;\n</code></pre>"},{"location":"TitanComms/Vtop______024root_8h/#variable-dut_param_mux__dot__in2","title":"variable dut_param_mux__DOT__in2","text":"<pre><code>IData dut_param_mux__DOT__in2;\n</code></pre>"},{"location":"TitanComms/Vtop______024root_8h/#variable-dut_param_mux__dot__in3","title":"variable dut_param_mux__DOT__in3","text":"<pre><code>IData dut_param_mux__DOT__in3;\n</code></pre>"},{"location":"TitanComms/Vtop______024root_8h/#variable-dut_param_mux__dot__in4","title":"variable dut_param_mux__DOT__in4","text":"<pre><code>IData dut_param_mux__DOT__in4;\n</code></pre>"},{"location":"TitanComms/Vtop______024root_8h/#variable-dut_param_mux__dot__mux_o","title":"variable dut_param_mux__DOT__mux_o","text":"<pre><code>IData dut_param_mux__DOT__mux_o;\n</code></pre>"},{"location":"TitanComms/Vtop______024root_8h/#variable-dut_param_mux__dot__sel_i","title":"variable dut_param_mux__DOT__sel_i","text":"<pre><code>CData dut_param_mux__DOT__sel_i;\n</code></pre>"},{"location":"TitanComms/Vtop______024root_8h/#variable-dut_param_mux__dot__uut_pmux__dot__inputs","title":"variable dut_param_mux__DOT__uut_pmux__DOT__inputs","text":"<pre><code>VlUnpacked&lt;IData, 4&gt; dut_param_mux__DOT__uut_pmux__DOT__inputs;\n</code></pre>"},{"location":"TitanComms/Vtop______024root_8h/#variable-dut_param_mux__dot__uut_pmux__dot__out","title":"variable dut_param_mux__DOT__uut_pmux__DOT__out","text":"<pre><code>IData dut_param_mux__DOT__uut_pmux__DOT__out;\n</code></pre>"},{"location":"TitanComms/Vtop______024root_8h/#variable-dut_param_mux__dot__uut_pmux__dot__selector","title":"variable dut_param_mux__DOT__uut_pmux__DOT__selector","text":"<pre><code>CData dut_param_mux__DOT__uut_pmux__DOT__selector;\n</code></pre>"},{"location":"TitanComms/Vtop______024root_8h/#variable-vlsymsp","title":"variable vlSymsp","text":"<pre><code>Vtop__Syms* const vlSymsp;\n</code></pre>"},{"location":"TitanComms/Vtop______024root_8h/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"TitanComms/Vtop______024root_8h/#variable-dut_param_mux__dot__uut_pmux__dot__input_width","title":"variable dut_param_mux__DOT__uut_pmux__DOT__INPUT_WIDTH","text":"<pre><code>constexpr IData dut_param_mux__DOT__uut_pmux__DOT__INPUT_WIDTH;\n</code></pre>"},{"location":"TitanComms/Vtop______024root_8h/#variable-dut_param_mux__dot__uut_pmux__dot__selector_width","title":"variable dut_param_mux__DOT__uut_pmux__DOT__SELECTOR_WIDTH","text":"<pre><code>constexpr IData dut_param_mux__DOT__uut_pmux__DOT__SELECTOR_WIDTH;\n</code></pre>"},{"location":"TitanComms/Vtop______024root_8h/#variable-dut_param_mux__dot__uut_pmux__dot__signal_count","title":"variable dut_param_mux__DOT__uut_pmux__DOT__SIGNAL_COUNT","text":"<pre><code>constexpr IData dut_param_mux__DOT__uut_pmux__DOT__SIGNAL_COUNT;\n</code></pre>"},{"location":"TitanComms/Vtop______024root_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"TitanComms/Vtop______024root_8h/#function-vl_attr_aligned","title":"function VL_ATTR_ALIGNED","text":"<pre><code>Vtop___024root VerilatedModule VL_ATTR_ALIGNED (\n    VL_CACHE_LINE_BYTES\n) \n</code></pre>"},{"location":"TitanComms/Vtop______024root_8h/#function-vl_in","title":"function VL_IN","text":"<pre><code>VL_IN (\n    in1,\n    31,\n    0\n) \n</code></pre>"},{"location":"TitanComms/Vtop______024root_8h/#function-vl_in_1","title":"function VL_IN","text":"<pre><code>VL_IN (\n    in2,\n    31,\n    0\n) \n</code></pre>"},{"location":"TitanComms/Vtop______024root_8h/#function-vl_in_2","title":"function VL_IN","text":"<pre><code>VL_IN (\n    in3,\n    31,\n    0\n) \n</code></pre>"},{"location":"TitanComms/Vtop______024root_8h/#function-vl_in_3","title":"function VL_IN","text":"<pre><code>VL_IN (\n    in4,\n    31,\n    0\n) \n</code></pre>"},{"location":"TitanComms/Vtop______024root_8h/#function-vl_in8","title":"function VL_IN8","text":"<pre><code>VL_IN8 (\n    sel_i,\n    1,\n    0\n) \n</code></pre>"},{"location":"TitanComms/Vtop______024root_8h/#function-vl_out","title":"function VL_OUT","text":"<pre><code>VL_OUT (\n    mux_o,\n    31,\n    0\n) \n</code></pre>"},{"location":"TitanComms/Vtop______024root_8h/#function-vl_uncopyable","title":"function VL_UNCOPYABLE","text":"<pre><code>VL_UNCOPYABLE (\n    Vtop___024root\n) \n</code></pre>"},{"location":"TitanComms/Vtop______024root_8h/#function-vtop___024root","title":"function Vtop___024root","text":"<pre><code>Vtop___024root (\n    Vtop__Syms * symsp,\n    const char * v__name\n) \n</code></pre>"},{"location":"TitanComms/Vtop______024root_8h/#function-__vconfigure","title":"function __Vconfigure","text":"<pre><code>void __Vconfigure (\n    bool first\n) \n</code></pre>"},{"location":"TitanComms/Vtop______024root_8h/#function-vtop___024root_1","title":"function ~Vtop___024root","text":"<pre><code>~Vtop___024root () \n</code></pre>"},{"location":"TitanComms/Vtop______024root_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"TitanComms/Vtop______024root_8h/#define-verilated_vtop___024root_h_","title":"define VERILATED_VTOP___024ROOT_H_","text":"<pre><code>#define VERILATED_VTOP___024ROOT_H_ \n</code></pre> <p>The documentation for this class was generated from the following file <code>titan/comms/verilog/tests/sim_build/Vtop___024root.h</code></p>"},{"location":"TitanComms/Vtop______024root_8h_source/","title":"File Vtop___024root.h","text":"<p>File List &gt; comms &gt; verilog &gt; tests &gt; sim_build &gt; Vtop___024root.h</p> <p>Go to the documentation of this file</p> <pre><code>// Verilated -*- C++ -*-\n// DESCRIPTION: Verilator output: Design internal header\n// See Vtop.h for the primary calling header\n\n#ifndef VERILATED_VTOP___024ROOT_H_\n#define VERILATED_VTOP___024ROOT_H_  // guard\n\n#include \"verilated.h\"\n#include \"verilated_timing.h\"\n\nclass Vtop__Syms;\n\nclass Vtop___024root final : public VerilatedModule {\n  public:\n\n    // DESIGN SPECIFIC STATE\n    VL_IN8(sel_i,1,0);\n    CData/*1:0*/ dut_param_mux__DOT__sel_i;\n    CData/*1:0*/ dut_param_mux__DOT__uut_pmux__DOT__selector;\n    CData/*0:0*/ __VactContinue;\n    VL_IN(in1,31,0);\n    VL_IN(in2,31,0);\n    VL_IN(in3,31,0);\n    VL_IN(in4,31,0);\n    VL_OUT(mux_o,31,0);\n    IData/*31:0*/ dut_param_mux__DOT__in1;\n    IData/*31:0*/ dut_param_mux__DOT__in2;\n    IData/*31:0*/ dut_param_mux__DOT__in3;\n    IData/*31:0*/ dut_param_mux__DOT__in4;\n    IData/*31:0*/ dut_param_mux__DOT__mux_o;\n    IData/*31:0*/ dut_param_mux__DOT__uut_pmux__DOT__out;\n    IData/*31:0*/ __VstlIterCount;\n    IData/*31:0*/ __VicoIterCount;\n    IData/*31:0*/ __VactIterCount;\n    VlUnpacked&lt;IData/*31:0*/, 4&gt; dut_param_mux__DOT____Vcellinp__uut_pmux__inputs;\n    VlUnpacked&lt;IData/*31:0*/, 4&gt; dut_param_mux__DOT__uut_pmux__DOT__inputs;\n    VlDelayScheduler __VdlySched;\n    VlTriggerVec&lt;1&gt; __VstlTriggered;\n    VlTriggerVec&lt;1&gt; __VicoTriggered;\n    VlTriggerVec&lt;1&gt; __VactTriggered;\n    VlTriggerVec&lt;1&gt; __VnbaTriggered;\n\n    // INTERNAL VARIABLES\n    Vtop__Syms* const vlSymsp;\n\n    // PARAMETERS\n    static constexpr IData/*31:0*/ dut_param_mux__DOT__uut_pmux__DOT__INPUT_WIDTH = 0x00000020U;\n    static constexpr IData/*31:0*/ dut_param_mux__DOT__uut_pmux__DOT__SELECTOR_WIDTH = 2U;\n    static constexpr IData/*31:0*/ dut_param_mux__DOT__uut_pmux__DOT__SIGNAL_COUNT = 4U;\n\n    // CONSTRUCTORS\n    Vtop___024root(Vtop__Syms* symsp, const char* v__name);\n    ~Vtop___024root();\n    VL_UNCOPYABLE(Vtop___024root);\n\n    // INTERNAL METHODS\n    void __Vconfigure(bool first);\n} VL_ATTR_ALIGNED(VL_CACHE_LINE_BYTES);\n\n\n#endif  // guard\n</code></pre>"},{"location":"TitanComms/Vtop______024root____DepSet__h84412442____0_8cpp/","title":"File Vtop___024root__DepSet_h84412442__0.cpp","text":"<p>FileList &gt; comms &gt; verilog &gt; tests &gt; sim_build &gt; Vtop___024root__DepSet_h84412442__0.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"verilated.h\"</code></li> <li><code>#include \"verilated_dpi.h\"</code></li> <li><code>#include \"Vtop__Syms.h\"</code></li> <li><code>#include \"Vtop___024root.h\"</code></li> </ul>"},{"location":"TitanComms/Vtop______024root____DepSet__h84412442____0_8cpp/#public-functions","title":"Public Functions","text":"Type Name VL_INLINE_OPT VlCoroutine Vtop___024root___eval_initial__TOP__0 (Vtop___024root * vlSelf)  void Vtop___024root___eval_triggers__act (Vtop___024root * vlSelf)  void Vtop___024root___eval_triggers__ico (Vtop___024root * vlSelf)"},{"location":"TitanComms/Vtop______024root____DepSet__h84412442____0_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"TitanComms/Vtop______024root____DepSet__h84412442____0_8cpp/#function-vtop___024root___eval_initial__top__0","title":"function Vtop___024root___eval_initial__TOP__0","text":"<pre><code>VL_INLINE_OPT VlCoroutine Vtop___024root___eval_initial__TOP__0 (\n    Vtop___024root * vlSelf\n) \n</code></pre>"},{"location":"TitanComms/Vtop______024root____DepSet__h84412442____0_8cpp/#function-vtop___024root___eval_triggers__act","title":"function Vtop___024root___eval_triggers__act","text":"<pre><code>void Vtop___024root___eval_triggers__act (\n    Vtop___024root * vlSelf\n) \n</code></pre>"},{"location":"TitanComms/Vtop______024root____DepSet__h84412442____0_8cpp/#function-vtop___024root___eval_triggers__ico","title":"function Vtop___024root___eval_triggers__ico","text":"<pre><code>void Vtop___024root___eval_triggers__ico (\n    Vtop___024root * vlSelf\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>titan/comms/verilog/tests/sim_build/Vtop___024root__DepSet_h84412442__0.cpp</code></p>"},{"location":"TitanComms/Vtop______024root____DepSet__h84412442____0_8cpp_source/","title":"File Vtop___024root__DepSet_h84412442__0.cpp","text":"<p>File List &gt; comms &gt; verilog &gt; tests &gt; sim_build &gt; Vtop___024root__DepSet_h84412442__0.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// Verilated -*- C++ -*-\n// DESCRIPTION: Verilator output: Design implementation internals\n// See Vtop.h for the primary calling header\n\n#include \"verilated.h\"\n#include \"verilated_dpi.h\"\n\n#include \"Vtop__Syms.h\"\n#include \"Vtop___024root.h\"\n\nVL_INLINE_OPT VlCoroutine Vtop___024root___eval_initial__TOP__0(Vtop___024root* vlSelf) {\n    if (false &amp;&amp; vlSelf) {}  // Prevent unused\n    Vtop__Syms* const __restrict vlSymsp VL_ATTR_UNUSED = vlSelf-&gt;vlSymsp;\n    VL_DEBUG_IF(VL_DBG_MSGF(\"+    Vtop___024root___eval_initial__TOP__0\\n\"); );\n    // Init\n    VlWide&lt;6&gt;/*191:0*/ __Vtemp_h513746c2__0;\n    // Body\n    __Vtemp_h513746c2__0[0U] = 0x2e766364U;\n    __Vtemp_h513746c2__0[1U] = 0x5f6d7578U;\n    __Vtemp_h513746c2__0[2U] = 0x6172616dU;\n    __Vtemp_h513746c2__0[3U] = 0x75745f70U;\n    __Vtemp_h513746c2__0[4U] = 0x65735f64U;\n    __Vtemp_h513746c2__0[5U] = 0x776176U;\n    vlSymsp-&gt;_vm_contextp__-&gt;dumpfile(VL_CVT_PACK_STR_NW(6, __Vtemp_h513746c2__0));\n    vlSymsp-&gt;_traceDumpOpen();\n    co_await vlSelf-&gt;__VdlySched.delay(0x3e8U, \"/home/kris/repos/titan/titan/comms/verilog/tests/dut_param_mux.sv\", \n                                       12);\n}\n\n#ifdef VL_DEBUG\nVL_ATTR_COLD void Vtop___024root___dump_triggers__ico(Vtop___024root* vlSelf);\n#endif  // VL_DEBUG\n\nvoid Vtop___024root___eval_triggers__ico(Vtop___024root* vlSelf) {\n    if (false &amp;&amp; vlSelf) {}  // Prevent unused\n    Vtop__Syms* const __restrict vlSymsp VL_ATTR_UNUSED = vlSelf-&gt;vlSymsp;\n    VL_DEBUG_IF(VL_DBG_MSGF(\"+    Vtop___024root___eval_triggers__ico\\n\"); );\n    // Body\n    vlSelf-&gt;__VicoTriggered.at(0U) = (0U == vlSelf-&gt;__VicoIterCount);\n#ifdef VL_DEBUG\n    if (VL_UNLIKELY(vlSymsp-&gt;_vm_contextp__-&gt;debug())) {\n        Vtop___024root___dump_triggers__ico(vlSelf);\n    }\n#endif\n}\n\n#ifdef VL_DEBUG\nVL_ATTR_COLD void Vtop___024root___dump_triggers__act(Vtop___024root* vlSelf);\n#endif  // VL_DEBUG\n\nvoid Vtop___024root___eval_triggers__act(Vtop___024root* vlSelf) {\n    if (false &amp;&amp; vlSelf) {}  // Prevent unused\n    Vtop__Syms* const __restrict vlSymsp VL_ATTR_UNUSED = vlSelf-&gt;vlSymsp;\n    VL_DEBUG_IF(VL_DBG_MSGF(\"+    Vtop___024root___eval_triggers__act\\n\"); );\n    // Body\n    vlSelf-&gt;__VactTriggered.at(0U) = vlSelf-&gt;__VdlySched.awaitingCurrentTime();\n#ifdef VL_DEBUG\n    if (VL_UNLIKELY(vlSymsp-&gt;_vm_contextp__-&gt;debug())) {\n        Vtop___024root___dump_triggers__act(vlSelf);\n    }\n#endif\n}\n</code></pre>"},{"location":"TitanComms/Vtop______024root____DepSet__h84412442____0____Slow_8cpp/","title":"File Vtop___024root__DepSet_h84412442__0__Slow.cpp","text":"<p>FileList &gt; comms &gt; verilog &gt; tests &gt; sim_build &gt; Vtop___024root__DepSet_h84412442__0__Slow.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"verilated.h\"</code></li> <li><code>#include \"verilated_dpi.h\"</code></li> <li><code>#include \"Vtop__Syms.h\"</code></li> <li><code>#include \"Vtop___024root.h\"</code></li> </ul>"},{"location":"TitanComms/Vtop______024root____DepSet__h84412442____0____Slow_8cpp/#public-functions","title":"Public Functions","text":"Type Name VL_ATTR_COLD void Vtop___024root___eval_triggers__stl (Vtop___024root * vlSelf)"},{"location":"TitanComms/Vtop______024root____DepSet__h84412442____0____Slow_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"TitanComms/Vtop______024root____DepSet__h84412442____0____Slow_8cpp/#function-vtop___024root___eval_triggers__stl","title":"function Vtop___024root___eval_triggers__stl","text":"<pre><code>VL_ATTR_COLD void Vtop___024root___eval_triggers__stl (\n    Vtop___024root * vlSelf\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>titan/comms/verilog/tests/sim_build/Vtop___024root__DepSet_h84412442__0__Slow.cpp</code></p>"},{"location":"TitanComms/Vtop______024root____DepSet__h84412442____0____Slow_8cpp_source/","title":"File Vtop___024root__DepSet_h84412442__0__Slow.cpp","text":"<p>File List &gt; comms &gt; verilog &gt; tests &gt; sim_build &gt; Vtop___024root__DepSet_h84412442__0__Slow.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// Verilated -*- C++ -*-\n// DESCRIPTION: Verilator output: Design implementation internals\n// See Vtop.h for the primary calling header\n\n#include \"verilated.h\"\n#include \"verilated_dpi.h\"\n\n#include \"Vtop__Syms.h\"\n#include \"Vtop___024root.h\"\n\n#ifdef VL_DEBUG\nVL_ATTR_COLD void Vtop___024root___dump_triggers__stl(Vtop___024root* vlSelf);\n#endif  // VL_DEBUG\n\nVL_ATTR_COLD void Vtop___024root___eval_triggers__stl(Vtop___024root* vlSelf) {\n    if (false &amp;&amp; vlSelf) {}  // Prevent unused\n    Vtop__Syms* const __restrict vlSymsp VL_ATTR_UNUSED = vlSelf-&gt;vlSymsp;\n    VL_DEBUG_IF(VL_DBG_MSGF(\"+    Vtop___024root___eval_triggers__stl\\n\"); );\n    // Body\n    vlSelf-&gt;__VstlTriggered.at(0U) = (0U == vlSelf-&gt;__VstlIterCount);\n#ifdef VL_DEBUG\n    if (VL_UNLIKELY(vlSymsp-&gt;_vm_contextp__-&gt;debug())) {\n        Vtop___024root___dump_triggers__stl(vlSelf);\n    }\n#endif\n}\n</code></pre>"},{"location":"TitanComms/Vtop______024root____DepSet__heccd7ead____0_8cpp/","title":"File Vtop___024root__DepSet_heccd7ead__0.cpp","text":"<p>FileList &gt; comms &gt; verilog &gt; tests &gt; sim_build &gt; Vtop___024root__DepSet_heccd7ead__0.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"verilated.h\"</code></li> <li><code>#include \"verilated_dpi.h\"</code></li> <li><code>#include \"Vtop___024root.h\"</code></li> </ul>"},{"location":"TitanComms/Vtop______024root____DepSet__heccd7ead____0_8cpp/#public-functions","title":"Public Functions","text":"Type Name void Vtop___024root___eval (Vtop___024root * vlSelf)  void Vtop___024root___eval_act (Vtop___024root * vlSelf)  void Vtop___024root___eval_ico (Vtop___024root * vlSelf)  void Vtop___024root___eval_initial (Vtop___024root * vlSelf)  VlCoroutine Vtop___024root___eval_initial__TOP__0 (Vtop___024root * vlSelf)  void Vtop___024root___eval_nba (Vtop___024root * vlSelf)  void Vtop___024root___eval_triggers__act (Vtop___024root * vlSelf)  void Vtop___024root___eval_triggers__ico (Vtop___024root * vlSelf)  VL_INLINE_OPT void Vtop___024root___ico_sequent__TOP__0 (Vtop___024root * vlSelf)  void Vtop___024root___timing_resume (Vtop___024root * vlSelf)"},{"location":"TitanComms/Vtop______024root____DepSet__heccd7ead____0_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"TitanComms/Vtop______024root____DepSet__heccd7ead____0_8cpp/#function-vtop___024root___eval","title":"function Vtop___024root___eval","text":"<pre><code>void Vtop___024root___eval (\n    Vtop___024root * vlSelf\n) \n</code></pre>"},{"location":"TitanComms/Vtop______024root____DepSet__heccd7ead____0_8cpp/#function-vtop___024root___eval_act","title":"function Vtop___024root___eval_act","text":"<pre><code>void Vtop___024root___eval_act (\n    Vtop___024root * vlSelf\n) \n</code></pre>"},{"location":"TitanComms/Vtop______024root____DepSet__heccd7ead____0_8cpp/#function-vtop___024root___eval_ico","title":"function Vtop___024root___eval_ico","text":"<pre><code>void Vtop___024root___eval_ico (\n    Vtop___024root * vlSelf\n) \n</code></pre>"},{"location":"TitanComms/Vtop______024root____DepSet__heccd7ead____0_8cpp/#function-vtop___024root___eval_initial","title":"function Vtop___024root___eval_initial","text":"<pre><code>void Vtop___024root___eval_initial (\n    Vtop___024root * vlSelf\n) \n</code></pre>"},{"location":"TitanComms/Vtop______024root____DepSet__heccd7ead____0_8cpp/#function-vtop___024root___eval_initial__top__0","title":"function Vtop___024root___eval_initial__TOP__0","text":"<pre><code>VlCoroutine Vtop___024root___eval_initial__TOP__0 (\n    Vtop___024root * vlSelf\n) \n</code></pre>"},{"location":"TitanComms/Vtop______024root____DepSet__heccd7ead____0_8cpp/#function-vtop___024root___eval_nba","title":"function Vtop___024root___eval_nba","text":"<pre><code>void Vtop___024root___eval_nba (\n    Vtop___024root * vlSelf\n) \n</code></pre>"},{"location":"TitanComms/Vtop______024root____DepSet__heccd7ead____0_8cpp/#function-vtop___024root___eval_triggers__act","title":"function Vtop___024root___eval_triggers__act","text":"<pre><code>void Vtop___024root___eval_triggers__act (\n    Vtop___024root * vlSelf\n) \n</code></pre>"},{"location":"TitanComms/Vtop______024root____DepSet__heccd7ead____0_8cpp/#function-vtop___024root___eval_triggers__ico","title":"function Vtop___024root___eval_triggers__ico","text":"<pre><code>void Vtop___024root___eval_triggers__ico (\n    Vtop___024root * vlSelf\n) \n</code></pre>"},{"location":"TitanComms/Vtop______024root____DepSet__heccd7ead____0_8cpp/#function-vtop___024root___ico_sequent__top__0","title":"function Vtop___024root___ico_sequent__TOP__0","text":"<pre><code>VL_INLINE_OPT void Vtop___024root___ico_sequent__TOP__0 (\n    Vtop___024root * vlSelf\n) \n</code></pre>"},{"location":"TitanComms/Vtop______024root____DepSet__heccd7ead____0_8cpp/#function-vtop___024root___timing_resume","title":"function Vtop___024root___timing_resume","text":"<pre><code>void Vtop___024root___timing_resume (\n    Vtop___024root * vlSelf\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>titan/comms/verilog/tests/sim_build/Vtop___024root__DepSet_heccd7ead__0.cpp</code></p>"},{"location":"TitanComms/Vtop______024root____DepSet__heccd7ead____0_8cpp_source/","title":"File Vtop___024root__DepSet_heccd7ead__0.cpp","text":"<p>File List &gt; comms &gt; verilog &gt; tests &gt; sim_build &gt; Vtop___024root__DepSet_heccd7ead__0.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// Verilated -*- C++ -*-\n// DESCRIPTION: Verilator output: Design implementation internals\n// See Vtop.h for the primary calling header\n\n#include \"verilated.h\"\n#include \"verilated_dpi.h\"\n\n#include \"Vtop___024root.h\"\n\nVlCoroutine Vtop___024root___eval_initial__TOP__0(Vtop___024root* vlSelf);\n\nvoid Vtop___024root___eval_initial(Vtop___024root* vlSelf) {\n    if (false &amp;&amp; vlSelf) {}  // Prevent unused\n    Vtop__Syms* const __restrict vlSymsp VL_ATTR_UNUSED = vlSelf-&gt;vlSymsp;\n    VL_DEBUG_IF(VL_DBG_MSGF(\"+    Vtop___024root___eval_initial\\n\"); );\n    // Body\n    Vtop___024root___eval_initial__TOP__0(vlSelf);\n}\n\nVL_INLINE_OPT void Vtop___024root___ico_sequent__TOP__0(Vtop___024root* vlSelf) {\n    if (false &amp;&amp; vlSelf) {}  // Prevent unused\n    Vtop__Syms* const __restrict vlSymsp VL_ATTR_UNUSED = vlSelf-&gt;vlSymsp;\n    VL_DEBUG_IF(VL_DBG_MSGF(\"+    Vtop___024root___ico_sequent__TOP__0\\n\"); );\n    // Body\n    vlSelf-&gt;dut_param_mux__DOT__in1 = vlSelf-&gt;in1;\n    vlSelf-&gt;dut_param_mux__DOT__in2 = vlSelf-&gt;in2;\n    vlSelf-&gt;dut_param_mux__DOT__in3 = vlSelf-&gt;in3;\n    vlSelf-&gt;dut_param_mux__DOT__in4 = vlSelf-&gt;in4;\n    vlSelf-&gt;dut_param_mux__DOT__sel_i = vlSelf-&gt;sel_i;\n    vlSelf-&gt;dut_param_mux__DOT____Vcellinp__uut_pmux__inputs[0U] \n        = vlSelf-&gt;in1;\n    vlSelf-&gt;dut_param_mux__DOT____Vcellinp__uut_pmux__inputs[1U] \n        = vlSelf-&gt;in2;\n    vlSelf-&gt;dut_param_mux__DOT____Vcellinp__uut_pmux__inputs[2U] \n        = vlSelf-&gt;in3;\n    vlSelf-&gt;dut_param_mux__DOT____Vcellinp__uut_pmux__inputs[3U] \n        = vlSelf-&gt;in4;\n    vlSelf-&gt;dut_param_mux__DOT__uut_pmux__DOT__selector \n        = vlSelf-&gt;dut_param_mux__DOT__sel_i;\n    vlSelf-&gt;dut_param_mux__DOT__uut_pmux__DOT__inputs[0U] \n        = vlSelf-&gt;dut_param_mux__DOT____Vcellinp__uut_pmux__inputs\n        [0U];\n    vlSelf-&gt;dut_param_mux__DOT__uut_pmux__DOT__inputs[1U] \n        = vlSelf-&gt;dut_param_mux__DOT____Vcellinp__uut_pmux__inputs\n        [1U];\n    vlSelf-&gt;dut_param_mux__DOT__uut_pmux__DOT__inputs[2U] \n        = vlSelf-&gt;dut_param_mux__DOT____Vcellinp__uut_pmux__inputs\n        [2U];\n    vlSelf-&gt;dut_param_mux__DOT__uut_pmux__DOT__inputs[3U] \n        = vlSelf-&gt;dut_param_mux__DOT____Vcellinp__uut_pmux__inputs\n        [3U];\n    vlSelf-&gt;mux_o = vlSelf-&gt;dut_param_mux__DOT____Vcellinp__uut_pmux__inputs\n        [vlSelf-&gt;sel_i];\n    vlSelf-&gt;dut_param_mux__DOT__mux_o = vlSelf-&gt;mux_o;\n    vlSelf-&gt;dut_param_mux__DOT__uut_pmux__DOT__out \n        = vlSelf-&gt;mux_o;\n}\n\nvoid Vtop___024root___eval_ico(Vtop___024root* vlSelf) {\n    if (false &amp;&amp; vlSelf) {}  // Prevent unused\n    Vtop__Syms* const __restrict vlSymsp VL_ATTR_UNUSED = vlSelf-&gt;vlSymsp;\n    VL_DEBUG_IF(VL_DBG_MSGF(\"+    Vtop___024root___eval_ico\\n\"); );\n    // Body\n    if (vlSelf-&gt;__VicoTriggered.at(0U)) {\n        Vtop___024root___ico_sequent__TOP__0(vlSelf);\n    }\n}\n\nvoid Vtop___024root___eval_act(Vtop___024root* vlSelf) {\n    if (false &amp;&amp; vlSelf) {}  // Prevent unused\n    Vtop__Syms* const __restrict vlSymsp VL_ATTR_UNUSED = vlSelf-&gt;vlSymsp;\n    VL_DEBUG_IF(VL_DBG_MSGF(\"+    Vtop___024root___eval_act\\n\"); );\n}\n\nvoid Vtop___024root___eval_nba(Vtop___024root* vlSelf) {\n    if (false &amp;&amp; vlSelf) {}  // Prevent unused\n    Vtop__Syms* const __restrict vlSymsp VL_ATTR_UNUSED = vlSelf-&gt;vlSymsp;\n    VL_DEBUG_IF(VL_DBG_MSGF(\"+    Vtop___024root___eval_nba\\n\"); );\n}\n\nvoid Vtop___024root___eval_triggers__ico(Vtop___024root* vlSelf);\n#ifdef VL_DEBUG\nVL_ATTR_COLD void Vtop___024root___dump_triggers__ico(Vtop___024root* vlSelf);\n#endif  // VL_DEBUG\nvoid Vtop___024root___eval_triggers__act(Vtop___024root* vlSelf);\n#ifdef VL_DEBUG\nVL_ATTR_COLD void Vtop___024root___dump_triggers__act(Vtop___024root* vlSelf);\n#endif  // VL_DEBUG\nvoid Vtop___024root___timing_resume(Vtop___024root* vlSelf);\n#ifdef VL_DEBUG\nVL_ATTR_COLD void Vtop___024root___dump_triggers__nba(Vtop___024root* vlSelf);\n#endif  // VL_DEBUG\n\nvoid Vtop___024root___eval(Vtop___024root* vlSelf) {\n    if (false &amp;&amp; vlSelf) {}  // Prevent unused\n    Vtop__Syms* const __restrict vlSymsp VL_ATTR_UNUSED = vlSelf-&gt;vlSymsp;\n    VL_DEBUG_IF(VL_DBG_MSGF(\"+    Vtop___024root___eval\\n\"); );\n    // Init\n    CData/*0:0*/ __VicoContinue;\n    VlTriggerVec&lt;1&gt; __VpreTriggered;\n    IData/*31:0*/ __VnbaIterCount;\n    CData/*0:0*/ __VnbaContinue;\n    // Body\n    vlSelf-&gt;__VicoIterCount = 0U;\n    __VicoContinue = 1U;\n    while (__VicoContinue) {\n        __VicoContinue = 0U;\n        Vtop___024root___eval_triggers__ico(vlSelf);\n        if (vlSelf-&gt;__VicoTriggered.any()) {\n            __VicoContinue = 1U;\n            if (VL_UNLIKELY((0x64U &lt; vlSelf-&gt;__VicoIterCount))) {\n#ifdef VL_DEBUG\n                Vtop___024root___dump_triggers__ico(vlSelf);\n#endif\n                VL_FATAL_MT(\"/home/kris/repos/titan/titan/comms/verilog/tests/dut_param_mux.sv\", 1, \"\", \"Input combinational region did not converge.\");\n            }\n            vlSelf-&gt;__VicoIterCount = ((IData)(1U) \n                                       + vlSelf-&gt;__VicoIterCount);\n            Vtop___024root___eval_ico(vlSelf);\n        }\n    }\n    __VnbaIterCount = 0U;\n    __VnbaContinue = 1U;\n    while (__VnbaContinue) {\n        __VnbaContinue = 0U;\n        vlSelf-&gt;__VnbaTriggered.clear();\n        vlSelf-&gt;__VactIterCount = 0U;\n        vlSelf-&gt;__VactContinue = 1U;\n        while (vlSelf-&gt;__VactContinue) {\n            vlSelf-&gt;__VactContinue = 0U;\n            Vtop___024root___eval_triggers__act(vlSelf);\n            if (vlSelf-&gt;__VactTriggered.any()) {\n                vlSelf-&gt;__VactContinue = 1U;\n                if (VL_UNLIKELY((0x64U &lt; vlSelf-&gt;__VactIterCount))) {\n#ifdef VL_DEBUG\n                    Vtop___024root___dump_triggers__act(vlSelf);\n#endif\n                    VL_FATAL_MT(\"/home/kris/repos/titan/titan/comms/verilog/tests/dut_param_mux.sv\", 1, \"\", \"Active region did not converge.\");\n                }\n                vlSelf-&gt;__VactIterCount = ((IData)(1U) \n                                           + vlSelf-&gt;__VactIterCount);\n                __VpreTriggered.andNot(vlSelf-&gt;__VactTriggered, vlSelf-&gt;__VnbaTriggered);\n                vlSelf-&gt;__VnbaTriggered.set(vlSelf-&gt;__VactTriggered);\n                Vtop___024root___timing_resume(vlSelf);\n                Vtop___024root___eval_act(vlSelf);\n            }\n        }\n        if (vlSelf-&gt;__VnbaTriggered.any()) {\n            __VnbaContinue = 1U;\n            if (VL_UNLIKELY((0x64U &lt; __VnbaIterCount))) {\n#ifdef VL_DEBUG\n                Vtop___024root___dump_triggers__nba(vlSelf);\n#endif\n                VL_FATAL_MT(\"/home/kris/repos/titan/titan/comms/verilog/tests/dut_param_mux.sv\", 1, \"\", \"NBA region did not converge.\");\n            }\n            __VnbaIterCount = ((IData)(1U) + __VnbaIterCount);\n            Vtop___024root___eval_nba(vlSelf);\n        }\n    }\n}\n\nvoid Vtop___024root___timing_resume(Vtop___024root* vlSelf) {\n    if (false &amp;&amp; vlSelf) {}  // Prevent unused\n    Vtop__Syms* const __restrict vlSymsp VL_ATTR_UNUSED = vlSelf-&gt;vlSymsp;\n    VL_DEBUG_IF(VL_DBG_MSGF(\"+    Vtop___024root___timing_resume\\n\"); );\n    // Body\n    if (vlSelf-&gt;__VactTriggered.at(0U)) {\n        vlSelf-&gt;__VdlySched.resume();\n    }\n}\n\n#ifdef VL_DEBUG\nvoid Vtop___024root___eval_debug_assertions(Vtop___024root* vlSelf) {\n    if (false &amp;&amp; vlSelf) {}  // Prevent unused\n    Vtop__Syms* const __restrict vlSymsp VL_ATTR_UNUSED = vlSelf-&gt;vlSymsp;\n    VL_DEBUG_IF(VL_DBG_MSGF(\"+    Vtop___024root___eval_debug_assertions\\n\"); );\n    // Body\n    if (VL_UNLIKELY((vlSelf-&gt;sel_i &amp; 0xfcU))) {\n        Verilated::overWidthError(\"sel_i\");}\n}\n#endif  // VL_DEBUG\n</code></pre>"},{"location":"TitanComms/Vtop______024root____DepSet__heccd7ead____0____Slow_8cpp/","title":"File Vtop___024root__DepSet_heccd7ead__0__Slow.cpp","text":"<p>FileList &gt; comms &gt; verilog &gt; tests &gt; sim_build &gt; Vtop___024root__DepSet_heccd7ead__0__Slow.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"verilated.h\"</code></li> <li><code>#include \"verilated_dpi.h\"</code></li> <li><code>#include \"Vtop___024root.h\"</code></li> </ul>"},{"location":"TitanComms/Vtop______024root____DepSet__heccd7ead____0____Slow_8cpp/#public-functions","title":"Public Functions","text":"Type Name VL_ATTR_COLD void Vtop___024root___ctor_var_reset (Vtop___024root * vlSelf)  VL_ATTR_COLD void Vtop___024root___eval_final (Vtop___024root * vlSelf)  VL_ATTR_COLD void Vtop___024root___eval_settle (Vtop___024root * vlSelf)  VL_ATTR_COLD void Vtop___024root___eval_static (Vtop___024root * vlSelf)  VL_ATTR_COLD void Vtop___024root___eval_stl (Vtop___024root * vlSelf)  VL_ATTR_COLD void Vtop___024root___eval_triggers__stl (Vtop___024root * vlSelf)  void Vtop___024root___ico_sequent__TOP__0 (Vtop___024root * vlSelf)"},{"location":"TitanComms/Vtop______024root____DepSet__heccd7ead____0____Slow_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"TitanComms/Vtop______024root____DepSet__heccd7ead____0____Slow_8cpp/#function-vtop___024root___ctor_var_reset","title":"function Vtop___024root___ctor_var_reset","text":"<pre><code>VL_ATTR_COLD void Vtop___024root___ctor_var_reset (\n    Vtop___024root * vlSelf\n) \n</code></pre>"},{"location":"TitanComms/Vtop______024root____DepSet__heccd7ead____0____Slow_8cpp/#function-vtop___024root___eval_final","title":"function Vtop___024root___eval_final","text":"<pre><code>VL_ATTR_COLD void Vtop___024root___eval_final (\n    Vtop___024root * vlSelf\n) \n</code></pre>"},{"location":"TitanComms/Vtop______024root____DepSet__heccd7ead____0____Slow_8cpp/#function-vtop___024root___eval_settle","title":"function Vtop___024root___eval_settle","text":"<pre><code>VL_ATTR_COLD void Vtop___024root___eval_settle (\n    Vtop___024root * vlSelf\n) \n</code></pre>"},{"location":"TitanComms/Vtop______024root____DepSet__heccd7ead____0____Slow_8cpp/#function-vtop___024root___eval_static","title":"function Vtop___024root___eval_static","text":"<pre><code>VL_ATTR_COLD void Vtop___024root___eval_static (\n    Vtop___024root * vlSelf\n) \n</code></pre>"},{"location":"TitanComms/Vtop______024root____DepSet__heccd7ead____0____Slow_8cpp/#function-vtop___024root___eval_stl","title":"function Vtop___024root___eval_stl","text":"<pre><code>VL_ATTR_COLD void Vtop___024root___eval_stl (\n    Vtop___024root * vlSelf\n) \n</code></pre>"},{"location":"TitanComms/Vtop______024root____DepSet__heccd7ead____0____Slow_8cpp/#function-vtop___024root___eval_triggers__stl","title":"function Vtop___024root___eval_triggers__stl","text":"<pre><code>VL_ATTR_COLD void Vtop___024root___eval_triggers__stl (\n    Vtop___024root * vlSelf\n) \n</code></pre>"},{"location":"TitanComms/Vtop______024root____DepSet__heccd7ead____0____Slow_8cpp/#function-vtop___024root___ico_sequent__top__0","title":"function Vtop___024root___ico_sequent__TOP__0","text":"<pre><code>void Vtop___024root___ico_sequent__TOP__0 (\n    Vtop___024root * vlSelf\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>titan/comms/verilog/tests/sim_build/Vtop___024root__DepSet_heccd7ead__0__Slow.cpp</code></p>"},{"location":"TitanComms/Vtop______024root____DepSet__heccd7ead____0____Slow_8cpp_source/","title":"File Vtop___024root__DepSet_heccd7ead__0__Slow.cpp","text":"<p>File List &gt; comms &gt; verilog &gt; tests &gt; sim_build &gt; Vtop___024root__DepSet_heccd7ead__0__Slow.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// Verilated -*- C++ -*-\n// DESCRIPTION: Verilator output: Design implementation internals\n// See Vtop.h for the primary calling header\n\n#include \"verilated.h\"\n#include \"verilated_dpi.h\"\n\n#include \"Vtop___024root.h\"\n\nVL_ATTR_COLD void Vtop___024root___eval_static(Vtop___024root* vlSelf) {\n    if (false &amp;&amp; vlSelf) {}  // Prevent unused\n    Vtop__Syms* const __restrict vlSymsp VL_ATTR_UNUSED = vlSelf-&gt;vlSymsp;\n    VL_DEBUG_IF(VL_DBG_MSGF(\"+    Vtop___024root___eval_static\\n\"); );\n}\n\nVL_ATTR_COLD void Vtop___024root___eval_final(Vtop___024root* vlSelf) {\n    if (false &amp;&amp; vlSelf) {}  // Prevent unused\n    Vtop__Syms* const __restrict vlSymsp VL_ATTR_UNUSED = vlSelf-&gt;vlSymsp;\n    VL_DEBUG_IF(VL_DBG_MSGF(\"+    Vtop___024root___eval_final\\n\"); );\n}\n\nVL_ATTR_COLD void Vtop___024root___eval_triggers__stl(Vtop___024root* vlSelf);\n#ifdef VL_DEBUG\nVL_ATTR_COLD void Vtop___024root___dump_triggers__stl(Vtop___024root* vlSelf);\n#endif  // VL_DEBUG\nVL_ATTR_COLD void Vtop___024root___eval_stl(Vtop___024root* vlSelf);\n\nVL_ATTR_COLD void Vtop___024root___eval_settle(Vtop___024root* vlSelf) {\n    if (false &amp;&amp; vlSelf) {}  // Prevent unused\n    Vtop__Syms* const __restrict vlSymsp VL_ATTR_UNUSED = vlSelf-&gt;vlSymsp;\n    VL_DEBUG_IF(VL_DBG_MSGF(\"+    Vtop___024root___eval_settle\\n\"); );\n    // Init\n    CData/*0:0*/ __VstlContinue;\n    // Body\n    vlSelf-&gt;__VstlIterCount = 0U;\n    __VstlContinue = 1U;\n    while (__VstlContinue) {\n        __VstlContinue = 0U;\n        Vtop___024root___eval_triggers__stl(vlSelf);\n        if (vlSelf-&gt;__VstlTriggered.any()) {\n            __VstlContinue = 1U;\n            if (VL_UNLIKELY((0x64U &lt; vlSelf-&gt;__VstlIterCount))) {\n#ifdef VL_DEBUG\n                Vtop___024root___dump_triggers__stl(vlSelf);\n#endif\n                VL_FATAL_MT(\"/home/kris/repos/titan/titan/comms/verilog/tests/dut_param_mux.sv\", 1, \"\", \"Settle region did not converge.\");\n            }\n            vlSelf-&gt;__VstlIterCount = ((IData)(1U) \n                                       + vlSelf-&gt;__VstlIterCount);\n            Vtop___024root___eval_stl(vlSelf);\n        }\n    }\n}\n\n#ifdef VL_DEBUG\nVL_ATTR_COLD void Vtop___024root___dump_triggers__stl(Vtop___024root* vlSelf) {\n    if (false &amp;&amp; vlSelf) {}  // Prevent unused\n    Vtop__Syms* const __restrict vlSymsp VL_ATTR_UNUSED = vlSelf-&gt;vlSymsp;\n    VL_DEBUG_IF(VL_DBG_MSGF(\"+    Vtop___024root___dump_triggers__stl\\n\"); );\n    // Body\n    if ((1U &amp; (~ (IData)(vlSelf-&gt;__VstlTriggered.any())))) {\n        VL_DBG_MSGF(\"         No triggers active\\n\");\n    }\n    if (vlSelf-&gt;__VstlTriggered.at(0U)) {\n        VL_DBG_MSGF(\"         'stl' region trigger index 0 is active: Internal 'stl' trigger - first iteration\\n\");\n    }\n}\n#endif  // VL_DEBUG\n\nvoid Vtop___024root___ico_sequent__TOP__0(Vtop___024root* vlSelf);\n\nVL_ATTR_COLD void Vtop___024root___eval_stl(Vtop___024root* vlSelf) {\n    if (false &amp;&amp; vlSelf) {}  // Prevent unused\n    Vtop__Syms* const __restrict vlSymsp VL_ATTR_UNUSED = vlSelf-&gt;vlSymsp;\n    VL_DEBUG_IF(VL_DBG_MSGF(\"+    Vtop___024root___eval_stl\\n\"); );\n    // Body\n    if (vlSelf-&gt;__VstlTriggered.at(0U)) {\n        Vtop___024root___ico_sequent__TOP__0(vlSelf);\n    }\n}\n\n#ifdef VL_DEBUG\nVL_ATTR_COLD void Vtop___024root___dump_triggers__ico(Vtop___024root* vlSelf) {\n    if (false &amp;&amp; vlSelf) {}  // Prevent unused\n    Vtop__Syms* const __restrict vlSymsp VL_ATTR_UNUSED = vlSelf-&gt;vlSymsp;\n    VL_DEBUG_IF(VL_DBG_MSGF(\"+    Vtop___024root___dump_triggers__ico\\n\"); );\n    // Body\n    if ((1U &amp; (~ (IData)(vlSelf-&gt;__VicoTriggered.any())))) {\n        VL_DBG_MSGF(\"         No triggers active\\n\");\n    }\n    if (vlSelf-&gt;__VicoTriggered.at(0U)) {\n        VL_DBG_MSGF(\"         'ico' region trigger index 0 is active: Internal 'ico' trigger - first iteration\\n\");\n    }\n}\n#endif  // VL_DEBUG\n\n#ifdef VL_DEBUG\nVL_ATTR_COLD void Vtop___024root___dump_triggers__act(Vtop___024root* vlSelf) {\n    if (false &amp;&amp; vlSelf) {}  // Prevent unused\n    Vtop__Syms* const __restrict vlSymsp VL_ATTR_UNUSED = vlSelf-&gt;vlSymsp;\n    VL_DEBUG_IF(VL_DBG_MSGF(\"+    Vtop___024root___dump_triggers__act\\n\"); );\n    // Body\n    if ((1U &amp; (~ (IData)(vlSelf-&gt;__VactTriggered.any())))) {\n        VL_DBG_MSGF(\"         No triggers active\\n\");\n    }\n    if (vlSelf-&gt;__VactTriggered.at(0U)) {\n        VL_DBG_MSGF(\"         'act' region trigger index 0 is active: @([true] __VdlySched.awaitingCurrentTime())\\n\");\n    }\n}\n#endif  // VL_DEBUG\n\n#ifdef VL_DEBUG\nVL_ATTR_COLD void Vtop___024root___dump_triggers__nba(Vtop___024root* vlSelf) {\n    if (false &amp;&amp; vlSelf) {}  // Prevent unused\n    Vtop__Syms* const __restrict vlSymsp VL_ATTR_UNUSED = vlSelf-&gt;vlSymsp;\n    VL_DEBUG_IF(VL_DBG_MSGF(\"+    Vtop___024root___dump_triggers__nba\\n\"); );\n    // Body\n    if ((1U &amp; (~ (IData)(vlSelf-&gt;__VnbaTriggered.any())))) {\n        VL_DBG_MSGF(\"         No triggers active\\n\");\n    }\n    if (vlSelf-&gt;__VnbaTriggered.at(0U)) {\n        VL_DBG_MSGF(\"         'nba' region trigger index 0 is active: @([true] __VdlySched.awaitingCurrentTime())\\n\");\n    }\n}\n#endif  // VL_DEBUG\n\nVL_ATTR_COLD void Vtop___024root___ctor_var_reset(Vtop___024root* vlSelf) {\n    if (false &amp;&amp; vlSelf) {}  // Prevent unused\n    Vtop__Syms* const __restrict vlSymsp VL_ATTR_UNUSED = vlSelf-&gt;vlSymsp;\n    VL_DEBUG_IF(VL_DBG_MSGF(\"+    Vtop___024root___ctor_var_reset\\n\"); );\n    // Body\n    vlSelf-&gt;in1 = VL_RAND_RESET_I(32);\n    vlSelf-&gt;in2 = VL_RAND_RESET_I(32);\n    vlSelf-&gt;in3 = VL_RAND_RESET_I(32);\n    vlSelf-&gt;in4 = VL_RAND_RESET_I(32);\n    vlSelf-&gt;sel_i = VL_RAND_RESET_I(2);\n    vlSelf-&gt;mux_o = VL_RAND_RESET_I(32);\n    vlSelf-&gt;dut_param_mux__DOT__in1 = VL_RAND_RESET_I(32);\n    vlSelf-&gt;dut_param_mux__DOT__in2 = VL_RAND_RESET_I(32);\n    vlSelf-&gt;dut_param_mux__DOT__in3 = VL_RAND_RESET_I(32);\n    vlSelf-&gt;dut_param_mux__DOT__in4 = VL_RAND_RESET_I(32);\n    vlSelf-&gt;dut_param_mux__DOT__sel_i = VL_RAND_RESET_I(2);\n    vlSelf-&gt;dut_param_mux__DOT__mux_o = VL_RAND_RESET_I(32);\n    for (int __Vi0 = 0; __Vi0 &lt; 4; ++__Vi0) {\n        vlSelf-&gt;dut_param_mux__DOT____Vcellinp__uut_pmux__inputs[__Vi0] = VL_RAND_RESET_I(32);\n    }\n    vlSelf-&gt;dut_param_mux__DOT__uut_pmux__DOT__selector = VL_RAND_RESET_I(2);\n    for (int __Vi0 = 0; __Vi0 &lt; 4; ++__Vi0) {\n        vlSelf-&gt;dut_param_mux__DOT__uut_pmux__DOT__inputs[__Vi0] = VL_RAND_RESET_I(32);\n    }\n    vlSelf-&gt;dut_param_mux__DOT__uut_pmux__DOT__out = VL_RAND_RESET_I(32);\n    }\n</code></pre>"},{"location":"TitanComms/Vtop______024root____Slow_8cpp/","title":"File Vtop___024root__Slow.cpp","text":"<p>FileList &gt; comms &gt; verilog &gt; tests &gt; sim_build &gt; Vtop___024root__Slow.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"verilated.h\"</code></li> <li><code>#include \"verilated_dpi.h\"</code></li> <li><code>#include \"Vtop__Syms.h\"</code></li> <li><code>#include \"Vtop___024root.h\"</code></li> </ul>"},{"location":"TitanComms/Vtop______024root____Slow_8cpp/#public-functions","title":"Public Functions","text":"Type Name void Vtop___024root___ctor_var_reset (Vtop___024root * vlSelf)"},{"location":"TitanComms/Vtop______024root____Slow_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"TitanComms/Vtop______024root____Slow_8cpp/#function-vtop___024root___ctor_var_reset","title":"function Vtop___024root___ctor_var_reset","text":"<pre><code>void Vtop___024root___ctor_var_reset (\n    Vtop___024root * vlSelf\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>titan/comms/verilog/tests/sim_build/Vtop___024root__Slow.cpp</code></p>"},{"location":"TitanComms/Vtop______024root____Slow_8cpp_source/","title":"File Vtop___024root__Slow.cpp","text":"<p>File List &gt; comms &gt; verilog &gt; tests &gt; sim_build &gt; Vtop___024root__Slow.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// Verilated -*- C++ -*-\n// DESCRIPTION: Verilator output: Design implementation internals\n// See Vtop.h for the primary calling header\n\n#include \"verilated.h\"\n#include \"verilated_dpi.h\"\n\n#include \"Vtop__Syms.h\"\n#include \"Vtop___024root.h\"\n\n// Parameter definitions for Vtop___024root\nconstexpr IData/*31:0*/ Vtop___024root::dut_param_mux__DOT__uut_pmux__DOT__INPUT_WIDTH;\nconstexpr IData/*31:0*/ Vtop___024root::dut_param_mux__DOT__uut_pmux__DOT__SELECTOR_WIDTH;\nconstexpr IData/*31:0*/ Vtop___024root::dut_param_mux__DOT__uut_pmux__DOT__SIGNAL_COUNT;\n\n\nvoid Vtop___024root___ctor_var_reset(Vtop___024root* vlSelf);\n\nVtop___024root::Vtop___024root(Vtop__Syms* symsp, const char* v__name)\n    : VerilatedModule{v__name}\n    , __VdlySched{*symsp-&gt;_vm_contextp__}\n    , vlSymsp{symsp}\n {\n    // Reset structure values\n    Vtop___024root___ctor_var_reset(this);\n}\n\nvoid Vtop___024root::__Vconfigure(bool first) {\n    if (false &amp;&amp; first) {}  // Prevent unused\n}\n\nVtop___024root::~Vtop___024root() {\n}\n</code></pre>"},{"location":"TitanComms/Vtop______024unit_8h/","title":"File Vtop___024unit.h","text":"<p>FileList &gt; comms &gt; verilog &gt; tests &gt; sim_build &gt; Vtop___024unit.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"verilated.h\"</code></li> <li><code>#include \"verilated_timing.h\"</code></li> </ul>"},{"location":"TitanComms/Vtop______024unit_8h/#classes","title":"Classes","text":"Type Name class Vtop___024unit"},{"location":"TitanComms/Vtop______024unit_8h/#public-attributes","title":"Public Attributes","text":"Type Name Vtop__Syms *const vlSymsp"},{"location":"TitanComms/Vtop______024unit_8h/#public-functions","title":"Public Functions","text":"Type Name Vtop___024unit VerilatedModule VL_ATTR_ALIGNED (VL_CACHE_LINE_BYTES)  VL_UNCOPYABLE (Vtop___024unit)  Vtop___024unit (Vtop__Syms * symsp, const char * v__name)  void __Vconfigure (bool first)  ~Vtop___024unit ()"},{"location":"TitanComms/Vtop______024unit_8h/#macros","title":"Macros","text":"Type Name define VERILATED_VTOP___024UNIT_H_"},{"location":"TitanComms/Vtop______024unit_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"TitanComms/Vtop______024unit_8h/#variable-vlsymsp","title":"variable vlSymsp","text":"<pre><code>Vtop__Syms* const vlSymsp;\n</code></pre>"},{"location":"TitanComms/Vtop______024unit_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"TitanComms/Vtop______024unit_8h/#function-vl_attr_aligned","title":"function VL_ATTR_ALIGNED","text":"<pre><code>Vtop___024unit VerilatedModule VL_ATTR_ALIGNED (\n    VL_CACHE_LINE_BYTES\n) \n</code></pre>"},{"location":"TitanComms/Vtop______024unit_8h/#function-vl_uncopyable","title":"function VL_UNCOPYABLE","text":"<pre><code>VL_UNCOPYABLE (\n    Vtop___024unit\n) \n</code></pre>"},{"location":"TitanComms/Vtop______024unit_8h/#function-vtop___024unit","title":"function Vtop___024unit","text":"<pre><code>Vtop___024unit (\n    Vtop__Syms * symsp,\n    const char * v__name\n) \n</code></pre>"},{"location":"TitanComms/Vtop______024unit_8h/#function-__vconfigure","title":"function __Vconfigure","text":"<pre><code>void __Vconfigure (\n    bool first\n) \n</code></pre>"},{"location":"TitanComms/Vtop______024unit_8h/#function-vtop___024unit_1","title":"function ~Vtop___024unit","text":"<pre><code>~Vtop___024unit () \n</code></pre>"},{"location":"TitanComms/Vtop______024unit_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"TitanComms/Vtop______024unit_8h/#define-verilated_vtop___024unit_h_","title":"define VERILATED_VTOP___024UNIT_H_","text":"<pre><code>#define VERILATED_VTOP___024UNIT_H_ \n</code></pre> <p>The documentation for this class was generated from the following file <code>titan/comms/verilog/tests/sim_build/Vtop___024unit.h</code></p>"},{"location":"TitanComms/Vtop______024unit_8h_source/","title":"File Vtop___024unit.h","text":"<p>File List &gt; comms &gt; verilog &gt; tests &gt; sim_build &gt; Vtop___024unit.h</p> <p>Go to the documentation of this file</p> <pre><code>// Verilated -*- C++ -*-\n// DESCRIPTION: Verilator output: Design internal header\n// See Vtop.h for the primary calling header\n\n#ifndef VERILATED_VTOP___024UNIT_H_\n#define VERILATED_VTOP___024UNIT_H_  // guard\n\n#include \"verilated.h\"\n#include \"verilated_timing.h\"\n\nclass Vtop__Syms;\n\nclass Vtop___024unit final : public VerilatedModule {\n  public:\n\n    // INTERNAL VARIABLES\n    Vtop__Syms* const vlSymsp;\n\n    // CONSTRUCTORS\n    Vtop___024unit(Vtop__Syms* symsp, const char* v__name);\n    ~Vtop___024unit();\n    VL_UNCOPYABLE(Vtop___024unit);\n\n    // INTERNAL METHODS\n    void __Vconfigure(bool first);\n} VL_ATTR_ALIGNED(VL_CACHE_LINE_BYTES);\n\n\n#endif  // guard\n</code></pre>"},{"location":"TitanComms/Vtop______024unit____DepSet__hff17caec____0____Slow_8cpp/","title":"File Vtop___024unit__DepSet_hff17caec__0__Slow.cpp","text":"<p>FileList &gt; comms &gt; verilog &gt; tests &gt; sim_build &gt; Vtop___024unit__DepSet_hff17caec__0__Slow.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"verilated.h\"</code></li> <li><code>#include \"verilated_dpi.h\"</code></li> <li><code>#include \"Vtop___024unit.h\"</code></li> </ul>"},{"location":"TitanComms/Vtop______024unit____DepSet__hff17caec____0____Slow_8cpp/#public-functions","title":"Public Functions","text":"Type Name VL_ATTR_COLD void Vtop___024unit___ctor_var_reset (Vtop___024unit * vlSelf)"},{"location":"TitanComms/Vtop______024unit____DepSet__hff17caec____0____Slow_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"TitanComms/Vtop______024unit____DepSet__hff17caec____0____Slow_8cpp/#function-vtop___024unit___ctor_var_reset","title":"function Vtop___024unit___ctor_var_reset","text":"<pre><code>VL_ATTR_COLD void Vtop___024unit___ctor_var_reset (\n    Vtop___024unit * vlSelf\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>titan/comms/verilog/tests/sim_build/Vtop___024unit__DepSet_hff17caec__0__Slow.cpp</code></p>"},{"location":"TitanComms/Vtop______024unit____DepSet__hff17caec____0____Slow_8cpp_source/","title":"File Vtop___024unit__DepSet_hff17caec__0__Slow.cpp","text":"<p>File List &gt; comms &gt; verilog &gt; tests &gt; sim_build &gt; Vtop___024unit__DepSet_hff17caec__0__Slow.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// Verilated -*- C++ -*-\n// DESCRIPTION: Verilator output: Design implementation internals\n// See Vtop.h for the primary calling header\n\n#include \"verilated.h\"\n#include \"verilated_dpi.h\"\n\n#include \"Vtop___024unit.h\"\n\nVL_ATTR_COLD void Vtop___024unit___ctor_var_reset(Vtop___024unit* vlSelf) {\n    if (false &amp;&amp; vlSelf) {}  // Prevent unused\n    Vtop__Syms* const __restrict vlSymsp VL_ATTR_UNUSED = vlSelf-&gt;vlSymsp;\n    VL_DEBUG_IF(VL_DBG_MSGF(\"+        Vtop___024unit___ctor_var_reset\\n\"); );\n}\n</code></pre>"},{"location":"TitanComms/Vtop______024unit____Slow_8cpp/","title":"File Vtop___024unit__Slow.cpp","text":"<p>FileList &gt; comms &gt; verilog &gt; tests &gt; sim_build &gt; Vtop___024unit__Slow.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"verilated.h\"</code></li> <li><code>#include \"verilated_dpi.h\"</code></li> <li><code>#include \"Vtop__Syms.h\"</code></li> <li><code>#include \"Vtop___024unit.h\"</code></li> </ul>"},{"location":"TitanComms/Vtop______024unit____Slow_8cpp/#public-functions","title":"Public Functions","text":"Type Name void Vtop___024unit___ctor_var_reset (Vtop___024unit * vlSelf)"},{"location":"TitanComms/Vtop______024unit____Slow_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"TitanComms/Vtop______024unit____Slow_8cpp/#function-vtop___024unit___ctor_var_reset","title":"function Vtop___024unit___ctor_var_reset","text":"<pre><code>void Vtop___024unit___ctor_var_reset (\n    Vtop___024unit * vlSelf\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>titan/comms/verilog/tests/sim_build/Vtop___024unit__Slow.cpp</code></p>"},{"location":"TitanComms/Vtop______024unit____Slow_8cpp_source/","title":"File Vtop___024unit__Slow.cpp","text":"<p>File List &gt; comms &gt; verilog &gt; tests &gt; sim_build &gt; Vtop___024unit__Slow.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// Verilated -*- C++ -*-\n// DESCRIPTION: Verilator output: Design implementation internals\n// See Vtop.h for the primary calling header\n\n#include \"verilated.h\"\n#include \"verilated_dpi.h\"\n\n#include \"Vtop__Syms.h\"\n#include \"Vtop___024unit.h\"\n\nvoid Vtop___024unit___ctor_var_reset(Vtop___024unit* vlSelf);\n\nVtop___024unit::Vtop___024unit(Vtop__Syms* symsp, const char* v__name)\n    : VerilatedModule{v__name}\n    , vlSymsp{symsp}\n {\n    // Reset structure values\n    Vtop___024unit___ctor_var_reset(this);\n}\n\nvoid Vtop___024unit::__Vconfigure(bool first) {\n    if (false &amp;&amp; first) {}  // Prevent unused\n}\n\nVtop___024unit::~Vtop___024unit() {\n}\n</code></pre>"},{"location":"TitanComms/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p>"},{"location":"TitanComms/classes/","title":"Class Index","text":""},{"location":"TitanComms/classes/#t","title":"t","text":"<ul> <li>TitanComms</li> </ul>"},{"location":"TitanComms/classes/#u","title":"u","text":"<ul> <li>u_int24 (TitanComms)</li> </ul>"},{"location":"TitanComms/classes/#v","title":"v","text":"<ul> <li>VL_NOT_FINAL</li> <li>Vtop___024root</li> <li>Vtop___024unit</li> <li>Vtop__Syms</li> </ul>"},{"location":"TitanComms/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>class TitanComms </li> <li>struct TitanComms::u_int24 </li> <li>class VerilatedModel <ul> <li>class VL_NOT_FINAL </li> </ul> </li> <li>class VerilatedSyms <ul> <li>class Vtop__Syms </li> </ul> </li> <li>class VerilatedModule <ul> <li>class Vtop___024root </li> <li>class Vtop___024unit </li> </ul> </li> </ul>"},{"location":"TitanComms/modules/","title":"Modules","text":"<p>No modules found.</p>"},{"location":"TitanComms/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p>"},{"location":"TitanComms/class_members/","title":"Class Members","text":""},{"location":"TitanComms/class_members/#b","title":"b","text":"<ul> <li>begin (TitanComms)</li> <li>bind_address (TitanComms)</li> </ul>"},{"location":"TitanComms/class_members/#d","title":"d","text":"<ul> <li>data (TitanComms::u_int24)</li> <li>dut_param_mux__DOT____Vcellinp__uut_pmux__inputs (Vtop___024root)</li> <li>dut_param_mux__DOT__in1 (Vtop___024root)</li> <li>dut_param_mux__DOT__in2 (Vtop___024root)</li> <li>dut_param_mux__DOT__in3 (Vtop___024root)</li> <li>dut_param_mux__DOT__in4 (Vtop___024root)</li> <li>dut_param_mux__DOT__mux_o (Vtop___024root)</li> <li>dut_param_mux__DOT__sel_i (Vtop___024root)</li> <li>dut_param_mux__DOT__uut_pmux__DOT__INPUT_WIDTH (Vtop___024root)</li> <li>dut_param_mux__DOT__uut_pmux__DOT__SELECTOR_WIDTH (Vtop___024root)</li> <li>dut_param_mux__DOT__uut_pmux__DOT__SIGNAL_COUNT (Vtop___024root)</li> <li>dut_param_mux__DOT__uut_pmux__DOT__inputs (Vtop___024root)</li> <li>dut_param_mux__DOT__uut_pmux__DOT__out (Vtop___024root)</li> <li>dut_param_mux__DOT__uut_pmux__DOT__selector (Vtop___024root)</li> </ul>"},{"location":"TitanComms/class_members/#e","title":"e","text":"<ul> <li>eval (VL_NOT_FINAL)</li> <li>eval_end_step (VL_NOT_FINAL)</li> <li>eval_step (VL_NOT_FINAL)</li> <li>eventsPending (VL_NOT_FINAL)</li> </ul>"},{"location":"TitanComms/class_members/#f","title":"f","text":"<ul> <li>final (VL_NOT_FINAL)</li> </ul>"},{"location":"TitanComms/class_members/#h","title":"h","text":"<ul> <li>hierName (VL_NOT_FINAL)</li> </ul>"},{"location":"TitanComms/class_members/#i","title":"i","text":"<ul> <li>instruction (TitanComms)</li> <li>in1 (VL_NOT_FINAL)</li> <li>in2 (VL_NOT_FINAL)</li> <li>in3 (VL_NOT_FINAL)</li> <li>in4 (VL_NOT_FINAL)</li> </ul>"},{"location":"TitanComms/class_members/#m","title":"m","text":"<ul> <li>modelName (VL_NOT_FINAL)</li> <li>mux_o (VL_NOT_FINAL)</li> </ul>"},{"location":"TitanComms/class_members/#n","title":"n","text":"<ul> <li>name (VL_NOT_FINAL, Vtop__Syms)</li> <li>nextTimeSlot (VL_NOT_FINAL)</li> </ul>"},{"location":"TitanComms/class_members/#r","title":"r","text":"<ul> <li>read (TitanComms)</li> <li>rootp (VL_NOT_FINAL)</li> </ul>"},{"location":"TitanComms/class_members/#s","title":"s","text":"<ul> <li>set_core_interrupt (TitanComms)</li> <li>set_stream_read_address (TitanComms)</li> <li>set_stream_write_address (TitanComms)</li> <li>stream (TitanComms)</li> <li>sel_i (VL_NOT_FINAL)</li> </ul>"},{"location":"TitanComms/class_members/#t","title":"t","text":"<ul> <li>TitanComms (TitanComms)</li> <li>threads (VL_NOT_FINAL)</li> <li>trace (VL_NOT_FINAL)</li> <li>traceConfig (VL_NOT_FINAL)</li> <li>TOP (Vtop__Syms)</li> </ul>"},{"location":"TitanComms/class_members/#v","title":"v","text":"<ul> <li>VL_UNCOPYABLE (VL_NOT_FINAL, Vtop___024root, Vtop___024unit)</li> <li>Vtop (VL_NOT_FINAL)</li> <li>vlSymsp (VL_NOT_FINAL, Vtop___024root, Vtop___024unit)</li> <li>VL_GUARDED_BY (Vtop__Syms)</li> <li>Vtop__Syms (Vtop__Syms)</li> <li>VL_IN (Vtop___024root)</li> <li>VL_IN8 (Vtop___024root)</li> <li>VL_OUT (Vtop___024root)</li> <li>Vtop___024root (Vtop___024root)</li> <li>Vtop___024unit (Vtop___024unit)</li> </ul>"},{"location":"TitanComms/class_members/#w","title":"w","text":"<ul> <li>write (TitanComms)</li> </ul>"},{"location":"TitanComms/class_members/#_1","title":"~","text":"<ul> <li>~Vtop (VL_NOT_FINAL)</li> <li>~Vtop__Syms (Vtop__Syms)</li> <li>~Vtop___024root (Vtop___024root)</li> <li>~Vtop___024unit (Vtop___024unit)</li> </ul>"},{"location":"TitanComms/class_members/#_","title":"_","text":"<ul> <li>_chip_deselect (TitanComms)</li> <li>_chip_select (TitanComms)</li> <li>_cs_pin (TitanComms)</li> <li>_extract_byte_from_int (TitanComms)</li> <li>_nop_and_read16 (TitanComms)</li> <li>_nop_and_read8 (TitanComms)</li> <li>_repeat (TitanComms)</li> <li>_spi_settings (TitanComms)</li> <li>_xor_checksum (TitanComms)</li> <li>__Vhier (Vtop__Syms)</li> <li>__Vm_activity (Vtop__Syms)</li> <li>__Vm_baseCode (Vtop__Syms)</li> <li>__Vm_didInit (Vtop__Syms)</li> <li>__Vm_dumperMutex (Vtop__Syms)</li> <li>__Vm_dumping (Vtop__Syms)</li> <li>__Vm_modelp (Vtop__Syms)</li> <li>__Vscope_TOP (Vtop__Syms)</li> <li>__Vscope_dut_param_mux (Vtop__Syms)</li> <li>__Vscope_dut_param_mux__uut_pmux (Vtop__Syms)</li> <li>_traceDump (Vtop__Syms)</li> <li>_traceDumpClose (Vtop__Syms)</li> <li>_traceDumpOpen (Vtop__Syms)</li> <li>__VactContinue (Vtop___024root)</li> <li>__VactIterCount (Vtop___024root)</li> <li>__VactTriggered (Vtop___024root)</li> <li>__Vconfigure (Vtop___024root, Vtop___024unit)</li> <li>__VdlySched (Vtop___024root)</li> <li>__VicoIterCount (Vtop___024root)</li> <li>__VicoTriggered (Vtop___024root)</li> <li>__VnbaTriggered (Vtop___024root)</li> <li>__VstlIterCount (Vtop___024root)</li> <li>__VstlTriggered (Vtop___024root)</li> </ul>"},{"location":"TitanComms/class_member_functions/","title":"Class Member Functions","text":""},{"location":"TitanComms/class_member_functions/#b","title":"b","text":"<ul> <li>begin (TitanComms)</li> <li>bind_address (TitanComms)</li> </ul>"},{"location":"TitanComms/class_member_functions/#e","title":"e","text":"<ul> <li>eval (VL_NOT_FINAL)</li> <li>eval_end_step (VL_NOT_FINAL)</li> <li>eval_step (VL_NOT_FINAL)</li> <li>eventsPending (VL_NOT_FINAL)</li> </ul>"},{"location":"TitanComms/class_member_functions/#f","title":"f","text":"<ul> <li>final (VL_NOT_FINAL)</li> </ul>"},{"location":"TitanComms/class_member_functions/#h","title":"h","text":"<ul> <li>hierName (VL_NOT_FINAL)</li> </ul>"},{"location":"TitanComms/class_member_functions/#m","title":"m","text":"<ul> <li>modelName (VL_NOT_FINAL)</li> </ul>"},{"location":"TitanComms/class_member_functions/#n","title":"n","text":"<ul> <li>name (VL_NOT_FINAL, Vtop__Syms)</li> <li>nextTimeSlot (VL_NOT_FINAL)</li> </ul>"},{"location":"TitanComms/class_member_functions/#r","title":"r","text":"<ul> <li>read (TitanComms)</li> </ul>"},{"location":"TitanComms/class_member_functions/#s","title":"s","text":"<ul> <li>set_core_interrupt (TitanComms)</li> <li>set_stream_read_address (TitanComms)</li> <li>set_stream_write_address (TitanComms)</li> <li>stream (TitanComms)</li> </ul>"},{"location":"TitanComms/class_member_functions/#t","title":"t","text":"<ul> <li>TitanComms (TitanComms)</li> <li>threads (VL_NOT_FINAL)</li> <li>trace (VL_NOT_FINAL)</li> <li>traceConfig (VL_NOT_FINAL)</li> </ul>"},{"location":"TitanComms/class_member_functions/#v","title":"v","text":"<ul> <li>VL_UNCOPYABLE (VL_NOT_FINAL, Vtop___024root, Vtop___024unit)</li> <li>Vtop (VL_NOT_FINAL)</li> <li>VL_GUARDED_BY (Vtop__Syms)</li> <li>Vtop__Syms (Vtop__Syms)</li> <li>VL_IN (Vtop___024root)</li> <li>VL_IN8 (Vtop___024root)</li> <li>VL_OUT (Vtop___024root)</li> <li>Vtop___024root (Vtop___024root)</li> <li>Vtop___024unit (Vtop___024unit)</li> </ul>"},{"location":"TitanComms/class_member_functions/#w","title":"w","text":"<ul> <li>write (TitanComms)</li> </ul>"},{"location":"TitanComms/class_member_functions/#_1","title":"~","text":"<ul> <li>~Vtop (VL_NOT_FINAL)</li> <li>~Vtop__Syms (Vtop__Syms)</li> <li>~Vtop___024root (Vtop___024root)</li> <li>~Vtop___024unit (Vtop___024unit)</li> </ul>"},{"location":"TitanComms/class_member_functions/#_","title":"_","text":"<ul> <li>_chip_deselect (TitanComms)</li> <li>_chip_select (TitanComms)</li> <li>_extract_byte_from_int (TitanComms)</li> <li>_nop_and_read16 (TitanComms)</li> <li>_nop_and_read8 (TitanComms)</li> <li>_repeat (TitanComms)</li> <li>_xor_checksum (TitanComms)</li> <li>_traceDump (Vtop__Syms)</li> <li>_traceDumpClose (Vtop__Syms)</li> <li>_traceDumpOpen (Vtop__Syms)</li> <li>__Vconfigure (Vtop___024root, Vtop___024unit)</li> </ul>"},{"location":"TitanComms/class_member_variables/","title":"Class Member Variables","text":""},{"location":"TitanComms/class_member_variables/#d","title":"d","text":"<ul> <li>data (TitanComms::u_int24)</li> <li>dut_param_mux__DOT____Vcellinp__uut_pmux__inputs (Vtop___024root)</li> <li>dut_param_mux__DOT__in1 (Vtop___024root)</li> <li>dut_param_mux__DOT__in2 (Vtop___024root)</li> <li>dut_param_mux__DOT__in3 (Vtop___024root)</li> <li>dut_param_mux__DOT__in4 (Vtop___024root)</li> <li>dut_param_mux__DOT__mux_o (Vtop___024root)</li> <li>dut_param_mux__DOT__sel_i (Vtop___024root)</li> <li>dut_param_mux__DOT__uut_pmux__DOT__INPUT_WIDTH (Vtop___024root)</li> <li>dut_param_mux__DOT__uut_pmux__DOT__SELECTOR_WIDTH (Vtop___024root)</li> <li>dut_param_mux__DOT__uut_pmux__DOT__SIGNAL_COUNT (Vtop___024root)</li> <li>dut_param_mux__DOT__uut_pmux__DOT__inputs (Vtop___024root)</li> <li>dut_param_mux__DOT__uut_pmux__DOT__out (Vtop___024root)</li> <li>dut_param_mux__DOT__uut_pmux__DOT__selector (Vtop___024root)</li> </ul>"},{"location":"TitanComms/class_member_variables/#i","title":"i","text":"<ul> <li>in1 (VL_NOT_FINAL)</li> <li>in2 (VL_NOT_FINAL)</li> <li>in3 (VL_NOT_FINAL)</li> <li>in4 (VL_NOT_FINAL)</li> </ul>"},{"location":"TitanComms/class_member_variables/#m","title":"m","text":"<ul> <li>mux_o (VL_NOT_FINAL)</li> </ul>"},{"location":"TitanComms/class_member_variables/#r","title":"r","text":"<ul> <li>rootp (VL_NOT_FINAL)</li> </ul>"},{"location":"TitanComms/class_member_variables/#s","title":"s","text":"<ul> <li>sel_i (VL_NOT_FINAL)</li> </ul>"},{"location":"TitanComms/class_member_variables/#t","title":"t","text":"<ul> <li>TOP (Vtop__Syms)</li> </ul>"},{"location":"TitanComms/class_member_variables/#v","title":"v","text":"<ul> <li>vlSymsp (VL_NOT_FINAL, Vtop___024root, Vtop___024unit)</li> </ul>"},{"location":"TitanComms/class_member_variables/#_","title":"_","text":"<ul> <li>_cs_pin (TitanComms)</li> <li>_spi_settings (TitanComms)</li> <li>__Vhier (Vtop__Syms)</li> <li>__Vm_activity (Vtop__Syms)</li> <li>__Vm_baseCode (Vtop__Syms)</li> <li>__Vm_didInit (Vtop__Syms)</li> <li>__Vm_dumperMutex (Vtop__Syms)</li> <li>__Vm_dumping (Vtop__Syms)</li> <li>__Vm_modelp (Vtop__Syms)</li> <li>__Vscope_TOP (Vtop__Syms)</li> <li>__Vscope_dut_param_mux (Vtop__Syms)</li> <li>__Vscope_dut_param_mux__uut_pmux (Vtop__Syms)</li> <li>__VactContinue (Vtop___024root)</li> <li>__VactIterCount (Vtop___024root)</li> <li>__VactTriggered (Vtop___024root)</li> <li>__VdlySched (Vtop___024root)</li> <li>__VicoIterCount (Vtop___024root)</li> <li>__VicoTriggered (Vtop___024root)</li> <li>__VnbaTriggered (Vtop___024root)</li> <li>__VstlIterCount (Vtop___024root)</li> <li>__VstlTriggered (Vtop___024root)</li> </ul>"},{"location":"TitanComms/class_member_typedefs/","title":"Class Member Typedefs","text":"<p>Nothing related to Class Member Typedefs found.</p>"},{"location":"TitanComms/class_member_enums/","title":"Class Member Enums","text":""},{"location":"TitanComms/class_member_enums/#i","title":"i","text":"<ul> <li>instruction (TitanComms)</li> </ul>"},{"location":"TitanComms/namespace_members/","title":"Namespace Members","text":"<p>Nothing related to Namespace Members found.</p>"},{"location":"TitanComms/namespace_member_functions/","title":"Namespace Member Functions","text":"<p>Nothing related to Namespace Member Functions found.</p>"},{"location":"TitanComms/namespace_member_variables/","title":"Namespace Member Variables","text":"<p>Nothing related to Namespace Member Variables found.</p>"},{"location":"TitanComms/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":"<p>Nothing related to Namespace Member Typedefs found.</p>"},{"location":"TitanComms/namespace_member_enums/","title":"Namespace Member Enums","text":"<p>Nothing related to Namespace Member Enums found.</p>"},{"location":"TitanComms/functions/","title":"Functions","text":""},{"location":"TitanComms/functions/#e","title":"e","text":"<ul> <li>eval (Vtop.h)</li> <li>eval_end_step (Vtop.h)</li> <li>eval_step (Vtop.h)</li> <li>eventsPending (Vtop.h)</li> </ul>"},{"location":"TitanComms/functions/#f","title":"f","text":"<ul> <li>final (Vtop.h)</li> </ul>"},{"location":"TitanComms/functions/#h","title":"h","text":"<ul> <li>hierName (Vtop.h)</li> </ul>"},{"location":"TitanComms/functions/#m","title":"m","text":"<ul> <li>modelName (Vtop.h)</li> </ul>"},{"location":"TitanComms/functions/#n","title":"n","text":"<ul> <li>name (Vtop.h, Vtop__Syms.h)</li> <li>nextTimeSlot (Vtop.h)</li> </ul>"},{"location":"TitanComms/functions/#t","title":"t","text":"<ul> <li>trace_init (Vtop.cpp)</li> <li>threads (Vtop.h)</li> <li>trace (Vtop.h)</li> <li>traceConfig (Vtop.h)</li> </ul>"},{"location":"TitanComms/functions/#v","title":"v","text":"<ul> <li>Vtop___024root___eval (Vtop.cpp, Vtop___024root__DepSet_heccd7ead__0.cpp)</li> <li>Vtop___024root___eval_final (Vtop.cpp, Vtop___024root__DepSet_heccd7ead__0__Slow.cpp)</li> <li>Vtop___024root___eval_initial (Vtop.cpp, Vtop___024root__DepSet_heccd7ead__0.cpp)</li> <li>Vtop___024root___eval_settle (Vtop.cpp, Vtop___024root__DepSet_heccd7ead__0__Slow.cpp)</li> <li>Vtop___024root___eval_static (Vtop.cpp, Vtop___024root__DepSet_heccd7ead__0__Slow.cpp)</li> <li>Vtop___024root__trace_init_top (Vtop.cpp, Vtop__Trace__0__Slow.cpp)</li> <li>Vtop___024root__trace_register (Vtop.cpp, Vtop__Trace__0__Slow.cpp)</li> <li>VL_ATTR_ALIGNED (Vtop.h, Vtop__Syms.h, Vtop___024root.h, Vtop___024unit.h)</li> <li>VL_UNCOPYABLE (Vtop.h, Vtop___024root.h, Vtop___024unit.h)</li> <li>Vtop (Vtop.h)</li> <li>VL_GUARDED_BY (Vtop__Syms.h)</li> <li>Vtop__Syms (Vtop__Syms.h)</li> <li>Vtop___024root__trace_chg_sub_0 (Vtop__Trace__0.cpp)</li> <li>Vtop___024root__trace_chg_top_0 (Vtop__Trace__0.cpp, Vtop__Trace__0__Slow.cpp)</li> <li>Vtop___024root__trace_cleanup (Vtop__Trace__0.cpp, Vtop__Trace__0__Slow.cpp)</li> <li>Vtop___024root__trace_full_sub_0 (Vtop__Trace__0__Slow.cpp)</li> <li>Vtop___024root__trace_full_top_0 (Vtop__Trace__0__Slow.cpp)</li> <li>Vtop___024root__trace_init_sub__TOP__0 (Vtop__Trace__0__Slow.cpp)</li> <li>VL_IN (Vtop___024root.h)</li> <li>VL_IN8 (Vtop___024root.h)</li> <li>VL_OUT (Vtop___024root.h)</li> <li>Vtop___024root (Vtop___024root.h)</li> <li>Vtop___024root___eval_initial__TOP__0 (Vtop___024root__DepSet_h84412442__0.cpp, Vtop___024root__DepSet_heccd7ead__0.cpp)</li> <li>Vtop___024root___eval_triggers__act (Vtop___024root__DepSet_h84412442__0.cpp, Vtop___024root__DepSet_heccd7ead__0.cpp)</li> <li>Vtop___024root___eval_triggers__ico (Vtop___024root__DepSet_h84412442__0.cpp, Vtop___024root__DepSet_heccd7ead__0.cpp)</li> <li>Vtop___024root___eval_triggers__stl (Vtop___024root__DepSet_h84412442__0__Slow.cpp, Vtop___024root__DepSet_heccd7ead__0__Slow.cpp)</li> <li>Vtop___024root___eval_act (Vtop___024root__DepSet_heccd7ead__0.cpp)</li> <li>Vtop___024root___eval_ico (Vtop___024root__DepSet_heccd7ead__0.cpp)</li> <li>Vtop___024root___eval_nba (Vtop___024root__DepSet_heccd7ead__0.cpp)</li> <li>Vtop___024root___ico_sequent__TOP__0 (Vtop___024root__DepSet_heccd7ead__0.cpp, Vtop___024root__DepSet_heccd7ead__0__Slow.cpp)</li> <li>Vtop___024root___timing_resume (Vtop___024root__DepSet_heccd7ead__0.cpp)</li> <li>Vtop___024root___ctor_var_reset (Vtop___024root__DepSet_heccd7ead__0__Slow.cpp, Vtop___024root__Slow.cpp)</li> <li>Vtop___024root___eval_stl (Vtop___024root__DepSet_heccd7ead__0__Slow.cpp)</li> <li>Vtop___024unit (Vtop___024unit.h)</li> <li>Vtop___024unit___ctor_var_reset (Vtop___024unit__DepSet_hff17caec__0__Slow.cpp, Vtop___024unit__Slow.cpp)</li> </ul>"},{"location":"TitanComms/functions/#_1","title":"~","text":"<ul> <li>~Vtop (Vtop.h)</li> <li>~Vtop__Syms (Vtop__Syms.h)</li> <li>~Vtop___024root (Vtop___024root.h)</li> <li>~Vtop___024unit (Vtop___024unit.h)</li> </ul>"},{"location":"TitanComms/functions/#_","title":"_","text":"<ul> <li>_traceDump (Vtop__Syms.h)</li> <li>_traceDumpClose (Vtop__Syms.h)</li> <li>_traceDumpOpen (Vtop__Syms.h)</li> <li>__Vconfigure (Vtop___024root.h, Vtop___024unit.h)</li> </ul>"},{"location":"TitanComms/macros/","title":"Macros","text":""},{"location":"TitanComms/macros/#d","title":"d","text":"<ul> <li>DEBUG (TitanComms.cpp)</li> <li>DEBUG_PRINT (TitanCommsDebug.h)</li> <li>DEBUG_PRINTLN (TitanCommsDebug.h)</li> <li>DEBUG_PRINTLN_STR (TitanCommsDebug.h)</li> <li>DEBUG_PRINT_BIN (TitanCommsDebug.h)</li> <li>DEBUG_PRINT_HEX (TitanCommsDebug.h)</li> <li>DEBUG_PRINT_INT (TitanCommsDebug.h)</li> <li>DEBUG_PRINT_SIZEOF (TitanCommsDebug.h)</li> <li>DEBUG_PRINT_STR (TitanCommsDebug.h)</li> </ul>"},{"location":"TitanComms/macros/#v","title":"v","text":"<ul> <li>VERILATED_VTOP_H_ (Vtop.h)</li> <li>VL_INCLUDE_OPT (Vtop__ALL.cpp)</li> <li>VERILATED_VTOP__DPI_H_ (Vtop__Dpi.h)</li> <li>VERILATED_VTOP__SYMS_H_ (Vtop__Syms.h)</li> <li>VERILATED_VTOP___024ROOT_H_ (Vtop___024root.h)</li> <li>VERILATED_VTOP___024UNIT_H_ (Vtop___024unit.h)</li> </ul>"},{"location":"TitanComms/variables/","title":"Variables","text":""},{"location":"TitanComms/variables/#d","title":"d","text":"<ul> <li>dut_param_mux__DOT____Vcellinp__uut_pmux__inputs (Vtop___024root.h)</li> <li>dut_param_mux__DOT__in1 (Vtop___024root.h)</li> <li>dut_param_mux__DOT__in2 (Vtop___024root.h)</li> <li>dut_param_mux__DOT__in3 (Vtop___024root.h)</li> <li>dut_param_mux__DOT__in4 (Vtop___024root.h)</li> <li>dut_param_mux__DOT__mux_o (Vtop___024root.h)</li> <li>dut_param_mux__DOT__sel_i (Vtop___024root.h)</li> <li>dut_param_mux__DOT__uut_pmux__DOT__INPUT_WIDTH (Vtop___024root.h)</li> <li>dut_param_mux__DOT__uut_pmux__DOT__SELECTOR_WIDTH (Vtop___024root.h)</li> <li>dut_param_mux__DOT__uut_pmux__DOT__SIGNAL_COUNT (Vtop___024root.h)</li> <li>dut_param_mux__DOT__uut_pmux__DOT__inputs (Vtop___024root.h)</li> <li>dut_param_mux__DOT__uut_pmux__DOT__out (Vtop___024root.h)</li> <li>dut_param_mux__DOT__uut_pmux__DOT__selector (Vtop___024root.h)</li> </ul>"},{"location":"TitanComms/variables/#i","title":"i","text":"<ul> <li>in1 (Vtop.h)</li> <li>in2 (Vtop.h)</li> <li>in3 (Vtop.h)</li> <li>in4 (Vtop.h)</li> </ul>"},{"location":"TitanComms/variables/#m","title":"m","text":"<ul> <li>mux_o (Vtop.h)</li> </ul>"},{"location":"TitanComms/variables/#r","title":"r","text":"<ul> <li>rootp (Vtop.h)</li> </ul>"},{"location":"TitanComms/variables/#s","title":"s","text":"<ul> <li>sel_i (Vtop.h)</li> </ul>"},{"location":"TitanComms/variables/#t","title":"t","text":"<ul> <li>TOP (Vtop__Syms.h)</li> </ul>"},{"location":"TitanComms/variables/#v","title":"v","text":"<ul> <li>vlSymsp (Vtop.h, Vtop___024root.h, Vtop___024unit.h)</li> </ul>"},{"location":"TitanComms/variables/#_","title":"_","text":"<ul> <li>__Vhier (Vtop__Syms.h)</li> <li>__Vm_activity (Vtop__Syms.h)</li> <li>__Vm_baseCode (Vtop__Syms.h)</li> <li>__Vm_didInit (Vtop__Syms.h)</li> <li>__Vm_dumperMutex (Vtop__Syms.h)</li> <li>__Vm_dumping (Vtop__Syms.h)</li> <li>__Vm_modelp (Vtop__Syms.h)</li> <li>__Vscope_TOP (Vtop__Syms.h)</li> <li>__Vscope_dut_param_mux (Vtop__Syms.h)</li> <li>__Vscope_dut_param_mux__uut_pmux (Vtop__Syms.h)</li> <li>__VactContinue (Vtop___024root.h)</li> <li>__VactIterCount (Vtop___024root.h)</li> <li>__VactTriggered (Vtop___024root.h)</li> <li>__VdlySched (Vtop___024root.h)</li> <li>__VicoIterCount (Vtop___024root.h)</li> <li>__VicoTriggered (Vtop___024root.h)</li> <li>__VnbaTriggered (Vtop___024root.h)</li> <li>__VstlIterCount (Vtop___024root.h)</li> <li>__VstlTriggered (Vtop___024root.h)</li> </ul>"},{"location":"TitanComms/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"}]}