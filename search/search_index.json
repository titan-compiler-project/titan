{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the Titan Compiler Project","text":"Curious about the project? <p>Check out the concept page.</p> Want to dive in? <p>See the user guide on how to get started.</p> Reference docs <p>Covers nearly everything you need to know about the compiler, communications method and the hardware modules.</p> Check out the authors <p>Visit the about page for some more info.</p> <p>Warning</p> <p>This is currently a work-in-progress compiler. Please be aware that there will be some bugs stil rumaging around in the code. </p>"},{"location":"about/","title":"About","text":"<p>Made as partial fulfilment of Masters by Research in Computer Science for the University of Lincoln by Kristaps Jurkans, supervised by Dr. Charles Fox.</p>"},{"location":"concept/","title":"The Concept","text":"<p>This compiler is based in the idea of DSAs, as talked about in Hennessy &amp; Pattersons Turing Award lecture. In essence, these devices have a highly specialised architecture, that targets one particular domain (think AI, ML, IoT) and provides a device which can perform tasks in that domain with better performance and efficiency.</p> <p>These architectures have to be custom built, and in order to achieve that we have to build some custom hardware. Instead of placing individual transistors down, we can program an FPGA using a HDL like SystemVerilog. Unfortunately, FPGAs do come with a steep learning curve, possibly dissuading people from using it. So why not attempt to make it easier to access, whilst also providing some DSA functionality?</p> <p>Python (and its variants like MicroPython) are growing in popularity, so much so that a recent StackOverflow survey had shown Python as being the 3rd most popular language. It seems like a good language to target due to that, but unfortunately it'll have to be a subset of the language so that it can map onto hardware and to also limit the scope of the compiler.</p> <p>Using SPIR-V as the intermediate language means that the front-end and back-end of the compiler can be swapped out, and the SPIR-V assembly can be compiled into something that can run on existing GPUs via OpenGL/OpenCL/Vulkan. Furthemore, SPIR-V's assembly structure mimics a dataflow graph, so we can use that to our advantage.</p> <p>With this SPIR-V assembly, we can then attempt to assemble some SystemVerilog and output this file to the user. With any luck, this SystemVerilog can be used to program the FPGA and provide the user with some custom hardware.</p>"},{"location":"license/","title":"License","text":"<p>This file is a part of the Titan Compiler Project.</p> <p>Copyright (C) 2023  Kristaps Jurkans</p> <p>This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.</p> <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.</p> <p>You should have received a copy of the GNU General Public License along with this program.  If not, see https://www.gnu.org/licenses/.</p>"},{"location":"reference-docs/pcb/","title":"FPGA Shield","text":"<p>An untested PCB design for an FPGA shield to interface with multiple microcontrollers over SPI is available in the repo. This shield is designed for the QMTech Cyclone V 5CEFA2 Core Development Board, and is very unlikely to work on other development boards. </p> <p>Features:</p> <ul> <li>Ability to connect a Raspberry Pi Pico, Teensy 3.2, ESP32 and CH341</li> <li>Header for OLED display, selectable source via jumpers</li> <li>Additional SPI headers</li> <li>I2C headers, with optional pull-up resistors</li> <li>Onboard 3.3V power supply </li> </ul>"},{"location":"reference-docs/compiler/ast_crawl/","title":"Documentation for <code>ast_crawl.py</code>","text":""},{"location":"reference-docs/compiler/ast_crawl/#titan.ast_crawl._SPIRVHelperGenerator","title":"<code>titan.ast_crawl._SPIRVHelperGenerator</code>","text":"<p>Helper class that provides functions related to SPIR-V generation.</p> Source code in <code>titan/ast_crawl.py</code> <pre><code>class _SPIRVHelperGenerator():\n    \"\"\"Helper class that provides functions related to SPIR-V generation.\"\"\"\n\n    class Sections(enum.Enum):\n        \"\"\" Enum containing sections that are present in the final SPIR-V assembly file.\n\n            Dividing the SPIR-V file into sections helps with ensuring that the code is\n            placed in the right spot, and can be easily altered if needed.\n        \"\"\"\n        CAPABILITY_AND_EXTENSION = enum.auto()\n        ENTRY_AND_EXEC_MODES = enum.auto()\n        DEBUG_STATEMENTS = enum.auto()\n        ANNOTATIONS = enum.auto()\n        TYPES = enum.auto()\n        VAR_CONST_DECLARATIONS = enum.auto()\n        FUNCTIONS = enum.auto()\n\n    class TypeContext(typing.NamedTuple):\n        \"\"\" Tuple that provides context about a given type. Used to align Python types with SPIR-V.\n\n            Attributes:\n                primative_type (titan.common.type.DataType): Base/primative (python) type.\n                storage_type (titan.common.type.StorageType): Storage type in SPIR-V.\n                is_constant (bool): Type describes a constant.\n                is_pointer (bool): Type describes a pointer.\n                is_function_typedef (bool): Type describes a function definition. \n        \"\"\"\n        primative_type: titan_type.DataType\n        storage_type: titan_type.StorageType = titan_type.StorageType.NONE\n        is_constant: bool = False\n        is_pointer: bool = False\n        is_function_typedef: bool = False\n\n    class ConstContext(typing.NamedTuple):\n        \"\"\" Tuple that provides context about a given constant.\n\n            Attributes:\n                primative_type (titan.common.type.DataType): Base/primative (python) type.\n                value: Value of the constant. Can be int, float, bool or None.\n        \"\"\"\n        primative_type: titan_type.DataType\n        value: typing.Union[int, float, bool, None]\n\n    class SymbolInfo(typing.NamedTuple):\n        \"\"\" Tuple that associates a primative type with a storage location.\n\n            Attributes:\n                type (titan.common.type.DataType): Base/primative (python) type.\n                location (titan.common.type.StorageType): Storage type in SPIR-V.\n        \"\"\"\n        type: titan_type.DataType\n        location: titan_type.StorageType\n\n\n    def __init__(self, disable_debug=True):\n        \"\"\" Init function for _SPIRVHelperGenerator.\n\n            Creates various attributes and allows for helper function access.\n\n            Args:\n                disable_debug (bool): Disable debug output.\n\n            Attributes:\n                entry_point (string): TODO\n                _disable_debug (bool): Disables debug. Set to value of parameter.\n                _latest_ifexp_selector_id (None): Last known ID for an if-expression selector.\n                _latest_compare_id (None): Last known ID for a compare expression.\n                _latest_function_name (None): TODO\n                _decorator_dict: Stores information regarding decorators are used on which functions.\n                input_port_list (TypedDict): List of input port names and their primative types.\n                output_port_lsit (TypedDict): List of output port names and their primative types.\n                _internal_output_port_list_counter (None): TODO\n                output_type_list: TODO\n                symbol_info: TODO\n                location_id: TODO\n                intermediate_id (int): Keep track of latest intermediate ID (used by unrolled expressions).\n                return_id (int): TODO\n                intermediate_ids: List of used intermediate IDs. Stores ID as string and primative type.\n                declared_constants: List of declared constants. Stores ConstContext and string ID of constant.\n                declared_types: List of declared types. Stores primative type and string ID.\n                body: TODO\n                generated_spirv (dict): Dictionary indexed with Sections enum, and stores generated lines in a list.\n        \"\"\"\n\n        self.entry_point = \"\"\n        self._disable_debug = disable_debug\n        self._latest_ifexp_selector_id = None\n        self._latest_compare_id = None\n        self._latest_function_name = None\n\n        self._decorator_dict = {}\n\n\n        class symbol_type_hint(typing.TypedDict):\n            symbol: str\n            type: typing.Union[int, float, bool, None]\n\n        class declared_constants_hint(typing.TypedDict):\n            type: self.ConstContext\n            spirv_id: str\n\n        class declared_types_hint(typing.TypedDict):\n            type: titan_type.DataType\n            spirv_id: str\n\n        class symbol_info_hint(typing.TypedDict):\n            symbol_id: str\n            info: self.SymbolInfo\n\n        class intermediate_id_type_hint(typing.TypedDict):\n            intermediate_id: str\n            type: titan_type.DataType\n\n        self.input_port_list: symbol_type_hint = {}\n        self.output_port_list: symbol_type_hint = {}\n\n        # attempts to align the output type list with the output port/symbol list\n        # this is so that the correct id (assuming that it is handled in order) will be assigned the correct type\n        # perhaps slightly over-engineered?\n        self._internal_output_port_list_counter = 0 \n        self.output_type_list = []\n\n        # TODO: probably remove \n        # self.symbols_and_types: symbol_type_hint = {}\n\n        self.symbol_info: symbol_info_hint = {}\n\n        self.location_id = 0\n        self.intermediate_id = 0\n        self.return_id = 0\n        self.intermediate_ids: intermediate_id_type_hint = {}\n\n        self.declared_constants: declared_constants_hint = {}\n        self.declared_types: declared_types_hint = {}\n        self.body = []\n\n        self.generated_spirv = {\n            self.Sections.CAPABILITY_AND_EXTENSION.name: [],\n            self.Sections.ENTRY_AND_EXEC_MODES.name: [],\n            self.Sections.DEBUG_STATEMENTS.name: [],\n            self.Sections.ANNOTATIONS.name: [],\n            self.Sections.TYPES.name: [],\n            self.Sections.VAR_CONST_DECLARATIONS.name: [],\n            self.Sections.FUNCTIONS.name: []\n        }\n\n    def dump(self):\n        \"\"\"Output debug info if debug flag has been set. Uses the logging library.\"\"\"\n        if not self._disable_debug:\n\n            logging.debug(f\"[debug info _SPIRVHelperGenerator]\")\n            logging.debug(f\"entry point: {self.entry_point}\")\n            logging.debug(f\"input port list: {self.input_port_list}\")\n            logging.debug(f\"output port list: {self.output_port_list}\")\n            logging.debug(f\"output type list: {self.output_type_list}\")\n\n            logging.debug(f\"symbols with info:\")\n            for id, info in self.symbol_info.items():\n                logging.debug(f\"\\t{id} -&gt; {info}\")\n\n            logging.debug(f\"declared constants:\")\n            for info, id in self.declared_constants.items():\n                logging.debug(f\"\\t{id} -&gt; {info}\")\n\n\n            logging.debug(f\"declared types:\")\n            for info, id in self.declared_types.items():\n                logging.debug(f\"\\t{id} -&gt; {info}\")\n\n            logging.debug(f\"intermediate line id &amp; type:\")\n            for id, type in self.intermediate_ids.items():\n                logging.debug(f\"\\t{id} -&gt; {type}\")\n\n            logging.debug(f\"generated spirv:\")\n            for section in self.generated_spirv.keys():\n                logging.debug(f\"section: {section}\")\n\n                for value in self.generated_spirv[section]:\n                    logging.debug(f\"\\t{value}\")\n\n\n    def add_line(self, section: Sections, line:str):\n        # \"\"\"add a line of generated SPIR-V to a certain section\"\"\"\n        \"\"\" Add a generated line of SPIR-V to a given section.\n\n            Args:\n                section (titan.ast_crawl._SPIRVHelperGenerator.Sections): The section to append the line to.\n                line (str): The line to add.\n        \"\"\"\n        self.generated_spirv[section.name].append(line)\n\n    def add_output_type(self, type):\n        \"\"\" Add an output type.\n\n            Args:\n                type: The type to add.\n\n            Warning:\n                This function may be removed in the future. It's not clear _what_ specifically it is adding.\n                Could possibly cause issues with the rest of the program.\n        \"\"\"\n        self.output_type_list.append(type)\n\n    def add_output_symbol(self, symbol:str):\n        \"\"\" Add an output symbol to the output_port_list.\n\n            Also increments an internal counter.\n\n            Args:\n                symbol (str): The symbol to be added. \n        \"\"\"\n\n        # HACK: what is the point of this line\n        self.output_port_list[symbol] = self.output_type_list[self._internal_output_port_list_counter]\n        self._internal_output_port_list_counter += 1\n\n    def symbol_exists(self, symbol: str) -&gt; bool:\n        \"\"\" Check if a symbol exists.\n\n            Args:\n                symbol (str): Given symbol name, with the SPIR-V \"%\" prefix.\n\n            Returns:\n                symbol_exists: True if symbol exists, else False.\n        \"\"\"\n\n        return True if symbol in self.symbol_info else False\n\n    # no overloading\n    # def add_symbol(self, symbol_id: str, info: SymbolInfo):\n        # self.symbol_info[symbol_id] = info\n\n    def add_symbol(self, symbol_id: str, type, location: titan_type.StorageType):\n        \"\"\" Add a symbol.\n\n            The value ``type`` arg will be automatically converted into a valid ``titan.common.type.DataType`` value.\n\n            Args:\n                symbol_id: ID given to the symbol.\n                type: Python type of the symbol.\n                location: Given storage location for the symbol. Required for SPIR-V.\n\n            TODO:\n                Need to determine whether the symbol ID contains the \"%\" prefix or not.\n        \"\"\"\n        self.symbol_info[symbol_id] = self.SymbolInfo(titan_type.DataType(type), location)\n\n    def get_symbol_info(self, symbol_id: str) -&gt; SymbolInfo:\n        \"\"\" Get information regarding a given symbol via ID.\n\n            Args:\n                symbol_id: ID of the symbol to check.\n\n            Returns:\n                Symbol information tuple.\n        \"\"\"\n        return self.symbol_info[symbol_id]\n\n    # basically works the same as add_symbol\n    def update_symbol_info(self, symbol_id:str, info: SymbolInfo):\n        \"\"\" Update the information currently stored of a given symbol.\n\n            Warning:\n                Simply overwrites an existing entry. The symbol _must_ have be declared before using this,\n                otherwise you may run into a KeyError exception.\n\n            Args:\n                symbol_id: ID of the symbol to update.\n                info: Tuple to update the information with.\n        \"\"\"\n        self.symbol_info[symbol_id] = info\n\n    def add_symbol_if_nonexistant(self, symbol: str, type, location: titan_type.StorageType) -&gt; bool:\n        \"\"\" Add a symbol, only if it does not already exist.\n\n            Method first checks if symbol exists or not. If not, it'll generate the corresponding SPIR-V\n            lines depending on its type and location, and increment the ``location_id`` counter.\n\n            Args:\n                symbol: Name of the symbol to add.\n                type: Python type of the symbol.\n                location: Given storage location for the symbol. Required for SPIR-V.\n\n            Returns:\n                symbol_added: True if symbol has been added, else False.\n        \"\"\"\n\n        if symbol not in self.symbol_info:\n            self.symbol_info[symbol] = self.SymbolInfo(titan_type.DataType(type), location)\n\n            self.add_line(\n                self.Sections.DEBUG_STATEMENTS,\n                f\"OpName %{symbol} \\\"{symbol}\\\"\"\n            )\n\n            # TODO: more elegant solution?\n            # if i/o\n            if location is (titan_type.StorageType.IN or titan_type.StorageType.OUT):\n                # add location (glsl specific i think)\n                self.add_line(\n                    self.Sections.ANNOTATIONS,\n                    f\"OpDecorate %{symbol} Location {self.location_id}\"\n                )\n\n                if location is titan_type.StorageType.IN:\n                    self.add_line(\n                        self.Sections.ANNOTATIONS,\n                        # more glsl specific stuff\n                        f\"OpDecorate %{symbol} Flat\"\n                    )\n\n                    # input variable pointer type\n                    ptr_ctx = self.TypeContext(\n                            titan_type.DataType(type), titan_type.StorageType.IN,\n                            False, True, False\n                    )\n\n                    ptr_id = self.add_type_if_nonexistant(\n                        ptr_ctx,\n                        f\"%pointer_input_{titan_type.DataType(type).name.lower()}\"\n                    )\n\n                    self.add_line(\n                        self.Sections.VAR_CONST_DECLARATIONS,\n                        f\"%{symbol} = OpVariable {ptr_id} Input\"\n                    )\n                elif location is titan_type.StorageType.OUT:\n                    ptr_ctx = self.TypeContext(\n                        titan_type.DataType(type), titan_type.StorageType.IN,\n                        False, True, False\n                    )\n\n                    ptr_id = self.add_type_if_nonexistant(\n                        ptr_ctx,\n                        f\"%pointer_output_{titan_type.DataType(type).name.lower()}\"\n                    )\n\n                    self.add_line(\n                        self.Sections.VAR_CONST_DECLARATIONS,\n                        f\"%{symbol} = OpVariable {ptr_id} Output\"\n                    )\n            elif location is titan_type.StorageType.FUNCTION_VAR:\n\n                ptr_id = self.add_type_if_nonexistant(\n                    self.TypeContext(\n                        titan_type.DataType(type), titan_type.StorageType.FUNCTION_VAR,\n                        False, True, False\n                    ),\n                    f\"%pointer_funcvar_{titan_type.DataType(type).name.lower()}\"\n                )\n\n                self.add_line(\n                    self.Sections.FUNCTIONS,\n                    f\"%{symbol} = OpVariable {ptr_id} Function\"\n                )\n\n            self.location_id += 1\n\n            return True\n        else:\n            return False\n\n    def get_symbol_type(self, symbol:str) -&gt; titan_type.DataType:\n        \"\"\" Get symbol type, using symbol ID.\n\n            Args:\n                symbol: Symbol ID\n\n            Returns:\n                Primative type of symbol.\n        \"\"\"\n\n        # symbol_info[symbol] -&gt; info (SymbolInfo).type\n        return self.symbol_info[symbol].type\n\n\n\n    # def get_symbol_as_type_context(self, symbol):\n    #     \"\"\"DO NOT USE returns primative type only\"\"\"\n    #     # TODO: handle funcvars somehow\n    #     # perhaps dumb override?\n    #     return self.symbols_and_types[symbol]\n\n\n    def intermediate_id_exists(self, intermediate_id: str) -&gt; bool:\n        \"\"\" Check if an intermediate ID already exists.\n\n            Args:\n                intermediate_id: Intermediate ID to check.\n\n            Returns:\n                True if intermediate ID already exists, else False.\n        \"\"\"\n        return True if intermediate_id in self.intermediate_ids else False\n\n    def add_intermediate_id(self, intermediate_id: str, type: titan_type.DataType):\n        \"\"\" Add an intermediate ID.\n\n            Args:\n                intermediate_id: Intermediate ID to add.\n                type: Type to associate with the intermediate ID.\n        \"\"\"\n        self.intermediate_ids[intermediate_id] = type\n\n    def get_type_of_intermediate_id(self, intermediate_id: str) -&gt; titan_type.DataType:\n        \"\"\" Returns the type of an intermediate ID, _not_ the type ID.\n\n            Args:\n                intermediate_id: Intermediate ID to return the type of.\n\n            Returns:\n                Primative intermediate ID type.\n        \"\"\"\n        return self.intermediate_ids[intermediate_id]\n\n    # type helpers\n    def type_exists(self, type: TypeContext) -&gt; bool:\n        \"\"\" Check if a type already exists, using a ``TypeContext``.\n\n            Args:\n                type: Type to check if it exists.\n\n            Returns:\n                True if type exists, else False.\n        \"\"\"\n        return True if type in self.declared_types else False\n\n    def add_type(self, type: TypeContext, id: str):\n        \"\"\" Add a type, using ``TypeContext``. Used to generate SPIR-V types.\n\n            Args:\n                type: Type, as ``TypeContext`` to add.\n                id: ID to associate with the type.\n        \"\"\"\n        self.declared_types[type] = id\n\n    def get_type_id(self, type: TypeContext) -&gt; str:\n        \"\"\" Get the ID of a given type.\n\n            Args:\n                type: Type to get ID for.\n\n            Returns:\n                ID of the type.\n        \"\"\"\n        # FIXME: the type hint declared for this attribute does not use TypeContext as the key.\n        #        declared_type_hint suggests to use common.type.DataType as the key!\n        return self.declared_types[type]\n\n    def get_primative_type_id(self, type: titan_type.DataType) -&gt; str:\n        \"\"\" Get the ID of a primative type.\n\n            Args:\n                type: Primative type to get ID for.\n\n            Return:\n                ID of the type.\n        \"\"\"\n\n        # TODO: convoluted? may be a better way to do this\n        # can this just be replaced with indexing with the primative type instead of going through TypeContext?\n        return self.declared_types[\n            self.TypeContext(titan_type.DataType(type))\n        ]\n\n    def add_type_if_nonexistant(self, type: TypeContext, id: str) -&gt; str:\n        \"\"\" Add a type, only if it does not already exist.\n\n            If the type does not already exist, the function will generate the corresponding SPIR-V for it.\n\n            Note: Currently supported types:\n                - OpTypeVoid\n                - OpTypeInteger (32-bit signed)\n                - OpTypeBool\n                - OpTypeFloat (32-bit float)\n\n            Args:\n                type: The type to add.\n                id: The ID to associate with the type.\n\n            Returns:\n                type_id: The ID of the type.\n        \"\"\"\n        if not self.type_exists(type):\n\n            # TODO: remove\n            self.add_type(type, id)\n\n            spirv_txt = f\"{id} = \"\n\n            if type.is_function_typedef:\n                prim_tid = self.get_primative_type_id(type.primative_type)\n                spirv_txt += f\"OpTypeFunction {prim_tid}\"\n            elif type.is_pointer:\n                prim_tid = self.get_primative_type_id(type.primative_type)\n                storage_type = \"\"\n\n                match type.storage_type:\n                    case titan_type.StorageType.IN:\n                        storage_type = \"Input\"\n                    case titan_type.StorageType.OUT:\n                        storage_type = \"Output\"\n                    case titan_type.StorageType.FUNCTION_VAR:\n                        storage_type = \"Function\"\n                    case _:\n                        logging.exception(f\"no text for storage type for {type.storage_type}\", exc_info=False)\n                        raise Exception(f\"no text for storage type for {type.storage_type}\")\n\n                spirv_txt += f\"OpTypePointer {storage_type} {prim_tid}\"\n\n            # this should mean we're working with the primative types\n            elif (not type.is_constant) and (not type.is_pointer) and (not type.is_function_typedef):\n\n                match type.primative_type:\n                    case titan_type.DataType.VOID:\n                        spirv_txt += f\"OpTypeVoid\"\n                    case titan_type.DataType.INTEGER:\n                        spirv_txt += f\"OpTypeInt 32 1\"\n                    case titan_type.DataType.BOOLEAN:\n                        spirv_txt += f\"OpTypeBool\"\n                    case titan_type.DataType.FLOAT:\n                        spirv_txt += f\"OpTypeFloat 32\"\n                    case _:\n                        logging.exception(f\"type text for {type} not implemented yet (did you wrap the type in a DataType() call to enum?)\", exc_info=False)\n                        raise Exception(f\"type text for {type} not implemented yet (did you wrap the type in a DataType() call to enum?)\")\n            else:\n                logging.exception(f\"unable to generate spirv text for type {id} -&gt; {type}\", exc_info=False)\n                raise Exception(f\"unable to generate spirv text for type {id} -&gt; {type}\")\n\n            self.add_line(\n                self.Sections.TYPES,\n                spirv_txt\n            )\n\n            return id\n        else:\n            return self.get_type_id(type)\n\n    # const helpers\n    def const_exists(self, const: ConstContext) -&gt; bool:\n        \"\"\" Check if a constant exists.\n\n            Args:\n                const: Constant to check.\n\n            Returns:\n                True if constant exists, else False.\n        \"\"\"\n        return True if const in self.declared_constants else False\n\n    def add_const(self, c_ctx: ConstContext, spirv_id: str):\n        \"\"\" Add a constant.\n\n            Args:\n                c_ctx: Constant to add.\n                spirv_id: The ID to associate with the constant.\n        \"\"\"\n        self.declared_constants[c_ctx] = spirv_id\n\n    def add_const_if_nonexistant(self, const: ConstContext, negative_val:bool = False) -&gt; str:\n        \"\"\" Add a constant, only if it does not exist already.\n\n            Checks if the constant exists, and if not, the method will generate the corresponding SPIR-V.\n\n            Args:\n                const: Constant to add.\n                negative_val: Flag the value as a negative constant. Needed to generate the SPIR-V assembly correctly.\n\n            Returns:\n                constant_id: Returns the ID of the constant.\n        \"\"\"\n\n        if const not in self.declared_constants:\n            txt_val = str(const.value)\n            const_str = f\"const_{titan_type.DataType(const.primative_type).name.lower()}\"\n\n            # format the string properly\n            if negative_val:\n                txt_val = txt_val.replace(\"-\", \"n\")\n\n            if const.primative_type is float:\n                txt_val = txt_val.replace(\".\", \"_\")\n\n            const_str += f\"_{txt_val}\"\n\n            self.declared_constants[const] = const_str\n\n            # check if type has been declared\n            self.add_type_if_nonexistant(self.TypeContext(titan_type.DataType(const.primative_type)),f\"%type_{(titan_type.DataType(const.primative_type).name).lower()}\")\n\n            self.add_line(\n                self.Sections.VAR_CONST_DECLARATIONS,\n                f\"%{const_str} = OpConstant {self.get_primative_type_id(titan_type.DataType(const.primative_type))} {const.value}\"\n            )\n\n            return const_str\n        else:\n            return self.declared_constants[const]\n\n    # TODO: add one that uses the ConstContext thing directly?\n    def get_const_id(self, value, type) -&gt; str:\n        \"\"\" Get the ID of a constant.\n\n            Args:\n                value: A constant value.\n                type: The type of the constant value.\n\n            Returns:\n                ID of the constant.\n        \"\"\"\n        temp_c_ctx = self.ConstContext(type, value)\n        return self.declared_constants[temp_c_ctx]\n\n    def get_const_id_with_ctx(self, context: ConstContext) -&gt; str:\n        \"\"\" Get the ID of a constant, using ``ConstContext``.\n\n            Args:\n                context: Context of the constant.\n\n            Returns:\n                ID of the constant.\n        \"\"\"\n        return self.declared_constants[context]\n</code></pre>"},{"location":"reference-docs/compiler/ast_crawl/#titan.ast_crawl._SPIRVHelperGenerator.ConstContext","title":"<code>ConstContext</code>","text":"<p>             Bases: <code>NamedTuple</code></p> <p>Tuple that provides context about a given constant.</p> <p>Attributes:</p> Name Type Description <code>primative_type</code> <code>DataType</code> <p>Base/primative (python) type.</p> <code>value</code> <code>Union[int, float, bool, None]</code> <p>Value of the constant. Can be int, float, bool or None.</p> Source code in <code>titan/ast_crawl.py</code> <pre><code>class ConstContext(typing.NamedTuple):\n    \"\"\" Tuple that provides context about a given constant.\n\n        Attributes:\n            primative_type (titan.common.type.DataType): Base/primative (python) type.\n            value: Value of the constant. Can be int, float, bool or None.\n    \"\"\"\n    primative_type: titan_type.DataType\n    value: typing.Union[int, float, bool, None]\n</code></pre>"},{"location":"reference-docs/compiler/ast_crawl/#titan.ast_crawl._SPIRVHelperGenerator.Sections","title":"<code>Sections</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Enum containing sections that are present in the final SPIR-V assembly file.</p> <p>Dividing the SPIR-V file into sections helps with ensuring that the code is placed in the right spot, and can be easily altered if needed.</p> Source code in <code>titan/ast_crawl.py</code> <pre><code>class Sections(enum.Enum):\n    \"\"\" Enum containing sections that are present in the final SPIR-V assembly file.\n\n        Dividing the SPIR-V file into sections helps with ensuring that the code is\n        placed in the right spot, and can be easily altered if needed.\n    \"\"\"\n    CAPABILITY_AND_EXTENSION = enum.auto()\n    ENTRY_AND_EXEC_MODES = enum.auto()\n    DEBUG_STATEMENTS = enum.auto()\n    ANNOTATIONS = enum.auto()\n    TYPES = enum.auto()\n    VAR_CONST_DECLARATIONS = enum.auto()\n    FUNCTIONS = enum.auto()\n</code></pre>"},{"location":"reference-docs/compiler/ast_crawl/#titan.ast_crawl._SPIRVHelperGenerator.SymbolInfo","title":"<code>SymbolInfo</code>","text":"<p>             Bases: <code>NamedTuple</code></p> <p>Tuple that associates a primative type with a storage location.</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>DataType</code> <p>Base/primative (python) type.</p> <code>location</code> <code>StorageType</code> <p>Storage type in SPIR-V.</p> Source code in <code>titan/ast_crawl.py</code> <pre><code>class SymbolInfo(typing.NamedTuple):\n    \"\"\" Tuple that associates a primative type with a storage location.\n\n        Attributes:\n            type (titan.common.type.DataType): Base/primative (python) type.\n            location (titan.common.type.StorageType): Storage type in SPIR-V.\n    \"\"\"\n    type: titan_type.DataType\n    location: titan_type.StorageType\n</code></pre>"},{"location":"reference-docs/compiler/ast_crawl/#titan.ast_crawl._SPIRVHelperGenerator.TypeContext","title":"<code>TypeContext</code>","text":"<p>             Bases: <code>NamedTuple</code></p> <p>Tuple that provides context about a given type. Used to align Python types with SPIR-V.</p> <p>Attributes:</p> Name Type Description <code>primative_type</code> <code>DataType</code> <p>Base/primative (python) type.</p> <code>storage_type</code> <code>StorageType</code> <p>Storage type in SPIR-V.</p> <code>is_constant</code> <code>bool</code> <p>Type describes a constant.</p> <code>is_pointer</code> <code>bool</code> <p>Type describes a pointer.</p> <code>is_function_typedef</code> <code>bool</code> <p>Type describes a function definition.</p> Source code in <code>titan/ast_crawl.py</code> <pre><code>class TypeContext(typing.NamedTuple):\n    \"\"\" Tuple that provides context about a given type. Used to align Python types with SPIR-V.\n\n        Attributes:\n            primative_type (titan.common.type.DataType): Base/primative (python) type.\n            storage_type (titan.common.type.StorageType): Storage type in SPIR-V.\n            is_constant (bool): Type describes a constant.\n            is_pointer (bool): Type describes a pointer.\n            is_function_typedef (bool): Type describes a function definition. \n    \"\"\"\n    primative_type: titan_type.DataType\n    storage_type: titan_type.StorageType = titan_type.StorageType.NONE\n    is_constant: bool = False\n    is_pointer: bool = False\n    is_function_typedef: bool = False\n</code></pre>"},{"location":"reference-docs/compiler/ast_crawl/#titan.ast_crawl._SPIRVHelperGenerator.__init__","title":"<code>__init__(disable_debug=True)</code>","text":"<p>Init function for _SPIRVHelperGenerator.</p> <p>Creates various attributes and allows for helper function access.</p> <p>Parameters:</p> Name Type Description Default <code>disable_debug</code> <code>bool</code> <p>Disable debug output.</p> <code>True</code> <p>Attributes:</p> Name Type Description <code>entry_point</code> <code>string</code> <p>TODO</p> <code>_disable_debug</code> <code>bool</code> <p>Disables debug. Set to value of parameter.</p> <code>_latest_ifexp_selector_id</code> <code>None</code> <p>Last known ID for an if-expression selector.</p> <code>_latest_compare_id</code> <code>None</code> <p>Last known ID for a compare expression.</p> <code>_latest_function_name</code> <code>None</code> <p>TODO</p> <code>_decorator_dict</code> <code>None</code> <p>Stores information regarding decorators are used on which functions.</p> <code>input_port_list</code> <code>TypedDict</code> <p>List of input port names and their primative types.</p> <code>output_port_lsit</code> <code>TypedDict</code> <p>List of output port names and their primative types.</p> <code>_internal_output_port_list_counter</code> <code>None</code> <p>TODO</p> <code>output_type_list</code> <code>None</code> <p>TODO</p> <code>symbol_info</code> <code>None</code> <p>TODO</p> <code>location_id</code> <code>None</code> <p>TODO</p> <code>intermediate_id</code> <code>int</code> <p>Keep track of latest intermediate ID (used by unrolled expressions).</p> <code>return_id</code> <code>int</code> <p>TODO</p> <code>intermediate_ids</code> <code>int</code> <p>List of used intermediate IDs. Stores ID as string and primative type.</p> <code>declared_constants</code> <code>int</code> <p>List of declared constants. Stores ConstContext and string ID of constant.</p> <code>declared_types</code> <code>int</code> <p>List of declared types. Stores primative type and string ID.</p> <code>body</code> <code>int</code> <p>TODO</p> <code>generated_spirv</code> <code>dict</code> <p>Dictionary indexed with Sections enum, and stores generated lines in a list.</p> Source code in <code>titan/ast_crawl.py</code> <pre><code>def __init__(self, disable_debug=True):\n    \"\"\" Init function for _SPIRVHelperGenerator.\n\n        Creates various attributes and allows for helper function access.\n\n        Args:\n            disable_debug (bool): Disable debug output.\n\n        Attributes:\n            entry_point (string): TODO\n            _disable_debug (bool): Disables debug. Set to value of parameter.\n            _latest_ifexp_selector_id (None): Last known ID for an if-expression selector.\n            _latest_compare_id (None): Last known ID for a compare expression.\n            _latest_function_name (None): TODO\n            _decorator_dict: Stores information regarding decorators are used on which functions.\n            input_port_list (TypedDict): List of input port names and their primative types.\n            output_port_lsit (TypedDict): List of output port names and their primative types.\n            _internal_output_port_list_counter (None): TODO\n            output_type_list: TODO\n            symbol_info: TODO\n            location_id: TODO\n            intermediate_id (int): Keep track of latest intermediate ID (used by unrolled expressions).\n            return_id (int): TODO\n            intermediate_ids: List of used intermediate IDs. Stores ID as string and primative type.\n            declared_constants: List of declared constants. Stores ConstContext and string ID of constant.\n            declared_types: List of declared types. Stores primative type and string ID.\n            body: TODO\n            generated_spirv (dict): Dictionary indexed with Sections enum, and stores generated lines in a list.\n    \"\"\"\n\n    self.entry_point = \"\"\n    self._disable_debug = disable_debug\n    self._latest_ifexp_selector_id = None\n    self._latest_compare_id = None\n    self._latest_function_name = None\n\n    self._decorator_dict = {}\n\n\n    class symbol_type_hint(typing.TypedDict):\n        symbol: str\n        type: typing.Union[int, float, bool, None]\n\n    class declared_constants_hint(typing.TypedDict):\n        type: self.ConstContext\n        spirv_id: str\n\n    class declared_types_hint(typing.TypedDict):\n        type: titan_type.DataType\n        spirv_id: str\n\n    class symbol_info_hint(typing.TypedDict):\n        symbol_id: str\n        info: self.SymbolInfo\n\n    class intermediate_id_type_hint(typing.TypedDict):\n        intermediate_id: str\n        type: titan_type.DataType\n\n    self.input_port_list: symbol_type_hint = {}\n    self.output_port_list: symbol_type_hint = {}\n\n    # attempts to align the output type list with the output port/symbol list\n    # this is so that the correct id (assuming that it is handled in order) will be assigned the correct type\n    # perhaps slightly over-engineered?\n    self._internal_output_port_list_counter = 0 \n    self.output_type_list = []\n\n    # TODO: probably remove \n    # self.symbols_and_types: symbol_type_hint = {}\n\n    self.symbol_info: symbol_info_hint = {}\n\n    self.location_id = 0\n    self.intermediate_id = 0\n    self.return_id = 0\n    self.intermediate_ids: intermediate_id_type_hint = {}\n\n    self.declared_constants: declared_constants_hint = {}\n    self.declared_types: declared_types_hint = {}\n    self.body = []\n\n    self.generated_spirv = {\n        self.Sections.CAPABILITY_AND_EXTENSION.name: [],\n        self.Sections.ENTRY_AND_EXEC_MODES.name: [],\n        self.Sections.DEBUG_STATEMENTS.name: [],\n        self.Sections.ANNOTATIONS.name: [],\n        self.Sections.TYPES.name: [],\n        self.Sections.VAR_CONST_DECLARATIONS.name: [],\n        self.Sections.FUNCTIONS.name: []\n    }\n</code></pre>"},{"location":"reference-docs/compiler/ast_crawl/#titan.ast_crawl._SPIRVHelperGenerator.add_const","title":"<code>add_const(c_ctx, spirv_id)</code>","text":"<p>Add a constant.</p> <p>Parameters:</p> Name Type Description Default <code>c_ctx</code> <code>ConstContext</code> <p>Constant to add.</p> required <code>spirv_id</code> <code>str</code> <p>The ID to associate with the constant.</p> required Source code in <code>titan/ast_crawl.py</code> <pre><code>def add_const(self, c_ctx: ConstContext, spirv_id: str):\n    \"\"\" Add a constant.\n\n        Args:\n            c_ctx: Constant to add.\n            spirv_id: The ID to associate with the constant.\n    \"\"\"\n    self.declared_constants[c_ctx] = spirv_id\n</code></pre>"},{"location":"reference-docs/compiler/ast_crawl/#titan.ast_crawl._SPIRVHelperGenerator.add_const_if_nonexistant","title":"<code>add_const_if_nonexistant(const, negative_val=False)</code>","text":"<p>Add a constant, only if it does not exist already.</p> <p>Checks if the constant exists, and if not, the method will generate the corresponding SPIR-V.</p> <p>Parameters:</p> Name Type Description Default <code>const</code> <code>ConstContext</code> <p>Constant to add.</p> required <code>negative_val</code> <code>bool</code> <p>Flag the value as a negative constant. Needed to generate the SPIR-V assembly correctly.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>constant_id</code> <code>str</code> <p>Returns the ID of the constant.</p> Source code in <code>titan/ast_crawl.py</code> <pre><code>def add_const_if_nonexistant(self, const: ConstContext, negative_val:bool = False) -&gt; str:\n    \"\"\" Add a constant, only if it does not exist already.\n\n        Checks if the constant exists, and if not, the method will generate the corresponding SPIR-V.\n\n        Args:\n            const: Constant to add.\n            negative_val: Flag the value as a negative constant. Needed to generate the SPIR-V assembly correctly.\n\n        Returns:\n            constant_id: Returns the ID of the constant.\n    \"\"\"\n\n    if const not in self.declared_constants:\n        txt_val = str(const.value)\n        const_str = f\"const_{titan_type.DataType(const.primative_type).name.lower()}\"\n\n        # format the string properly\n        if negative_val:\n            txt_val = txt_val.replace(\"-\", \"n\")\n\n        if const.primative_type is float:\n            txt_val = txt_val.replace(\".\", \"_\")\n\n        const_str += f\"_{txt_val}\"\n\n        self.declared_constants[const] = const_str\n\n        # check if type has been declared\n        self.add_type_if_nonexistant(self.TypeContext(titan_type.DataType(const.primative_type)),f\"%type_{(titan_type.DataType(const.primative_type).name).lower()}\")\n\n        self.add_line(\n            self.Sections.VAR_CONST_DECLARATIONS,\n            f\"%{const_str} = OpConstant {self.get_primative_type_id(titan_type.DataType(const.primative_type))} {const.value}\"\n        )\n\n        return const_str\n    else:\n        return self.declared_constants[const]\n</code></pre>"},{"location":"reference-docs/compiler/ast_crawl/#titan.ast_crawl._SPIRVHelperGenerator.add_intermediate_id","title":"<code>add_intermediate_id(intermediate_id, type)</code>","text":"<p>Add an intermediate ID.</p> <p>Parameters:</p> Name Type Description Default <code>intermediate_id</code> <code>str</code> <p>Intermediate ID to add.</p> required <code>type</code> <code>DataType</code> <p>Type to associate with the intermediate ID.</p> required Source code in <code>titan/ast_crawl.py</code> <pre><code>def add_intermediate_id(self, intermediate_id: str, type: titan_type.DataType):\n    \"\"\" Add an intermediate ID.\n\n        Args:\n            intermediate_id: Intermediate ID to add.\n            type: Type to associate with the intermediate ID.\n    \"\"\"\n    self.intermediate_ids[intermediate_id] = type\n</code></pre>"},{"location":"reference-docs/compiler/ast_crawl/#titan.ast_crawl._SPIRVHelperGenerator.add_line","title":"<code>add_line(section, line)</code>","text":"<p>Add a generated line of SPIR-V to a given section.</p> <p>Parameters:</p> Name Type Description Default <code>section</code> <code>Sections</code> <p>The section to append the line to.</p> required <code>line</code> <code>str</code> <p>The line to add.</p> required Source code in <code>titan/ast_crawl.py</code> <pre><code>def add_line(self, section: Sections, line:str):\n    # \"\"\"add a line of generated SPIR-V to a certain section\"\"\"\n    \"\"\" Add a generated line of SPIR-V to a given section.\n\n        Args:\n            section (titan.ast_crawl._SPIRVHelperGenerator.Sections): The section to append the line to.\n            line (str): The line to add.\n    \"\"\"\n    self.generated_spirv[section.name].append(line)\n</code></pre>"},{"location":"reference-docs/compiler/ast_crawl/#titan.ast_crawl._SPIRVHelperGenerator.add_output_symbol","title":"<code>add_output_symbol(symbol)</code>","text":"<p>Add an output symbol to the output_port_list.</p> <p>Also increments an internal counter.</p> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>The symbol to be added.</p> required Source code in <code>titan/ast_crawl.py</code> <pre><code>def add_output_symbol(self, symbol:str):\n    \"\"\" Add an output symbol to the output_port_list.\n\n        Also increments an internal counter.\n\n        Args:\n            symbol (str): The symbol to be added. \n    \"\"\"\n\n    # HACK: what is the point of this line\n    self.output_port_list[symbol] = self.output_type_list[self._internal_output_port_list_counter]\n    self._internal_output_port_list_counter += 1\n</code></pre>"},{"location":"reference-docs/compiler/ast_crawl/#titan.ast_crawl._SPIRVHelperGenerator.add_output_type","title":"<code>add_output_type(type)</code>","text":"<p>Add an output type.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <p>The type to add.</p> required Warning <p>This function may be removed in the future. It's not clear what specifically it is adding. Could possibly cause issues with the rest of the program.</p> Source code in <code>titan/ast_crawl.py</code> <pre><code>def add_output_type(self, type):\n    \"\"\" Add an output type.\n\n        Args:\n            type: The type to add.\n\n        Warning:\n            This function may be removed in the future. It's not clear _what_ specifically it is adding.\n            Could possibly cause issues with the rest of the program.\n    \"\"\"\n    self.output_type_list.append(type)\n</code></pre>"},{"location":"reference-docs/compiler/ast_crawl/#titan.ast_crawl._SPIRVHelperGenerator.add_symbol","title":"<code>add_symbol(symbol_id, type, location)</code>","text":"<p>Add a symbol.</p> <p>The value <code>type</code> arg will be automatically converted into a valid <code>titan.common.type.DataType</code> value.</p> <p>Parameters:</p> Name Type Description Default <code>symbol_id</code> <code>str</code> <p>ID given to the symbol.</p> required <code>type</code> <p>Python type of the symbol.</p> required <code>location</code> <code>StorageType</code> <p>Given storage location for the symbol. Required for SPIR-V.</p> required TODO <p>Need to determine whether the symbol ID contains the \"%\" prefix or not.</p> Source code in <code>titan/ast_crawl.py</code> <pre><code>def add_symbol(self, symbol_id: str, type, location: titan_type.StorageType):\n    \"\"\" Add a symbol.\n\n        The value ``type`` arg will be automatically converted into a valid ``titan.common.type.DataType`` value.\n\n        Args:\n            symbol_id: ID given to the symbol.\n            type: Python type of the symbol.\n            location: Given storage location for the symbol. Required for SPIR-V.\n\n        TODO:\n            Need to determine whether the symbol ID contains the \"%\" prefix or not.\n    \"\"\"\n    self.symbol_info[symbol_id] = self.SymbolInfo(titan_type.DataType(type), location)\n</code></pre>"},{"location":"reference-docs/compiler/ast_crawl/#titan.ast_crawl._SPIRVHelperGenerator.add_symbol_if_nonexistant","title":"<code>add_symbol_if_nonexistant(symbol, type, location)</code>","text":"<p>Add a symbol, only if it does not already exist.</p> <p>Method first checks if symbol exists or not. If not, it'll generate the corresponding SPIR-V lines depending on its type and location, and increment the <code>location_id</code> counter.</p> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>Name of the symbol to add.</p> required <code>type</code> <p>Python type of the symbol.</p> required <code>location</code> <code>StorageType</code> <p>Given storage location for the symbol. Required for SPIR-V.</p> required <p>Returns:</p> Name Type Description <code>symbol_added</code> <code>bool</code> <p>True if symbol has been added, else False.</p> Source code in <code>titan/ast_crawl.py</code> <pre><code>def add_symbol_if_nonexistant(self, symbol: str, type, location: titan_type.StorageType) -&gt; bool:\n    \"\"\" Add a symbol, only if it does not already exist.\n\n        Method first checks if symbol exists or not. If not, it'll generate the corresponding SPIR-V\n        lines depending on its type and location, and increment the ``location_id`` counter.\n\n        Args:\n            symbol: Name of the symbol to add.\n            type: Python type of the symbol.\n            location: Given storage location for the symbol. Required for SPIR-V.\n\n        Returns:\n            symbol_added: True if symbol has been added, else False.\n    \"\"\"\n\n    if symbol not in self.symbol_info:\n        self.symbol_info[symbol] = self.SymbolInfo(titan_type.DataType(type), location)\n\n        self.add_line(\n            self.Sections.DEBUG_STATEMENTS,\n            f\"OpName %{symbol} \\\"{symbol}\\\"\"\n        )\n\n        # TODO: more elegant solution?\n        # if i/o\n        if location is (titan_type.StorageType.IN or titan_type.StorageType.OUT):\n            # add location (glsl specific i think)\n            self.add_line(\n                self.Sections.ANNOTATIONS,\n                f\"OpDecorate %{symbol} Location {self.location_id}\"\n            )\n\n            if location is titan_type.StorageType.IN:\n                self.add_line(\n                    self.Sections.ANNOTATIONS,\n                    # more glsl specific stuff\n                    f\"OpDecorate %{symbol} Flat\"\n                )\n\n                # input variable pointer type\n                ptr_ctx = self.TypeContext(\n                        titan_type.DataType(type), titan_type.StorageType.IN,\n                        False, True, False\n                )\n\n                ptr_id = self.add_type_if_nonexistant(\n                    ptr_ctx,\n                    f\"%pointer_input_{titan_type.DataType(type).name.lower()}\"\n                )\n\n                self.add_line(\n                    self.Sections.VAR_CONST_DECLARATIONS,\n                    f\"%{symbol} = OpVariable {ptr_id} Input\"\n                )\n            elif location is titan_type.StorageType.OUT:\n                ptr_ctx = self.TypeContext(\n                    titan_type.DataType(type), titan_type.StorageType.IN,\n                    False, True, False\n                )\n\n                ptr_id = self.add_type_if_nonexistant(\n                    ptr_ctx,\n                    f\"%pointer_output_{titan_type.DataType(type).name.lower()}\"\n                )\n\n                self.add_line(\n                    self.Sections.VAR_CONST_DECLARATIONS,\n                    f\"%{symbol} = OpVariable {ptr_id} Output\"\n                )\n        elif location is titan_type.StorageType.FUNCTION_VAR:\n\n            ptr_id = self.add_type_if_nonexistant(\n                self.TypeContext(\n                    titan_type.DataType(type), titan_type.StorageType.FUNCTION_VAR,\n                    False, True, False\n                ),\n                f\"%pointer_funcvar_{titan_type.DataType(type).name.lower()}\"\n            )\n\n            self.add_line(\n                self.Sections.FUNCTIONS,\n                f\"%{symbol} = OpVariable {ptr_id} Function\"\n            )\n\n        self.location_id += 1\n\n        return True\n    else:\n        return False\n</code></pre>"},{"location":"reference-docs/compiler/ast_crawl/#titan.ast_crawl._SPIRVHelperGenerator.add_type","title":"<code>add_type(type, id)</code>","text":"<p>Add a type, using <code>TypeContext</code>. Used to generate SPIR-V types.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>TypeContext</code> <p>Type, as <code>TypeContext</code> to add.</p> required <code>id</code> <code>str</code> <p>ID to associate with the type.</p> required Source code in <code>titan/ast_crawl.py</code> <pre><code>def add_type(self, type: TypeContext, id: str):\n    \"\"\" Add a type, using ``TypeContext``. Used to generate SPIR-V types.\n\n        Args:\n            type: Type, as ``TypeContext`` to add.\n            id: ID to associate with the type.\n    \"\"\"\n    self.declared_types[type] = id\n</code></pre>"},{"location":"reference-docs/compiler/ast_crawl/#titan.ast_crawl._SPIRVHelperGenerator.add_type_if_nonexistant","title":"<code>add_type_if_nonexistant(type, id)</code>","text":"<p>Add a type, only if it does not already exist.</p> <p>If the type does not already exist, the function will generate the corresponding SPIR-V for it.</p> Currently supported types: <ul> <li>OpTypeVoid</li> <li>OpTypeInteger (32-bit signed)</li> <li>OpTypeBool</li> <li>OpTypeFloat (32-bit float)</li> </ul> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>TypeContext</code> <p>The type to add.</p> required <code>id</code> <code>str</code> <p>The ID to associate with the type.</p> required <p>Returns:</p> Name Type Description <code>type_id</code> <code>str</code> <p>The ID of the type.</p> Source code in <code>titan/ast_crawl.py</code> <pre><code>def add_type_if_nonexistant(self, type: TypeContext, id: str) -&gt; str:\n    \"\"\" Add a type, only if it does not already exist.\n\n        If the type does not already exist, the function will generate the corresponding SPIR-V for it.\n\n        Note: Currently supported types:\n            - OpTypeVoid\n            - OpTypeInteger (32-bit signed)\n            - OpTypeBool\n            - OpTypeFloat (32-bit float)\n\n        Args:\n            type: The type to add.\n            id: The ID to associate with the type.\n\n        Returns:\n            type_id: The ID of the type.\n    \"\"\"\n    if not self.type_exists(type):\n\n        # TODO: remove\n        self.add_type(type, id)\n\n        spirv_txt = f\"{id} = \"\n\n        if type.is_function_typedef:\n            prim_tid = self.get_primative_type_id(type.primative_type)\n            spirv_txt += f\"OpTypeFunction {prim_tid}\"\n        elif type.is_pointer:\n            prim_tid = self.get_primative_type_id(type.primative_type)\n            storage_type = \"\"\n\n            match type.storage_type:\n                case titan_type.StorageType.IN:\n                    storage_type = \"Input\"\n                case titan_type.StorageType.OUT:\n                    storage_type = \"Output\"\n                case titan_type.StorageType.FUNCTION_VAR:\n                    storage_type = \"Function\"\n                case _:\n                    logging.exception(f\"no text for storage type for {type.storage_type}\", exc_info=False)\n                    raise Exception(f\"no text for storage type for {type.storage_type}\")\n\n            spirv_txt += f\"OpTypePointer {storage_type} {prim_tid}\"\n\n        # this should mean we're working with the primative types\n        elif (not type.is_constant) and (not type.is_pointer) and (not type.is_function_typedef):\n\n            match type.primative_type:\n                case titan_type.DataType.VOID:\n                    spirv_txt += f\"OpTypeVoid\"\n                case titan_type.DataType.INTEGER:\n                    spirv_txt += f\"OpTypeInt 32 1\"\n                case titan_type.DataType.BOOLEAN:\n                    spirv_txt += f\"OpTypeBool\"\n                case titan_type.DataType.FLOAT:\n                    spirv_txt += f\"OpTypeFloat 32\"\n                case _:\n                    logging.exception(f\"type text for {type} not implemented yet (did you wrap the type in a DataType() call to enum?)\", exc_info=False)\n                    raise Exception(f\"type text for {type} not implemented yet (did you wrap the type in a DataType() call to enum?)\")\n        else:\n            logging.exception(f\"unable to generate spirv text for type {id} -&gt; {type}\", exc_info=False)\n            raise Exception(f\"unable to generate spirv text for type {id} -&gt; {type}\")\n\n        self.add_line(\n            self.Sections.TYPES,\n            spirv_txt\n        )\n\n        return id\n    else:\n        return self.get_type_id(type)\n</code></pre>"},{"location":"reference-docs/compiler/ast_crawl/#titan.ast_crawl._SPIRVHelperGenerator.const_exists","title":"<code>const_exists(const)</code>","text":"<p>Check if a constant exists.</p> <p>Parameters:</p> Name Type Description Default <code>const</code> <code>ConstContext</code> <p>Constant to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if constant exists, else False.</p> Source code in <code>titan/ast_crawl.py</code> <pre><code>def const_exists(self, const: ConstContext) -&gt; bool:\n    \"\"\" Check if a constant exists.\n\n        Args:\n            const: Constant to check.\n\n        Returns:\n            True if constant exists, else False.\n    \"\"\"\n    return True if const in self.declared_constants else False\n</code></pre>"},{"location":"reference-docs/compiler/ast_crawl/#titan.ast_crawl._SPIRVHelperGenerator.dump","title":"<code>dump()</code>","text":"<p>Output debug info if debug flag has been set. Uses the logging library.</p> Source code in <code>titan/ast_crawl.py</code> <pre><code>def dump(self):\n    \"\"\"Output debug info if debug flag has been set. Uses the logging library.\"\"\"\n    if not self._disable_debug:\n\n        logging.debug(f\"[debug info _SPIRVHelperGenerator]\")\n        logging.debug(f\"entry point: {self.entry_point}\")\n        logging.debug(f\"input port list: {self.input_port_list}\")\n        logging.debug(f\"output port list: {self.output_port_list}\")\n        logging.debug(f\"output type list: {self.output_type_list}\")\n\n        logging.debug(f\"symbols with info:\")\n        for id, info in self.symbol_info.items():\n            logging.debug(f\"\\t{id} -&gt; {info}\")\n\n        logging.debug(f\"declared constants:\")\n        for info, id in self.declared_constants.items():\n            logging.debug(f\"\\t{id} -&gt; {info}\")\n\n\n        logging.debug(f\"declared types:\")\n        for info, id in self.declared_types.items():\n            logging.debug(f\"\\t{id} -&gt; {info}\")\n\n        logging.debug(f\"intermediate line id &amp; type:\")\n        for id, type in self.intermediate_ids.items():\n            logging.debug(f\"\\t{id} -&gt; {type}\")\n\n        logging.debug(f\"generated spirv:\")\n        for section in self.generated_spirv.keys():\n            logging.debug(f\"section: {section}\")\n\n            for value in self.generated_spirv[section]:\n                logging.debug(f\"\\t{value}\")\n</code></pre>"},{"location":"reference-docs/compiler/ast_crawl/#titan.ast_crawl._SPIRVHelperGenerator.get_const_id","title":"<code>get_const_id(value, type)</code>","text":"<p>Get the ID of a constant.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <p>A constant value.</p> required <code>type</code> <p>The type of the constant value.</p> required <p>Returns:</p> Type Description <code>str</code> <p>ID of the constant.</p> Source code in <code>titan/ast_crawl.py</code> <pre><code>def get_const_id(self, value, type) -&gt; str:\n    \"\"\" Get the ID of a constant.\n\n        Args:\n            value: A constant value.\n            type: The type of the constant value.\n\n        Returns:\n            ID of the constant.\n    \"\"\"\n    temp_c_ctx = self.ConstContext(type, value)\n    return self.declared_constants[temp_c_ctx]\n</code></pre>"},{"location":"reference-docs/compiler/ast_crawl/#titan.ast_crawl._SPIRVHelperGenerator.get_const_id_with_ctx","title":"<code>get_const_id_with_ctx(context)</code>","text":"<p>Get the ID of a constant, using <code>ConstContext</code>.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>ConstContext</code> <p>Context of the constant.</p> required <p>Returns:</p> Type Description <code>str</code> <p>ID of the constant.</p> Source code in <code>titan/ast_crawl.py</code> <pre><code>def get_const_id_with_ctx(self, context: ConstContext) -&gt; str:\n    \"\"\" Get the ID of a constant, using ``ConstContext``.\n\n        Args:\n            context: Context of the constant.\n\n        Returns:\n            ID of the constant.\n    \"\"\"\n    return self.declared_constants[context]\n</code></pre>"},{"location":"reference-docs/compiler/ast_crawl/#titan.ast_crawl._SPIRVHelperGenerator.get_primative_type_id","title":"<code>get_primative_type_id(type)</code>","text":"<p>Get the ID of a primative type.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>DataType</code> <p>Primative type to get ID for.</p> required Return <p>ID of the type.</p> Source code in <code>titan/ast_crawl.py</code> <pre><code>def get_primative_type_id(self, type: titan_type.DataType) -&gt; str:\n    \"\"\" Get the ID of a primative type.\n\n        Args:\n            type: Primative type to get ID for.\n\n        Return:\n            ID of the type.\n    \"\"\"\n\n    # TODO: convoluted? may be a better way to do this\n    # can this just be replaced with indexing with the primative type instead of going through TypeContext?\n    return self.declared_types[\n        self.TypeContext(titan_type.DataType(type))\n    ]\n</code></pre>"},{"location":"reference-docs/compiler/ast_crawl/#titan.ast_crawl._SPIRVHelperGenerator.get_symbol_info","title":"<code>get_symbol_info(symbol_id)</code>","text":"<p>Get information regarding a given symbol via ID.</p> <p>Parameters:</p> Name Type Description Default <code>symbol_id</code> <code>str</code> <p>ID of the symbol to check.</p> required <p>Returns:</p> Type Description <code>SymbolInfo</code> <p>Symbol information tuple.</p> Source code in <code>titan/ast_crawl.py</code> <pre><code>def get_symbol_info(self, symbol_id: str) -&gt; SymbolInfo:\n    \"\"\" Get information regarding a given symbol via ID.\n\n        Args:\n            symbol_id: ID of the symbol to check.\n\n        Returns:\n            Symbol information tuple.\n    \"\"\"\n    return self.symbol_info[symbol_id]\n</code></pre>"},{"location":"reference-docs/compiler/ast_crawl/#titan.ast_crawl._SPIRVHelperGenerator.get_symbol_type","title":"<code>get_symbol_type(symbol)</code>","text":"<p>Get symbol type, using symbol ID.</p> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>Symbol ID</p> required <p>Returns:</p> Type Description <code>DataType</code> <p>Primative type of symbol.</p> Source code in <code>titan/ast_crawl.py</code> <pre><code>def get_symbol_type(self, symbol:str) -&gt; titan_type.DataType:\n    \"\"\" Get symbol type, using symbol ID.\n\n        Args:\n            symbol: Symbol ID\n\n        Returns:\n            Primative type of symbol.\n    \"\"\"\n\n    # symbol_info[symbol] -&gt; info (SymbolInfo).type\n    return self.symbol_info[symbol].type\n</code></pre>"},{"location":"reference-docs/compiler/ast_crawl/#titan.ast_crawl._SPIRVHelperGenerator.get_type_id","title":"<code>get_type_id(type)</code>","text":"<p>Get the ID of a given type.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>TypeContext</code> <p>Type to get ID for.</p> required <p>Returns:</p> Type Description <code>str</code> <p>ID of the type.</p> Source code in <code>titan/ast_crawl.py</code> <pre><code>def get_type_id(self, type: TypeContext) -&gt; str:\n    \"\"\" Get the ID of a given type.\n\n        Args:\n            type: Type to get ID for.\n\n        Returns:\n            ID of the type.\n    \"\"\"\n    # FIXME: the type hint declared for this attribute does not use TypeContext as the key.\n    #        declared_type_hint suggests to use common.type.DataType as the key!\n    return self.declared_types[type]\n</code></pre>"},{"location":"reference-docs/compiler/ast_crawl/#titan.ast_crawl._SPIRVHelperGenerator.get_type_of_intermediate_id","title":"<code>get_type_of_intermediate_id(intermediate_id)</code>","text":"<p>Returns the type of an intermediate ID, not the type ID.</p> <p>Parameters:</p> Name Type Description Default <code>intermediate_id</code> <code>str</code> <p>Intermediate ID to return the type of.</p> required <p>Returns:</p> Type Description <code>DataType</code> <p>Primative intermediate ID type.</p> Source code in <code>titan/ast_crawl.py</code> <pre><code>def get_type_of_intermediate_id(self, intermediate_id: str) -&gt; titan_type.DataType:\n    \"\"\" Returns the type of an intermediate ID, _not_ the type ID.\n\n        Args:\n            intermediate_id: Intermediate ID to return the type of.\n\n        Returns:\n            Primative intermediate ID type.\n    \"\"\"\n    return self.intermediate_ids[intermediate_id]\n</code></pre>"},{"location":"reference-docs/compiler/ast_crawl/#titan.ast_crawl._SPIRVHelperGenerator.intermediate_id_exists","title":"<code>intermediate_id_exists(intermediate_id)</code>","text":"<p>Check if an intermediate ID already exists.</p> <p>Parameters:</p> Name Type Description Default <code>intermediate_id</code> <code>str</code> <p>Intermediate ID to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if intermediate ID already exists, else False.</p> Source code in <code>titan/ast_crawl.py</code> <pre><code>def intermediate_id_exists(self, intermediate_id: str) -&gt; bool:\n    \"\"\" Check if an intermediate ID already exists.\n\n        Args:\n            intermediate_id: Intermediate ID to check.\n\n        Returns:\n            True if intermediate ID already exists, else False.\n    \"\"\"\n    return True if intermediate_id in self.intermediate_ids else False\n</code></pre>"},{"location":"reference-docs/compiler/ast_crawl/#titan.ast_crawl._SPIRVHelperGenerator.symbol_exists","title":"<code>symbol_exists(symbol)</code>","text":"<p>Check if a symbol exists.</p> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>Given symbol name, with the SPIR-V \"%\" prefix.</p> required <p>Returns:</p> Name Type Description <code>symbol_exists</code> <code>bool</code> <p>True if symbol exists, else False.</p> Source code in <code>titan/ast_crawl.py</code> <pre><code>def symbol_exists(self, symbol: str) -&gt; bool:\n    \"\"\" Check if a symbol exists.\n\n        Args:\n            symbol (str): Given symbol name, with the SPIR-V \"%\" prefix.\n\n        Returns:\n            symbol_exists: True if symbol exists, else False.\n    \"\"\"\n\n    return True if symbol in self.symbol_info else False\n</code></pre>"},{"location":"reference-docs/compiler/ast_crawl/#titan.ast_crawl._SPIRVHelperGenerator.type_exists","title":"<code>type_exists(type)</code>","text":"<p>Check if a type already exists, using a <code>TypeContext</code>.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>TypeContext</code> <p>Type to check if it exists.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if type exists, else False.</p> Source code in <code>titan/ast_crawl.py</code> <pre><code>def type_exists(self, type: TypeContext) -&gt; bool:\n    \"\"\" Check if a type already exists, using a ``TypeContext``.\n\n        Args:\n            type: Type to check if it exists.\n\n        Returns:\n            True if type exists, else False.\n    \"\"\"\n    return True if type in self.declared_types else False\n</code></pre>"},{"location":"reference-docs/compiler/ast_crawl/#titan.ast_crawl._SPIRVHelperGenerator.update_symbol_info","title":"<code>update_symbol_info(symbol_id, info)</code>","text":"<p>Update the information currently stored of a given symbol.</p> Warning <p>Simply overwrites an existing entry. The symbol must have be declared before using this, otherwise you may run into a KeyError exception.</p> <p>Parameters:</p> Name Type Description Default <code>symbol_id</code> <code>str</code> <p>ID of the symbol to update.</p> required <code>info</code> <code>SymbolInfo</code> <p>Tuple to update the information with.</p> required Source code in <code>titan/ast_crawl.py</code> <pre><code>def update_symbol_info(self, symbol_id:str, info: SymbolInfo):\n    \"\"\" Update the information currently stored of a given symbol.\n\n        Warning:\n            Simply overwrites an existing entry. The symbol _must_ have be declared before using this,\n            otherwise you may run into a KeyError exception.\n\n        Args:\n            symbol_id: ID of the symbol to update.\n            info: Tuple to update the information with.\n    \"\"\"\n    self.symbol_info[symbol_id] = info\n</code></pre>"},{"location":"reference-docs/compiler/ast_crawl/#titan.ast_crawl.GenerateSPIRVFromAST","title":"<code>titan.ast_crawl.GenerateSPIRVFromAST</code>","text":"<p>             Bases: <code>NodeVisitor</code></p> <p>Class responsible for generating the SPIR-V assembly, using Python's AST module.</p> Source code in <code>titan/ast_crawl.py</code> <pre><code>class GenerateSPIRVFromAST(ast.NodeVisitor):\n    \"\"\" Class responsible for generating the SPIR-V assembly, using Python's AST module.\"\"\"\n\n    def __init__(self, file):\n        \"\"\" Init function for GenerateSPIRVFromAST.\n\n            Args:\n                file: Python source file to transpile.\n\n            Attributes:\n                _target_file: Stores the ``file`` parameter. (Should probably be removed.)\n                _tree: Stores the AST generated by the AST library whilst parsing the source file.\n                spirv_helper: An instance of ``_SPIRVHelperGenerator``.\n        \"\"\"\n        self._target_file = file\n        self._tree = ast.parse(open(file, \"r\").read())\n\n        self.spirv_helper = _SPIRVHelperGenerator(disable_debug=False)\n\n    def crawl(self):\n        \"\"\" Method reponsible for starting the compilation.\n\n            Begins visiting each node and calls corresponding functions to generate SPIR-V assembly.\n        \"\"\"\n        # wrapper function for visiting the top of the tree\n        self.visit(self._tree)\n        self.spirv_helper.dump()\n\n    # TODO: probably inefficient\n    def create_file_as_string(self) -&gt; str:\n        \"\"\" Transforms the generated SPIR-V assembly from lists into a very long string.\n\n            TODO:\n                Rework this function. Must be a better way to do this.\n\n            Returns:\n                String containing all of the generated SPIR-V assembly code.\n        \"\"\"\n        fake_file = \"\"\n\n        # key=section, value=list of lines\n        for lines in self.spirv_helper.generated_spirv.values():\n            for line in lines:\n                fake_file += f\"{line}\\n\"\n\n        return fake_file\n\n    def output_to_file(self, filename:str):\n        \"\"\" Write generated SPIR-V assembly into a real file.\n\n            Args:\n                filename: Name of the file to write to. ``.spvasm`` will be automatically appended.\n        \"\"\"\n        ff = self.create_file_as_string()\n\n        with open(f\"{filename}.spvasm\", \"w\") as f:\n            for line in ff:\n                f.write(line)\n\n    def _get_python_type_from_string(self, type: str):\n        \"\"\" Returns the Python type by extracting the string from the type, and evaluating it.\n\n            Warning:\n                This is probably bad, and should be replaced when possible.\n\n            Args:\n                type: Python type as a string, i.e. \"&lt;class 'int'&gt;\"\n\n            Returns:\n                Type as an object.\n        \"\"\"\n        # returns python type from &lt;class 'x'&gt; string\n        return eval(type.split(\"'\")[0])\n\n    # TODO: can these be turned into enums instead?\n    def _return_string_from_type(self, type) -&gt; str:\n        \"\"\" Returns a string depending on the type() of a variable. \n\n            Works on int, float and bool. \n\n            Warning:\n                Should be replaced when possible.\n\n            Args:\n                type: Returned value of ``type()``.\n\n            Returns:\n                Type as a string.\n\n            Raises:\n                Exception: Unknown type.\n        \"\"\"\n\n        if (type is int):\n            return \"int\"\n        elif (type is float):\n            return \"float\"\n        elif (type is bool):\n            return \"bool\"\n        else:\n            logging.exception(f\"unexpected type {type}\", exc_info=False)\n            raise Exception(f\"unexpected type {type}\")\n\n    def _return_type_from_string(self, type_as_string: str):\n        \"\"\" Returns the type object when given a string.\n\n            Args:\n                type_as_string: Type, given as a string.\n\n            Returns:\n                Type, as an object.\n\n            Raises:\n                Exception: Unknown string.\n        \"\"\"\n        \"\"\"returns a type class depending on the recieved string\n\n        works on int, float and bool, otherwise raises an exception\n        \"\"\"\n        if type_as_string == \"int\":\n            return int\n        elif type_as_string == \"float\":\n            return float\n        elif type_as_string == \"bool\":\n            return bool\n        else:\n            logging.exception(f\"unexpected type as string {type_as_string}\", exc_info=False)\n            raise Exception(f\"unexpected type as string {type_as_string}\")\n\n\n\n\n    # ---------- start of AST functions ----------\n    # see: https://docs.python.org/3/library/ast.html\n\n    def visit_Module(self, node):\n        \"\"\" Function called when visiting a module.\n\n            Method first sets the entry point to the name of the function inside the module. If there are multiple,\n            the name can either be specified via a command line option, or if present, a function named \"step\" will\n            be the entry point. If there is only one function, then it will be used instead, regardless of the name.\n\n            Some initial boilerplate SPIR-V code is added at this stage.\n\n            After that the method will visit all of the functions in the body, generating the equivalent SPIR-V assembly.\n            The ports (I/O or parameters/returns) are handled after the function visits.\n\n            Args:\n                node: The current node.\n\n            Attributes:\n                _module_contains_step_function (bool): A check if the module contains a function specifically called \"step\".\n\n        \"\"\"\n        _module_contains_step_function = False\n\n        logging.debug(f\"found {len(node.body)} functions\")\n\n        for i in range(len(node.body)):\n            if node.body[i].name == \"step\":\n                _module_contains_step_function = True\n\n        if _module_contains_step_function:\n            self.spirv_helper.entry_point = \"step\"\n        else:\n            # TODO: better to error or assume?\n            self.spirv_helper.entry_point = node.body[0].name\n\n        # spirv boilerplate\n        self.spirv_helper.add_line(\n            self.spirv_helper.Sections.CAPABILITY_AND_EXTENSION,\n            f\"OpCapability Shader\"\n        )\n\n        self.spirv_helper.add_line(\n            self.spirv_helper.Sections.CAPABILITY_AND_EXTENSION,\n            f\"OpMemoryModel Logical GLSL450\"\n        )\n\n        for fn in node.body:\n            # print(f\"function: {fn.name} returns {fn.returns.id}\")\n            self.visit_FunctionDef(fn)\n\n            # if the function is our entry point, we want to capture its params\n            # TODO: this will fail if the entry point is not the first function in the list,\n            #       since the lists/dicts will contain previous function entries, messing with the names\n            if fn.name == self.spirv_helper.entry_point:\n                # take contents of input/output ports and convert them into ids\n                ports_str = \"\"\n\n                for symbol, s_ctx in self.spirv_helper.symbol_info.items():\n                    # print(s_ctx.location)\n                    if (s_ctx.location is titan_type.StorageType.IN) or (s_ctx.location is titan_type.StorageType.OUT):\n                        ports_str += f\"%{symbol} \"\n\n                self.spirv_helper.add_line(\n                    self.spirv_helper.Sections.ENTRY_AND_EXEC_MODES,\n                    f\"OpEntryPoint Fragment %{fn.name} \\\"{fn.name}\\\" {ports_str}\"\n                )\n\n            self.spirv_helper.add_line(\n                self.spirv_helper.Sections.ENTRY_AND_EXEC_MODES,\n                f\"OpExecutionMode %{fn.name} OriginUpperLeft\"\n            )\n\n            logging.debug(f\"exit function {fn.name}\")\n\n\n\n    def visit_FunctionDef(self, node):\n        \"\"\" Function called when visiting a function definition.\n\n            Method evaluates function signature, generates appropriate SPIR-V types and visits the body nodes.\n\n            Args:\n                node: The current node.\n\n        \"\"\"\n        logging.debug(f\"function {node.name} returns type {node.returns.id} -- {node._fields}\")\n        self.spirv_helper._latest_function_name = node.name\n\n\n        self.spirv_helper.add_line(\n            self.spirv_helper.Sections.DEBUG_STATEMENTS,\n            f\"OpName %{node.name} \\\"{node.name}\\\"\"\n        )\n\n        # TODO: how to make so this only needs to run once? (low priority)\n        void_ctx = self.spirv_helper.TypeContext(\n            titan_type.DataType.VOID, titan_type.StorageType.NONE\n        )\n\n        t_void_id = self.spirv_helper.add_type_if_nonexistant(\n            void_ctx,\n            f\"%type_void\"\n        )\n\n        # make spirv function def for OpTypeFunction\n        fn_ctx = self.spirv_helper.TypeContext(\n            titan_type.DataType.VOID, titan_type.StorageType.NONE, False, False, True\n        )\n\n        t_fn_void_id = self.spirv_helper.add_type_if_nonexistant(\n            fn_ctx,\n            f\"%type_function_{(titan_type.DataType.VOID.name).lower()}\"\n        )\n\n        # mark start of function\n        self.spirv_helper.add_line(\n            self.spirv_helper.Sections.FUNCTIONS,\n            f\"%{node.name} = OpFunction {t_void_id} None {t_fn_void_id}\"\n        )\n\n        self.spirv_helper.add_line(\n            self.spirv_helper.Sections.FUNCTIONS,\n            f\"%label_{node.name} = OpLabel\"\n        )\n\n\n        # iterate through each arg, make type &amp; pointer type\n        for args in node.args.args:\n            # TODO: remove/fix/rework this try-except block\n            # may have to use __attrs__ or something to check if args contains annotation\n            try:\n                # print(f\"arg: {args.annotation.id}\", end=\" \")\n\n                # TODO: not a fan of using \"eval\" to determine type, is there a better way?\n                type_class = eval(args.annotation.id.split(\"'\")[0])\n\n\n                # check if generic type exists\n                t_ctx = self.spirv_helper.TypeContext(\n                    titan_type.DataType(type_class), titan_type.StorageType.NONE,\n                    False, False\n                )\n\n                self.spirv_helper.add_type_if_nonexistant(\n                    t_ctx,\n                    f\"%type_{(titan_type.DataType(type_class).name).lower()}\"\n                )\n\n                # dealing with args means that a special type needs to be made\n                ptr_t_ctx = self.spirv_helper.TypeContext(\n                    titan_type.DataType(type_class), titan_type.StorageType.IN, False, True\n                )\n\n                self.spirv_helper.add_type_if_nonexistant(\n                    ptr_t_ctx,\n                    f\"%pointer_input_{(titan_type.DataType(type_class).name).lower()}\"\n                )\n\n                self.spirv_helper.add_symbol_if_nonexistant(\n                    args.arg,\n                    type_class,\n                    titan_type.StorageType.IN\n                )\n            except AttributeError:\n                # self.spirv_helper.add_input(args.arg, None)\n                self.spirv_helper.add_symbol(args.arg, None, titan_type.StorageType.IN)\n\n        # TODO: needs implementation for multiple returns\n        # handle returns (types for now)\n        if isinstance(node.returns, ast.Call):\n            logging.exception(f\"multiple returns/function calls no handled yet\", exc_info=False)\n            raise Exception(f\"multiple returns/function calls not handled yet\")\n        elif isinstance(node.returns, ast.Name):\n            type_class = self._get_python_type_from_string(node.returns.id)\n            self.spirv_helper.add_output_type(type_class)\n\n            type_as_string = titan_type.DataType(type_class).name.lower()\n\n            # add primative type if it does not exist\n            self.spirv_helper.add_type_if_nonexistant(\n                self.spirv_helper.TypeContext(\n                    titan_type.DataType(type_class)\n                ),\n                f\"%type_{type_as_string}\"\n            )\n\n            # add pointer type if it does not exist\n            self.spirv_helper.add_type_if_nonexistant(\n                self.spirv_helper.TypeContext(\n                    titan_type.DataType(type_class), titan_type.StorageType.OUT,\n                    False, True, False\n                ),\n                f\"%pointer_output_{type_as_string}\"\n            )\n\n\n\n        logging.debug(f\"body start {node.name}\")\n        super().generic_visit(node)\n        logging.debug(f\"body end {node.name}\")\n\n        # TODO: add function that lets me add lists of strings instead of having to\n        #       write this every time\n        # spirv boilerplate for end of function\n        self.spirv_helper.add_line(\n            self.spirv_helper.Sections.FUNCTIONS,\n            f\"OpReturn\"\n        )\n\n        self.spirv_helper.add_line(\n            self.spirv_helper.Sections.FUNCTIONS,\n            f\"OpFunctionEnd\"\n        )\n\n\n    def visit_Call(self, node):\n        \"\"\" Function called when performing a function call.\n\n            Warning:\n                Work in progress. Will be used to implement decorators, to enable features such as delayed inputs.\n\n            Args:\n                node: The current node.\n        \"\"\"\n        logging.debug(f\"TODO: function calls/decorators properly\")\n        logging.debug(ast.dump(node))\n\n        if isinstance(node.func, ast.Attribute):\n            # logging.debug(f\"attribute hit with name {node.func.value.id}.{node.func.attr} with args {node.args}, targeting {self.spirv_helper._latest_function_name}\")\n\n            match node.func.attr:\n                case \"lag\":\n                    logging.debug(f\"lagging decorator found\")\n\n                    if len(node.args) != 1:\n                        raise Exception(f\"unexpected amount of args, wanted 1 got {len(node.args)}\")\n\n                    decorator_args = node.args[0] # there should only be one entry, and this should be a list\n\n                    if not isinstance(decorator_args, ast.List):\n                        raise Exception(f\"expecting list for decorator, got {type(decorator_args)} instead\")\n\n                    list_of_inputs_and_lags = decorator_args.elts\n\n                    # {function_name: {\n                    #                   input1: 2,\n                    #                   input2: 5\n                    #                 }\n                    # }\n\n                    temp_dict = {}\n\n                    for element in list_of_inputs_and_lags:\n                        # still working with ast.Lists here\n                        if len(element.elts) != 2:\n                            raise Exception(f\"unexpected amount of elements, wanted 2 got {len(element.elts)}\")\n\n                        target_input = self._extract_content(element.elts[0])\n                        target_lag_depth = self._extract_content(element.elts[1])\n                        temp_dict[target_input] = target_lag_depth\n\n                    self.spirv_helper._decorator_dict[self.spirv_helper._latest_function_name] = temp_dict\n                    logging.debug(f\"lagging decorator produced: {self.spirv_helper._decorator_dict}\")\n\n                    logging.info(f\"Generating JSON (contains lagging information)...\")\n                    with open(f\"{self.spirv_helper._latest_function_name}_lagging_info.json\", \"w+\") as f:\n                        f.write(json.dumps(self.spirv_helper._decorator_dict, indent=4))\n\n\n                case \"recursive\":\n                    raise Exception(\"TODO\")\n                case _:\n                    raise Exception(\"unexpected attribute when handling a call\")\n\n\n\n    def visit_Assign(self, node):\n        \"\"\" Function called when performing an assignment.\n\n            Attempts to evaluate the assignment, by calling ``_eval_line()``.\n\n            Args:\n                node: The current node.\n        \"\"\"\n        if len(node.targets) &gt; 1:\n            logging.exception(f\"multiple assignments not supported\", exc_info=False)\n            raise Exception(\"multiple assignments not supported\")\n\n        try:\n            eval_id, eval_ctx = self._eval_line_wrap(node)\n        except Exception as e:\n            logging.exception(f\"failed to unpack evaluation, usually a sign that the operation was not handled properly... exception: {e}\")\n            raise Exception(f\"failed to unpack evaluation, usually a sign that the operation was not handled properly... exception: {e}\")\n\n        type_class = self._extract_type(eval_ctx)\n\n        if type_class is None:\n            logging.exception(f\"evaluated type as None for variable with no type declaration\", exc_info=False)\n            raise Exception(\"evaluated type as None for variable with no type declaration\")\n\n        t_id = self.spirv_helper.add_type_if_nonexistant(\n            self.spirv_helper.TypeContext(\n                titan_type.DataType(type_class)\n            ),\n            f\"%type_{titan_type.DataType(type_class).name.lower()}\"\n        )\n\n        self.spirv_helper.add_symbol_if_nonexistant(node.targets[0].id, type_class, titan_type.StorageType.FUNCTION_VAR)\n\n        self.spirv_helper.add_line(\n            self.spirv_helper.Sections.FUNCTIONS,\n            f\"OpStore %{node.targets[0].id} %{eval_id.strip('%')}\"\n        )\n\n\n    def visit_AnnAssign(self, node):\n        # print(f\"{node.annotation.id} {node.target.id} = {node.value.value}\")\n        type_class = self._get_python_type_from_string(node.annotation.id)\n\n        t_id = self.spirv_helper.add_type_if_nonexistant(\n            self.spirv_helper.TypeContext(titan_type.DataType(type_class)),\n            f\"%type_{titan_type.DataType(type_class).name.lower()}\"\n        )\n        try:\n            eval_id, eval_ctx = self._eval_line_wrap(node)\n        except Exception as e:\n            logging.exception(f\"failed to unpack evaluation, usually a sign that the operation was not handled properly... exception: {e}\")\n            raise Exception(f\"failed to unpack evaluation, usually a sign that the operation was not handled properly... exception: {e}\")\n\n\n        eval_type = self._extract_type(eval_ctx)\n\n        if eval_type != type_class:\n            logging.exception(f\"mismatched types: eval_type {eval_type} - type_class {type_class}\", exc_info=False)\n            raise Exception(f\"mismatched types: eval_type {eval_type} - type_class {type_class}\")\n\n        self.spirv_helper.add_symbol_if_nonexistant(node.target.id, type_class, titan_type.StorageType.FUNCTION_VAR)\n\n        self.spirv_helper.add_line(\n            self.spirv_helper.Sections.FUNCTIONS,\n            f\"OpStore %{node.target.id} {eval_id}\"\n        )\n\n\n\n    def visit_Return(self, node):\n        \"\"\"\n        handle return nodes\n        \"\"\"\n        # TODO: add calls to _eval_line to get proper id for node\n        if isinstance(node.value, ast.Constant):\n            logging.debug(f\"returning const: {node.value.value}\")\n            logging.exception(f\"TODO: return constant value\", exc_info=False)\n            raise Exception(\"TODO: return constant value\")\n\n        elif isinstance(node.value, ast.Name):\n            logging.debug(f\"returning name: {node.value.id}\")\n            id, ctx = self._eval_line(node.value)\n\n            if self.spirv_helper.symbol_exists(id):\n                s_info = self.spirv_helper.get_symbol_info(id)\n\n                if s_info.location == titan_type.StorageType.FUNCTION_VAR:\n                    s_info_new = self.spirv_helper.SymbolInfo(\n                        ctx, titan_type.StorageType.OUT\n                    )\n\n                    self.spirv_helper.update_symbol_info(id, s_info_new)\n\n                    ptr_t_id = self.spirv_helper.get_type_id(\n                        self.spirv_helper.TypeContext(\n                            ctx, titan_type.StorageType.FUNCTION_VAR, False, True\n                        )\n                    )\n\n                    ptr_t_out_id = self.spirv_helper.get_type_id(\n                        self.spirv_helper.TypeContext(\n                            ctx, titan_type.StorageType.OUT, False, True\n                        )\n                    )\n\n                    self.spirv_helper.add_line(\n                        self.spirv_helper.Sections.VAR_CONST_DECLARATIONS,\n                        f\"%{id} = OpVariable {ptr_t_out_id} Output\"\n                    )\n\n                    str_to_match = f\"%{id} = OpVariable {ptr_t_id} Function\"\n\n                    # TODO: implement better method\n                    # bruteforce remove reference of symbol declaration in FUNCTIONS section\n                    i = 0\n                    for line in self.spirv_helper.generated_spirv[self.spirv_helper.Sections.FUNCTIONS.name]:\n                        if line == str_to_match:\n                            self.spirv_helper.generated_spirv[self.spirv_helper.Sections.FUNCTIONS.name].pop(i)\n                            break\n                        i += 1\n\n\n        elif isinstance(node.value, ast.IfExp):\n            # print(f\"returning if expression\")\n            # print(node.value._fields)\n            # print(f\"test: {node.value.test._fields}\")\n\n            # error prone\n            # node.value.test.ops is a list! be careful and check length before doing anything\n            # print(f\"\\tleft: {node.value.test.left.id}\")\n\n            # print(\"\\tops &amp; comparators:\")\n            # for i in range(len(node.value.test.ops)):\n                # print(f\"\\t{node.value.test.ops[i].__class__.__name__} {self._extract_content(node.value.test.comparators[i])}\")\n\n            #        v node.value.body.id\n            # return c if a &gt; 0 else 0 \n            #             ^ ^        ^ node.value.orelse\n            #             | | node.value.test.{ops|comparators}\n            #             | node.value.test.left\n            # print(f\"body: {node.value.body.id} {node.value.body.ctx}\")\n\n            # print(f\"orelse: {self._extract_content(node.value.orelse)}\")\n\n            # TODO: need to get ID somehow, move the IfExp function to something else accessible and call it directly?\n            super().generic_visit(node)\n\n            # because this is direct return, we have to make a temp symbol into which we can return (in spirv terms)\n            # we have to also add it to the symbols list, making sure that it has the same type as the indicated return type\n            # and that it doesn't clash with the return type\n\n            out_str_id = f\"titan_return_id_{self.spirv_helper.return_id}\"\n            self.spirv_helper.return_id += 1\n            # TODO: make sure names don't clash?\n            self.spirv_helper.add_symbol_if_nonexistant(\n                out_str_id, self.spirv_helper.output_type_list[0], titan_type.StorageType.OUT\n            )\n\n            self.spirv_helper.add_output_symbol(out_str_id)\n\n            # store titan_id_x into the newly created return variable\n            self.spirv_helper.add_line(\n                self.spirv_helper.Sections.FUNCTIONS,\n                f\"OpStore %{out_str_id} %{self.spirv_helper._latest_ifexp_selector_id}\"\n            )\n\n            ptr_t_out_ctx = self.spirv_helper.TypeContext(\n                titan_type.DataType(self.spirv_helper.output_type_list[0]), titan_type.StorageType.OUT,\n                False, True, False\n            )\n\n            ptr_t_out_id = self.spirv_helper.get_type_id(ptr_t_out_ctx)\n\n            self.spirv_helper.add_line(\n                self.spirv_helper.Sections.VAR_CONST_DECLARATIONS,\n                f\"%{out_str_id} = OpVariable %{ptr_t_out_id.strip('%')} Output\"\n            )\n\n\n            # print(f\"return {node.value.body.id} if {node.value.test.left.id} {node.value.test.ops[0].__class__.__name__} {self._extract_content(node.value.test.comparators[0])} else {self._extract_content(node.value.orelse)}\")\n        elif isinstance(node.value, ast.BinOp):\n            logging.exception(f\"TODO implement handling binops for return values\", exc_info=False)\n            raise Exception(\"TODO implement handling binops for return values\")\n\n            id, ctx = self._eval_line(node.value)\n            print(f\"returning binop val ({id})\")\n\n            if self.spirv_helper.symbol_exists(id):\n                print(\"this was a symbol\")\n            elif self.spirv_helper.intermediate_id_exists(id):\n                print(\"this was a temp id\")\n            else:\n                raise Exception(\"idk\")\n\n        else:\n            logging.exception(f\"unhandled type during return node evaluation {node}\", exc_info=False)\n            raise Exception(f\"unhandled type during return node evaluation {node} {type(node)}\")\n\n\n    def visit_Name(self, node): pass\n\n\n    def _get_id_of_node(self, node):\n        if isinstance(node, ast.Name):\n            if self.spirv_helper.symbol_exists(node.id):\n                return node.id\n            else:\n                logging.exception(f\"symbol referenced but does not exist: {node.id}\", exc_info=False)\n                raise Exception(f\"symbol referenced but does not exist: {node.id}\")\n        elif isinstance(node, ast.Constant):\n\n            c_ctx = self.spirv_helper.ConstContext(titan_type.DataType(type(node.value)), node.value)\n            if self.spirv_helper.const_exists(c_ctx):\n                return self.spirv_helper.get_const_id_with_ctx(c_ctx)\n            else:\n                # TODO: does not account for negative numbers, probably need an UnaryOp section \n                c_id = self.spirv_helper.add_const_if_nonexistant(\n                    c_ctx, False\n                )\n                return c_id\n            # return self.spirv_helper.get_const_id(node.value, titan_type.DataType(type(node.value)))\n        else:\n            logging.exception(f\"unhandled node {node}\", exc_info=False)\n            raise Exception(f\"unhandled node {node} {type(node)}\")\n\n    def visit_IfExp(self, node):\n        logging.debug(f\"[visit_IfExp] {node} {node._fields}\")\n\n\n        # this should take care of the comparison node\n        # --- only if IfExp is visited by this function, and not _eval_line\n        super().generic_visit(node)\n\n        # TODO: probably should check if both types match, but as a hack we check only the left one and pray\n        t_id = self.spirv_helper.get_primative_type_id(self.spirv_helper.get_symbol_type(node.test.left.id))\n\n        body_id = self._get_id_of_node(node.body)\n        orelse_id = self._get_id_of_node(node.orelse)\n\n        self.spirv_helper.add_line(\n            self.spirv_helper.Sections.FUNCTIONS,\n            #TODO:                                                                  vvv should this just be always -1 of the current id?\n            f\"%titan_id_{self.spirv_helper.intermediate_id} = OpSelect {t_id} {self.spirv_helper._latest_compare_id} %{body_id} %{orelse_id}\"\n        )\n\n        # add id, set it as latest, increment by 1\n        self.spirv_helper.add_intermediate_id(f\"titan_id_{self.spirv_helper.intermediate_id}\", bool)\n        self.spirv_helper._latest_ifexp_selector_id = f\"titan_id_{self.spirv_helper.intermediate_id}\"\n        self.spirv_helper.intermediate_id += 1\n\n\n\n\n    # comparison only, do not need to worry about the \"orelse\" value\n    def visit_Compare(self, node):\n        # also fails to do a &gt; b -- \"failed to unpack evaluation, unhandled instance when checking Name object\"\n\n        if len(node.ops) &gt; 1:\n            # TODO: will probably need recursive function to evaluate all comparisons?\n            logging.exception(f\"TODO: cannot handle multiple comparisons yet\", exc_info=False)\n            raise Exception(\"TODO: cannot handle multiple comparisons yet\")\n\n        t_id = self.spirv_helper.add_type_if_nonexistant(\n            self.spirv_helper.TypeContext(\n                titan_type.DataType.BOOLEAN\n            ),\n            f\"%type_{titan_type.DataType.BOOLEAN.name.lower()}\"\n        )\n\n        # left_id = None\n        # right_id = None\n        # opcode = None\n\n        # fails to do 1 &gt; b -- \"constant object has no attribute id\"\n        # TODO: needs typechecking to determine correct type of node\n        # target_type = self.spirv_helper.get_symbol_type(node.left.id) # this will need to be changed to whatever object the left operand is\n\n        eval_left_id, left_ctx = self._eval_line(node.left)\n        eval_right_id, right_ctx = self._eval_line(node.comparators[0])\n\n        left_type = self._extract_type(left_ctx)\n        right_type = self._extract_type(right_ctx)\n\n\n        # big chance that this will have to get changed since it may cause issues if you're not super specific with types\n        if left_type is not right_type:\n            logging.exception(f\"{errors.TitanErrors.TYPE_MISMATCH.value}, L: {left_type} R: {right_type} ({errors.TitanErrors.TYPE_MISMATCH.name})\")\n            raise Exception(f\"{errors.TitanErrors.TYPE_MISMATCH.value}, L: {left_type} R: {right_type} ({errors.TitanErrors.TYPE_MISMATCH.name})\")\n        else:\n            target_type = left_type\n            target_type_id = self.spirv_helper.get_primative_type_id(target_type)\n\n\n        # handle left node\n        if isinstance(node.left, ast.Name):\n            # if name, that means symbol, so we have to load it\n            load_str = f\"temp_{node.left.id}\"\n            self.spirv_helper.add_line(\n                self.spirv_helper.Sections.FUNCTIONS,\n                f\"%{load_str} = OpLoad {target_type_id} %{node.left.id}\"\n            )\n            eval_left_id = load_str # use updated id\n\n        elif isinstance(node.left, ast.Constant):\n            # possibly do nothing, or simply set variables? although we already have info from _eval_line\n            pass\n        else:\n            logging.exception(f\"possibly unhandled left node when evaluating comparison: {node.left} {type(node.left)}\")\n            raise Exception(f\"possibly unhandled left node when evaluating comparison: {node.left} {type(node.left)}\")\n\n\n        # handle comparators\n        # - at the moment this can only handle 1 comparator, so dont do nesting\n        # - might need some recursive function to handle various depths of comparisons i.e. for each comparison, call _eval_line?\n        if isinstance(node.comparators[0], ast.Name):\n            load_str = f\"temp_{node.comparators[0].id}\"\n            self.spirv_helper.add_line(\n                self.spirv_helper.Sections.FUNCTIONS,\n                f\"%{load_str} = OpLoad {target_type_id} %{node.comparators[0].id}\"\n            )\n            eval_right_id = load_str\n\n        # node.ops contains a list of operators (as ast.LtE, ast.Gt etc etc), we take the zeroth one since atm we can only do 1 comparison\n        opcode = self.__return_correct_opcode(target_type, node.ops[0])\n\n        self.spirv_helper.add_intermediate_id(f\"titan_id_{self.spirv_helper.intermediate_id}\", target_type)\n        self.spirv_helper.add_line(\n            self.spirv_helper.Sections.FUNCTIONS,\n            f\"%titan_id_{self.spirv_helper.intermediate_id} = {opcode} {t_id} %{eval_left_id.strip('%')} %{eval_right_id.strip('%')}\"\n        )\n\n        self.spirv_helper._latest_compare_id = f\"%titan_id_{self.spirv_helper.intermediate_id}\"\n        self.spirv_helper.intermediate_id += 1\n\n    # TODO: figure out exactly what info is needed from here, if any\n    def visit_arguments(self, node): pass\n\n    def visit_Constant(self, node): pass\n\n    def generic_visit(self, node):\n        logging.debug(f\"generic visit {node.__class__.__name__} {node._fields}\")\n\n    def _extract_content(self, node):\n        \"\"\"\n        returns value if node is ast.Constant, id if node is ast.Name\n        \"\"\"\n\n        if isinstance(node, ast.Constant):\n            return node.value\n        elif isinstance(node, ast.Name):\n            return node.id\n        else:\n            logging.exception(f\"idk what to do for {type(node)}\", exc_info=False)\n            raise Exception(f\"idk what to do for {type(node)}\")\n\n\n    def _extract_type(self, context):\n        \"\"\"\n        attempts to extract the primative type from a given context\n\n        - handles TypeContext, ConstContext, DataType, bool and int\n        \"\"\"\n        if isinstance(context, self.spirv_helper.TypeContext):\n            return context.primative_type\n        elif isinstance(context, self.spirv_helper.ConstContext):\n            return context.primative_type\n        elif isinstance(context, titan_type.DataType):\n            return context.value\n        elif context is bool or int:\n            return context\n        else:\n            logging.exception(f\"unable to extract type from context - {context} {type(context)}\", exc_info=False)\n            raise Exception(f\"unable to extract type from context - {context} {type(context)}\")\n\n    def __return_correct_opcode(self, chosen_type, operation):\n        logging.debug(f\"determining opcode for {operation} (type: {chosen_type})\")\n\n        opcode_dict = {\n            (ast.Add, int) : \"OpIAdd\",\n            (ast.Sub, int) : \"OpISub\",\n            (ast.Mult, int) : \"OpIMul\",\n            (ast.Div, int) : \"OpSDiv\",\n            (ast.LShift, int) : \"OpShiftLeftLogical\",\n            (ast.RShift, int) : \"OpShiftRightLogical\",\n            (ast.Eq, int) : \"OpIEqual\",\n            (ast.NotEq, int) : \"OpINotEqual\",\n            (ast.Lt, int) : \"OpSLessThan\",\n            (ast.LtE, int) : \"OpSLessThanEqual\",\n            (ast.Gt, int) : \"OpSGreaterThan\",\n            (ast.GtE, int) : \"OpSGreaterThanEqual\",\n\n            (ast.Add, float) : \"OpFAdd\",\n            (ast.Sub, float) : \"OpFSub\",\n            (ast.Div, float) : \"OpFDiv\",\n            (ast.Mult, float) : \"OpFMult\",\n            (ast.Eq, float) : \"OpFOrdEqual\",\n            (ast.NotEq, float) : \"OpFOrdNotEqual\",\n            (ast.Lt, float) : \"OpFOrdLessThan\",\n            (ast.LtE, float) : \"OpFOrdLessThanEqual\",\n            (ast.Gt, float) : \"OpFOrdGreaterThan\",\n            (ast.GtE, float) : \"OpFOrdGreaterThanEqual\"\n        }\n\n        try:\n            # need __class__ to avoid indexing with object instance\n            return opcode_dict[(operation.__class__, chosen_type)]\n        except KeyError:\n            logging.exception(f\"unable to index opcode: ({operation.__class__}, {chosen_type})\")\n            raise\n        except Exception as e:\n            logging.exception(f\"{e}\")\n            raise\n\n    def _eval_line(self, node):\n        \"\"\"\n        recursively evaluates a line and returns the final line id and line context\n        \"\"\"\n        logging.debug(f\"evaluating node: {node.__class__}\")\n\n\n        if isinstance(node, ast.BinOp):\n\n            left_id, left_ctx = self._eval_line(node.left)\n            right_id, right_ctx = self._eval_line(node.right)\n\n            return_ctx = None\n            chosen_type = None\n            spirv_line_str = f\"titan_id_{self.spirv_helper.intermediate_id}\"\n\n            left_type = self._extract_type(left_ctx)\n            left_type_id = self.spirv_helper.get_primative_type_id(left_type)\n\n            right_type = self._extract_type(right_ctx)\n            right_type_id = self.spirv_helper.get_primative_type_id(right_type)\n\n            # print(f\"L: {left_id} HAS TYPE {left_type} (id: {left_type_id}) ({left_ctx} {type(left_ctx)})\")\n            # print(f\"R: {right_id} HAS TYPE {right_type} (id: {right_type_id}) ({right_ctx} {type(right_ctx)})\")\n\n            # print(f\"{node.op.__class__.__name__} {isinstance(node.op, ast.Add)}\")\n\n            if left_type is not right_type:\n                logging.exception(f\"mismatched types l: {left_type} r: {right_type}\", exc_info=False)\n                raise Exception(f\"mismatched types l: {left_type}  r: {right_type}\")\n\n            if left_type is None:\n                return_ctx = right_ctx\n                chosen_type = right_type\n            elif right_type is None:\n                return_ctx = left_ctx\n                chosen_type = left_type\n            elif left_type is right_type:\n                return_ctx = left_ctx\n                chosen_type = left_type\n            else:\n                logging.exception(f\"unable to determine return type (L: {left_type} , R: {right_type})\", exc_info=False)\n                raise Exception(f\"unable to determine return type (L: {left_type} , R: {right_type})\")\n\n            if self.spirv_helper.symbol_exists(left_id):\n                temp_left_id = f\"temp_{left_id}\"\n                self.spirv_helper.add_line(\n                    self.spirv_helper.Sections.FUNCTIONS,\n                    f\"%{temp_left_id} = OpLoad {left_type_id} %{left_id}\"\n                )\n\n                left_id = temp_left_id\n\n            if self.spirv_helper.symbol_exists(right_id):\n                temp_right_id = f\"temp_{right_id}\"\n                self.spirv_helper.add_line(\n                    self.spirv_helper.Sections.FUNCTIONS,\n                    f\"%{temp_right_id} = OpLoad {right_type_id} %{right_id}\"\n                )\n\n                right_id = temp_right_id\n\n            self.spirv_helper.add_intermediate_id(f\"{spirv_line_str}\", chosen_type)\n            chosen_type_id = self.spirv_helper.get_primative_type_id(titan_type.DataType(chosen_type))\n\n            # set the appropriate opcode\n            opcode = None\n            opcode = self.__return_correct_opcode(chosen_type, node.op)\n\n            if opcode is None:\n                logging.exception(f\"opcode was not updated, why? {node.op} {chosen_type} {left_id} {right_id} {left_type} {right_type}\", exc_info=False)\n                raise Exception(f\"opcode was not updated, why? {node.op} {chosen_type} {left_id} {right_id} {left_type} {right_type}\")\n\n            self.spirv_helper.add_line(\n                self.spirv_helper.Sections.FUNCTIONS,\n                f\"%{spirv_line_str} = {opcode} {chosen_type_id} %{left_id.strip('%')} %{right_id.strip('%')}\"\n            )\n\n            # TODO: check which type is not None, and propagate that back up\n            # TODO: should we change the type for a symbol?\n            self.spirv_helper.intermediate_id += 1\n            return spirv_line_str, return_ctx\n\n        elif isinstance(node, ast.UnaryOp):\n\n            if isinstance(node.op, ast.USub):\n                value = node.operand.value\n\n                if type(value) not in [int, float, bool]:\n                    logging.exception(f\"got unexpected constant value type {type(value)}\", exc_info=False)\n                    raise Exception(f\"got unexpected constant value type {type(value)}\")\n\n                c_ctx = self.spirv_helper.ConstContext(type(value), value * -1)\n\n                if not self.spirv_helper.const_exists(c_ctx):\n                    # id = f\"%const_{self._return_string_from_type(type(value))}_n{str(value).replace('.', '_')}\"\n                    id = f\"%const_{titan_type.DataType(type(value)).name.lower()}_n{str(value).replace('.', '_')}\"\n                    # self.spirv_helper.add_const(c_ctx, id)\n                    self.spirv_helper.add_const_if_nonexistant(c_ctx, True)\n                    return id, c_ctx\n                else:\n                    return self.spirv_helper.get_const_id(value*-1, type(value)), c_ctx\n\n            logging.exception(f\"unhandled additional operator in unaryop class {node.op}\", exc_info=False)\n            raise Exception(f\"unhandled additional operator in unaryop class {node.op}\")\n            # return f\"{node.op.__class__.__name__} {node.operand.value} {type(node.operand.value)} ({isinstance(node.op,ast.USub)})\"\n\n        elif isinstance(node, ast.Name):\n            if not self.spirv_helper.symbol_exists(node.id):\n                logging.exception(f\"symbol '{node.id}' does not exist\", exc_info=False)\n                raise Exception(f\"symbol '{node.id}' does not exist\")\n\n            return f\"{node.id}\", self.spirv_helper.get_symbol_type(node.id)\n\n        elif isinstance(node, ast.Constant):\n            # TODO: maybe use titan_types instead of python types?\n            c_ctx = self.spirv_helper.ConstContext(type(node.value), node.value)\n\n            if not self.spirv_helper.const_exists(c_ctx):\n                # TODO: check if type also exists?\n                # id = f\"%const_{self._return_string_from_type(type(node.value))}_{node.value}\"\n                id = f\"%const_{titan_type.DataType(type(node.value)).name.lower()}_{str(node.value).replace('.', '_')}\"\n                # self.spirv_helper.add_const(c_ctx, id)\n                self.spirv_helper.add_const_if_nonexistant(c_ctx)\n                return id, c_ctx\n            else:\n                return self.spirv_helper.get_const_id(node.value, type(node.value)), c_ctx\n\n        elif isinstance(node, ast.IfExp):\n            self.visit_IfExp(node)\n\n            # return the context of the comparison node, because that'll indicate the type\n            # whereas the the ifexp_selector would only be bool due to the comparison condition\n            ctx = self.spirv_helper.get_type_of_intermediate_id(self.spirv_helper._latest_compare_id[1:])\n            return self.spirv_helper._latest_ifexp_selector_id, ctx\n\n\n        elif isinstance(node, ast.Compare):\n            self.visit_Compare(node)\n\n            ctx = self.spirv_helper.get_type_of_intermediate_id(self.spirv_helper._latest_compare_id[1:])\n            return self.spirv_helper._latest_compare_id, ctx\n\n        else:\n            logging.exception(f\"unexpected {type(node)} to parse in eval_line, probably not implemented yet\", exc_info=False)\n            raise Exception(f\"unexpected {type(node)} to parse in eval_line, probably not implemented yet\")\n\n    def _eval_line_wrap(self, node):\n        \"\"\"\n        works on ast.Assign or ast.AnnAssign nodes\n        \"\"\"\n\n        # this will call _eval_line on various nodes, including IfExp instead of going through visit_IfExp\n        # is this going to be an issue?\n\n        if isinstance(node, ast.Assign):\n            if len(node.targets) &gt; 1:\n                logging.exception(f\"multiple assignments not supported\", exc_info=False)\n                raise Exception(\"multiple assignments not supported\")\n\n            # for target in node.targets:\n            target = node.targets[0]\n            logging.debug(f\"{target.id}\")\n\n            evaluated = self._eval_line(node.value)\n            logging.debug(f\" = {evaluated}\")\n            return evaluated\n\n        elif isinstance(node, ast.AnnAssign):\n            logging.debug(f\"{node.target.id}\")\n\n            evaluated = self._eval_line(node.value)\n            logging.debug(f\" = {evaluated}\")\n            return evaluated\n</code></pre>"},{"location":"reference-docs/compiler/ast_crawl/#titan.ast_crawl.GenerateSPIRVFromAST.__init__","title":"<code>__init__(file)</code>","text":"<p>Init function for GenerateSPIRVFromAST.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <p>Python source file to transpile.</p> required <p>Attributes:</p> Name Type Description <code>_target_file</code> <p>Stores the <code>file</code> parameter. (Should probably be removed.)</p> <code>_tree</code> <p>Stores the AST generated by the AST library whilst parsing the source file.</p> <code>spirv_helper</code> <p>An instance of <code>_SPIRVHelperGenerator</code>.</p> Source code in <code>titan/ast_crawl.py</code> <pre><code>def __init__(self, file):\n    \"\"\" Init function for GenerateSPIRVFromAST.\n\n        Args:\n            file: Python source file to transpile.\n\n        Attributes:\n            _target_file: Stores the ``file`` parameter. (Should probably be removed.)\n            _tree: Stores the AST generated by the AST library whilst parsing the source file.\n            spirv_helper: An instance of ``_SPIRVHelperGenerator``.\n    \"\"\"\n    self._target_file = file\n    self._tree = ast.parse(open(file, \"r\").read())\n\n    self.spirv_helper = _SPIRVHelperGenerator(disable_debug=False)\n</code></pre>"},{"location":"reference-docs/compiler/ast_crawl/#titan.ast_crawl.GenerateSPIRVFromAST.crawl","title":"<code>crawl()</code>","text":"<p>Method reponsible for starting the compilation.</p> <p>Begins visiting each node and calls corresponding functions to generate SPIR-V assembly.</p> Source code in <code>titan/ast_crawl.py</code> <pre><code>def crawl(self):\n    \"\"\" Method reponsible for starting the compilation.\n\n        Begins visiting each node and calls corresponding functions to generate SPIR-V assembly.\n    \"\"\"\n    # wrapper function for visiting the top of the tree\n    self.visit(self._tree)\n    self.spirv_helper.dump()\n</code></pre>"},{"location":"reference-docs/compiler/ast_crawl/#titan.ast_crawl.GenerateSPIRVFromAST.create_file_as_string","title":"<code>create_file_as_string()</code>","text":"<p>Transforms the generated SPIR-V assembly from lists into a very long string.</p> TODO <p>Rework this function. Must be a better way to do this.</p> <p>Returns:</p> Type Description <code>str</code> <p>String containing all of the generated SPIR-V assembly code.</p> Source code in <code>titan/ast_crawl.py</code> <pre><code>def create_file_as_string(self) -&gt; str:\n    \"\"\" Transforms the generated SPIR-V assembly from lists into a very long string.\n\n        TODO:\n            Rework this function. Must be a better way to do this.\n\n        Returns:\n            String containing all of the generated SPIR-V assembly code.\n    \"\"\"\n    fake_file = \"\"\n\n    # key=section, value=list of lines\n    for lines in self.spirv_helper.generated_spirv.values():\n        for line in lines:\n            fake_file += f\"{line}\\n\"\n\n    return fake_file\n</code></pre>"},{"location":"reference-docs/compiler/ast_crawl/#titan.ast_crawl.GenerateSPIRVFromAST.output_to_file","title":"<code>output_to_file(filename)</code>","text":"<p>Write generated SPIR-V assembly into a real file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Name of the file to write to. <code>.spvasm</code> will be automatically appended.</p> required Source code in <code>titan/ast_crawl.py</code> <pre><code>def output_to_file(self, filename:str):\n    \"\"\" Write generated SPIR-V assembly into a real file.\n\n        Args:\n            filename: Name of the file to write to. ``.spvasm`` will be automatically appended.\n    \"\"\"\n    ff = self.create_file_as_string()\n\n    with open(f\"{filename}.spvasm\", \"w\") as f:\n        for line in ff:\n            f.write(line)\n</code></pre>"},{"location":"reference-docs/compiler/ast_crawl/#titan.ast_crawl.GenerateSPIRVFromAST.visit_Assign","title":"<code>visit_Assign(node)</code>","text":"<p>Function called when performing an assignment.</p> <p>Attempts to evaluate the assignment, by calling <code>_eval_line()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <p>The current node.</p> required Source code in <code>titan/ast_crawl.py</code> <pre><code>def visit_Assign(self, node):\n    \"\"\" Function called when performing an assignment.\n\n        Attempts to evaluate the assignment, by calling ``_eval_line()``.\n\n        Args:\n            node: The current node.\n    \"\"\"\n    if len(node.targets) &gt; 1:\n        logging.exception(f\"multiple assignments not supported\", exc_info=False)\n        raise Exception(\"multiple assignments not supported\")\n\n    try:\n        eval_id, eval_ctx = self._eval_line_wrap(node)\n    except Exception as e:\n        logging.exception(f\"failed to unpack evaluation, usually a sign that the operation was not handled properly... exception: {e}\")\n        raise Exception(f\"failed to unpack evaluation, usually a sign that the operation was not handled properly... exception: {e}\")\n\n    type_class = self._extract_type(eval_ctx)\n\n    if type_class is None:\n        logging.exception(f\"evaluated type as None for variable with no type declaration\", exc_info=False)\n        raise Exception(\"evaluated type as None for variable with no type declaration\")\n\n    t_id = self.spirv_helper.add_type_if_nonexistant(\n        self.spirv_helper.TypeContext(\n            titan_type.DataType(type_class)\n        ),\n        f\"%type_{titan_type.DataType(type_class).name.lower()}\"\n    )\n\n    self.spirv_helper.add_symbol_if_nonexistant(node.targets[0].id, type_class, titan_type.StorageType.FUNCTION_VAR)\n\n    self.spirv_helper.add_line(\n        self.spirv_helper.Sections.FUNCTIONS,\n        f\"OpStore %{node.targets[0].id} %{eval_id.strip('%')}\"\n    )\n</code></pre>"},{"location":"reference-docs/compiler/ast_crawl/#titan.ast_crawl.GenerateSPIRVFromAST.visit_Call","title":"<code>visit_Call(node)</code>","text":"<p>Function called when performing a function call.</p> Warning <p>Work in progress. Will be used to implement decorators, to enable features such as delayed inputs.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <p>The current node.</p> required Source code in <code>titan/ast_crawl.py</code> <pre><code>def visit_Call(self, node):\n    \"\"\" Function called when performing a function call.\n\n        Warning:\n            Work in progress. Will be used to implement decorators, to enable features such as delayed inputs.\n\n        Args:\n            node: The current node.\n    \"\"\"\n    logging.debug(f\"TODO: function calls/decorators properly\")\n    logging.debug(ast.dump(node))\n\n    if isinstance(node.func, ast.Attribute):\n        # logging.debug(f\"attribute hit with name {node.func.value.id}.{node.func.attr} with args {node.args}, targeting {self.spirv_helper._latest_function_name}\")\n\n        match node.func.attr:\n            case \"lag\":\n                logging.debug(f\"lagging decorator found\")\n\n                if len(node.args) != 1:\n                    raise Exception(f\"unexpected amount of args, wanted 1 got {len(node.args)}\")\n\n                decorator_args = node.args[0] # there should only be one entry, and this should be a list\n\n                if not isinstance(decorator_args, ast.List):\n                    raise Exception(f\"expecting list for decorator, got {type(decorator_args)} instead\")\n\n                list_of_inputs_and_lags = decorator_args.elts\n\n                # {function_name: {\n                #                   input1: 2,\n                #                   input2: 5\n                #                 }\n                # }\n\n                temp_dict = {}\n\n                for element in list_of_inputs_and_lags:\n                    # still working with ast.Lists here\n                    if len(element.elts) != 2:\n                        raise Exception(f\"unexpected amount of elements, wanted 2 got {len(element.elts)}\")\n\n                    target_input = self._extract_content(element.elts[0])\n                    target_lag_depth = self._extract_content(element.elts[1])\n                    temp_dict[target_input] = target_lag_depth\n\n                self.spirv_helper._decorator_dict[self.spirv_helper._latest_function_name] = temp_dict\n                logging.debug(f\"lagging decorator produced: {self.spirv_helper._decorator_dict}\")\n\n                logging.info(f\"Generating JSON (contains lagging information)...\")\n                with open(f\"{self.spirv_helper._latest_function_name}_lagging_info.json\", \"w+\") as f:\n                    f.write(json.dumps(self.spirv_helper._decorator_dict, indent=4))\n\n\n            case \"recursive\":\n                raise Exception(\"TODO\")\n            case _:\n                raise Exception(\"unexpected attribute when handling a call\")\n</code></pre>"},{"location":"reference-docs/compiler/ast_crawl/#titan.ast_crawl.GenerateSPIRVFromAST.visit_FunctionDef","title":"<code>visit_FunctionDef(node)</code>","text":"<p>Function called when visiting a function definition.</p> <p>Method evaluates function signature, generates appropriate SPIR-V types and visits the body nodes.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <p>The current node.</p> required Source code in <code>titan/ast_crawl.py</code> <pre><code>def visit_FunctionDef(self, node):\n    \"\"\" Function called when visiting a function definition.\n\n        Method evaluates function signature, generates appropriate SPIR-V types and visits the body nodes.\n\n        Args:\n            node: The current node.\n\n    \"\"\"\n    logging.debug(f\"function {node.name} returns type {node.returns.id} -- {node._fields}\")\n    self.spirv_helper._latest_function_name = node.name\n\n\n    self.spirv_helper.add_line(\n        self.spirv_helper.Sections.DEBUG_STATEMENTS,\n        f\"OpName %{node.name} \\\"{node.name}\\\"\"\n    )\n\n    # TODO: how to make so this only needs to run once? (low priority)\n    void_ctx = self.spirv_helper.TypeContext(\n        titan_type.DataType.VOID, titan_type.StorageType.NONE\n    )\n\n    t_void_id = self.spirv_helper.add_type_if_nonexistant(\n        void_ctx,\n        f\"%type_void\"\n    )\n\n    # make spirv function def for OpTypeFunction\n    fn_ctx = self.spirv_helper.TypeContext(\n        titan_type.DataType.VOID, titan_type.StorageType.NONE, False, False, True\n    )\n\n    t_fn_void_id = self.spirv_helper.add_type_if_nonexistant(\n        fn_ctx,\n        f\"%type_function_{(titan_type.DataType.VOID.name).lower()}\"\n    )\n\n    # mark start of function\n    self.spirv_helper.add_line(\n        self.spirv_helper.Sections.FUNCTIONS,\n        f\"%{node.name} = OpFunction {t_void_id} None {t_fn_void_id}\"\n    )\n\n    self.spirv_helper.add_line(\n        self.spirv_helper.Sections.FUNCTIONS,\n        f\"%label_{node.name} = OpLabel\"\n    )\n\n\n    # iterate through each arg, make type &amp; pointer type\n    for args in node.args.args:\n        # TODO: remove/fix/rework this try-except block\n        # may have to use __attrs__ or something to check if args contains annotation\n        try:\n            # print(f\"arg: {args.annotation.id}\", end=\" \")\n\n            # TODO: not a fan of using \"eval\" to determine type, is there a better way?\n            type_class = eval(args.annotation.id.split(\"'\")[0])\n\n\n            # check if generic type exists\n            t_ctx = self.spirv_helper.TypeContext(\n                titan_type.DataType(type_class), titan_type.StorageType.NONE,\n                False, False\n            )\n\n            self.spirv_helper.add_type_if_nonexistant(\n                t_ctx,\n                f\"%type_{(titan_type.DataType(type_class).name).lower()}\"\n            )\n\n            # dealing with args means that a special type needs to be made\n            ptr_t_ctx = self.spirv_helper.TypeContext(\n                titan_type.DataType(type_class), titan_type.StorageType.IN, False, True\n            )\n\n            self.spirv_helper.add_type_if_nonexistant(\n                ptr_t_ctx,\n                f\"%pointer_input_{(titan_type.DataType(type_class).name).lower()}\"\n            )\n\n            self.spirv_helper.add_symbol_if_nonexistant(\n                args.arg,\n                type_class,\n                titan_type.StorageType.IN\n            )\n        except AttributeError:\n            # self.spirv_helper.add_input(args.arg, None)\n            self.spirv_helper.add_symbol(args.arg, None, titan_type.StorageType.IN)\n\n    # TODO: needs implementation for multiple returns\n    # handle returns (types for now)\n    if isinstance(node.returns, ast.Call):\n        logging.exception(f\"multiple returns/function calls no handled yet\", exc_info=False)\n        raise Exception(f\"multiple returns/function calls not handled yet\")\n    elif isinstance(node.returns, ast.Name):\n        type_class = self._get_python_type_from_string(node.returns.id)\n        self.spirv_helper.add_output_type(type_class)\n\n        type_as_string = titan_type.DataType(type_class).name.lower()\n\n        # add primative type if it does not exist\n        self.spirv_helper.add_type_if_nonexistant(\n            self.spirv_helper.TypeContext(\n                titan_type.DataType(type_class)\n            ),\n            f\"%type_{type_as_string}\"\n        )\n\n        # add pointer type if it does not exist\n        self.spirv_helper.add_type_if_nonexistant(\n            self.spirv_helper.TypeContext(\n                titan_type.DataType(type_class), titan_type.StorageType.OUT,\n                False, True, False\n            ),\n            f\"%pointer_output_{type_as_string}\"\n        )\n\n\n\n    logging.debug(f\"body start {node.name}\")\n    super().generic_visit(node)\n    logging.debug(f\"body end {node.name}\")\n\n    # TODO: add function that lets me add lists of strings instead of having to\n    #       write this every time\n    # spirv boilerplate for end of function\n    self.spirv_helper.add_line(\n        self.spirv_helper.Sections.FUNCTIONS,\n        f\"OpReturn\"\n    )\n\n    self.spirv_helper.add_line(\n        self.spirv_helper.Sections.FUNCTIONS,\n        f\"OpFunctionEnd\"\n    )\n</code></pre>"},{"location":"reference-docs/compiler/ast_crawl/#titan.ast_crawl.GenerateSPIRVFromAST.visit_Module","title":"<code>visit_Module(node)</code>","text":"<p>Function called when visiting a module.</p> <p>Method first sets the entry point to the name of the function inside the module. If there are multiple, the name can either be specified via a command line option, or if present, a function named \"step\" will be the entry point. If there is only one function, then it will be used instead, regardless of the name.</p> <p>Some initial boilerplate SPIR-V code is added at this stage.</p> <p>After that the method will visit all of the functions in the body, generating the equivalent SPIR-V assembly. The ports (I/O or parameters/returns) are handled after the function visits.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <p>The current node.</p> required <p>Attributes:</p> Name Type Description <code>_module_contains_step_function</code> <code>bool</code> <p>A check if the module contains a function specifically called \"step\".</p> Source code in <code>titan/ast_crawl.py</code> <pre><code>def visit_Module(self, node):\n    \"\"\" Function called when visiting a module.\n\n        Method first sets the entry point to the name of the function inside the module. If there are multiple,\n        the name can either be specified via a command line option, or if present, a function named \"step\" will\n        be the entry point. If there is only one function, then it will be used instead, regardless of the name.\n\n        Some initial boilerplate SPIR-V code is added at this stage.\n\n        After that the method will visit all of the functions in the body, generating the equivalent SPIR-V assembly.\n        The ports (I/O or parameters/returns) are handled after the function visits.\n\n        Args:\n            node: The current node.\n\n        Attributes:\n            _module_contains_step_function (bool): A check if the module contains a function specifically called \"step\".\n\n    \"\"\"\n    _module_contains_step_function = False\n\n    logging.debug(f\"found {len(node.body)} functions\")\n\n    for i in range(len(node.body)):\n        if node.body[i].name == \"step\":\n            _module_contains_step_function = True\n\n    if _module_contains_step_function:\n        self.spirv_helper.entry_point = \"step\"\n    else:\n        # TODO: better to error or assume?\n        self.spirv_helper.entry_point = node.body[0].name\n\n    # spirv boilerplate\n    self.spirv_helper.add_line(\n        self.spirv_helper.Sections.CAPABILITY_AND_EXTENSION,\n        f\"OpCapability Shader\"\n    )\n\n    self.spirv_helper.add_line(\n        self.spirv_helper.Sections.CAPABILITY_AND_EXTENSION,\n        f\"OpMemoryModel Logical GLSL450\"\n    )\n\n    for fn in node.body:\n        # print(f\"function: {fn.name} returns {fn.returns.id}\")\n        self.visit_FunctionDef(fn)\n\n        # if the function is our entry point, we want to capture its params\n        # TODO: this will fail if the entry point is not the first function in the list,\n        #       since the lists/dicts will contain previous function entries, messing with the names\n        if fn.name == self.spirv_helper.entry_point:\n            # take contents of input/output ports and convert them into ids\n            ports_str = \"\"\n\n            for symbol, s_ctx in self.spirv_helper.symbol_info.items():\n                # print(s_ctx.location)\n                if (s_ctx.location is titan_type.StorageType.IN) or (s_ctx.location is titan_type.StorageType.OUT):\n                    ports_str += f\"%{symbol} \"\n\n            self.spirv_helper.add_line(\n                self.spirv_helper.Sections.ENTRY_AND_EXEC_MODES,\n                f\"OpEntryPoint Fragment %{fn.name} \\\"{fn.name}\\\" {ports_str}\"\n            )\n\n        self.spirv_helper.add_line(\n            self.spirv_helper.Sections.ENTRY_AND_EXEC_MODES,\n            f\"OpExecutionMode %{fn.name} OriginUpperLeft\"\n        )\n\n        logging.debug(f\"exit function {fn.name}\")\n</code></pre>"},{"location":"reference-docs/compiler/ast_crawl/#titan.ast_crawl.GenerateSPIRVFromAST.visit_Return","title":"<code>visit_Return(node)</code>","text":"<p>handle return nodes</p> Source code in <code>titan/ast_crawl.py</code> <pre><code>def visit_Return(self, node):\n    \"\"\"\n    handle return nodes\n    \"\"\"\n    # TODO: add calls to _eval_line to get proper id for node\n    if isinstance(node.value, ast.Constant):\n        logging.debug(f\"returning const: {node.value.value}\")\n        logging.exception(f\"TODO: return constant value\", exc_info=False)\n        raise Exception(\"TODO: return constant value\")\n\n    elif isinstance(node.value, ast.Name):\n        logging.debug(f\"returning name: {node.value.id}\")\n        id, ctx = self._eval_line(node.value)\n\n        if self.spirv_helper.symbol_exists(id):\n            s_info = self.spirv_helper.get_symbol_info(id)\n\n            if s_info.location == titan_type.StorageType.FUNCTION_VAR:\n                s_info_new = self.spirv_helper.SymbolInfo(\n                    ctx, titan_type.StorageType.OUT\n                )\n\n                self.spirv_helper.update_symbol_info(id, s_info_new)\n\n                ptr_t_id = self.spirv_helper.get_type_id(\n                    self.spirv_helper.TypeContext(\n                        ctx, titan_type.StorageType.FUNCTION_VAR, False, True\n                    )\n                )\n\n                ptr_t_out_id = self.spirv_helper.get_type_id(\n                    self.spirv_helper.TypeContext(\n                        ctx, titan_type.StorageType.OUT, False, True\n                    )\n                )\n\n                self.spirv_helper.add_line(\n                    self.spirv_helper.Sections.VAR_CONST_DECLARATIONS,\n                    f\"%{id} = OpVariable {ptr_t_out_id} Output\"\n                )\n\n                str_to_match = f\"%{id} = OpVariable {ptr_t_id} Function\"\n\n                # TODO: implement better method\n                # bruteforce remove reference of symbol declaration in FUNCTIONS section\n                i = 0\n                for line in self.spirv_helper.generated_spirv[self.spirv_helper.Sections.FUNCTIONS.name]:\n                    if line == str_to_match:\n                        self.spirv_helper.generated_spirv[self.spirv_helper.Sections.FUNCTIONS.name].pop(i)\n                        break\n                    i += 1\n\n\n    elif isinstance(node.value, ast.IfExp):\n        # print(f\"returning if expression\")\n        # print(node.value._fields)\n        # print(f\"test: {node.value.test._fields}\")\n\n        # error prone\n        # node.value.test.ops is a list! be careful and check length before doing anything\n        # print(f\"\\tleft: {node.value.test.left.id}\")\n\n        # print(\"\\tops &amp; comparators:\")\n        # for i in range(len(node.value.test.ops)):\n            # print(f\"\\t{node.value.test.ops[i].__class__.__name__} {self._extract_content(node.value.test.comparators[i])}\")\n\n        #        v node.value.body.id\n        # return c if a &gt; 0 else 0 \n        #             ^ ^        ^ node.value.orelse\n        #             | | node.value.test.{ops|comparators}\n        #             | node.value.test.left\n        # print(f\"body: {node.value.body.id} {node.value.body.ctx}\")\n\n        # print(f\"orelse: {self._extract_content(node.value.orelse)}\")\n\n        # TODO: need to get ID somehow, move the IfExp function to something else accessible and call it directly?\n        super().generic_visit(node)\n\n        # because this is direct return, we have to make a temp symbol into which we can return (in spirv terms)\n        # we have to also add it to the symbols list, making sure that it has the same type as the indicated return type\n        # and that it doesn't clash with the return type\n\n        out_str_id = f\"titan_return_id_{self.spirv_helper.return_id}\"\n        self.spirv_helper.return_id += 1\n        # TODO: make sure names don't clash?\n        self.spirv_helper.add_symbol_if_nonexistant(\n            out_str_id, self.spirv_helper.output_type_list[0], titan_type.StorageType.OUT\n        )\n\n        self.spirv_helper.add_output_symbol(out_str_id)\n\n        # store titan_id_x into the newly created return variable\n        self.spirv_helper.add_line(\n            self.spirv_helper.Sections.FUNCTIONS,\n            f\"OpStore %{out_str_id} %{self.spirv_helper._latest_ifexp_selector_id}\"\n        )\n\n        ptr_t_out_ctx = self.spirv_helper.TypeContext(\n            titan_type.DataType(self.spirv_helper.output_type_list[0]), titan_type.StorageType.OUT,\n            False, True, False\n        )\n\n        ptr_t_out_id = self.spirv_helper.get_type_id(ptr_t_out_ctx)\n\n        self.spirv_helper.add_line(\n            self.spirv_helper.Sections.VAR_CONST_DECLARATIONS,\n            f\"%{out_str_id} = OpVariable %{ptr_t_out_id.strip('%')} Output\"\n        )\n\n\n        # print(f\"return {node.value.body.id} if {node.value.test.left.id} {node.value.test.ops[0].__class__.__name__} {self._extract_content(node.value.test.comparators[0])} else {self._extract_content(node.value.orelse)}\")\n    elif isinstance(node.value, ast.BinOp):\n        logging.exception(f\"TODO implement handling binops for return values\", exc_info=False)\n        raise Exception(\"TODO implement handling binops for return values\")\n\n        id, ctx = self._eval_line(node.value)\n        print(f\"returning binop val ({id})\")\n\n        if self.spirv_helper.symbol_exists(id):\n            print(\"this was a symbol\")\n        elif self.spirv_helper.intermediate_id_exists(id):\n            print(\"this was a temp id\")\n        else:\n            raise Exception(\"idk\")\n\n    else:\n        logging.exception(f\"unhandled type during return node evaluation {node}\", exc_info=False)\n        raise Exception(f\"unhandled type during return node evaluation {node} {type(node)}\")\n</code></pre>"},{"location":"reference-docs/compiler/dataflow/","title":"Documentation for <code>dataflow.py</code>","text":""},{"location":"reference-docs/compiler/dataflow/#titan.dataflow","title":"<code>titan.dataflow</code>","text":""},{"location":"reference-docs/compiler/dataflow/#titan.dataflow.Node","title":"<code>Node</code>","text":"<p>Node class. Generated when transpiling SPIR-V into SystemVerilog. </p> <p>Attempts to replicate the dataflow structure of SPIR-V, so that generating SystemVerilog would be easier.</p> Source code in <code>titan/dataflow.py</code> <pre><code>class Node:\n    \"\"\" Node class. Generated when transpiling SPIR-V into SystemVerilog. \n\n        Attempts to replicate the dataflow structure of SPIR-V, so that generating SystemVerilog would be easier.\n    \"\"\"\n\n    @staticmethod\n    def _calculate_tick(left_node, right_node, comparison_node = None):\n        \"\"\" Calculate the correct tick for the node.\n\n            Ticks can be set to zero if the node has no parents, or to the highest tick of the parents + 1.\n        \"\"\"\n        # print(\"-[_calculate_tick] hit\")\n\n        if comparison_node is None:\n            if left_node is None and right_node is None:\n                return 0\n            elif left_node is None:\n                return right_node + 1\n            elif right_node is None:\n                return left_node + 1\n            else:\n                return max(left_node, right_node) + 1\n        else:\n            if left_node is None and right_node is None:\n                return comparison_node + 1\n            elif left_node is None:\n                return max(right_node, comparison_node) + 1\n            elif right_node is None:\n                return max(left_node, comparison_node) + 1\n            else:\n                return max(left_node, right_node, comparison_node) + 1\n\n    @staticmethod\n    def _set_tick_during_init(context: NodeContext):\n        \"\"\" Calculate the tick for the node during initialisation.\"\"\"\n        # left_node_is_none = context.input_left == None\n        # right_node_is_none = context.input_right == None\n\n        l_node_val = None if context.input_left == None else context.input_left.tick\n        r_node_val = None if context.input_right == None else context.input_right.tick\n\n        if context.is_comparison:\n            # return Node._calculate_tick(l_node_val, r_node_val, context.data[0].tick)\n            # TODO: do we have to account for the tick of the input nodes, if the selector is guaranteed to come after?\n            #                                                                               is it even guaranteed to come right after? idk\n            return Node._calculate_tick(0, 0, context.data[0].tick) \n        else:\n            return Node._calculate_tick(l_node_val, r_node_val)\n\n\n    def __init__(self, context: NodeContext):\n        \"\"\" Init function for a node.\n\n            Args:\n                context: Node context to create the node with.\n        \"\"\"\n        self.spirv_line_no = context.line_no\n        self.spirv_id = context.id\n        self.type_id = context.type_id\n        self.input_left = context.input_left\n        self.input_right = context.input_right\n        self.operation = context.operation\n        self.data = context.data\n        self.is_comparison = context.is_comparison\n        self.tick = self._set_tick_during_init(context)\n\n\n    def _update_tick(self) -&gt; int:\n        \"\"\" Helper function to update the tick when one of the parent nodes are changed.\n\n            Returns:\n                Recalculated tick value.\n        \"\"\"\n        left_node_is_none = self.input_left == None\n        right_node_is_none = self.input_right == None\n\n        l_node_val = None if left_node_is_none else self.input_left.tick\n        r_node_val = None if right_node_is_none else self.input_right.tick\n\n        if self.is_comparison:\n            return Node._calculate_tick(l_node_val, r_node_val, self.data[0].tick)\n        else:\n            return Node._calculate_tick(l_node_val, r_node_val)\n\n        # if left_node_is_none and right_node_is_none:\n        #     return 0\n        # elif left_node_is_none:\n        #     return self.input_right.tick + 1\n        # elif right_node_is_none:\n        #     return self.input_left.tick + 1\n        # else:\n        #     return max(self.input_left.tick, self.input_right.tick) + 1\n\n\n    def update_input(self, pos: int, new_node: Node):\n        \"\"\" Update a parent node.\n\n            Automatically recalculates the tick for the current node.\n\n            Args:\n                pos: 0 = left node, 1 = right node\n                new_node (titan.dataflow.Node): New node to update the input with.\n        \"\"\"        \n        if pos == 0: # left node\n            self.input_left = new_node\n        elif pos == 1: # right node\n            self.input_right = new_node\n\n        self.tick = self._update_tick()\n\n    # TODO: make this look a lot better- how to do multi line strings without tabs?\n    # def __str__(self):\n        # return f\"({self.__class__.__name__}: [{self.spirv_line_no}:{self.spirv_id}], \\\n# left: [{self.input_left.spirv_id if self.input_left is not None else None}], \\\n# right: [{self.input_right.spirv_id if self.input_right is not None else None}], \\\n# operation: {self.operation}, data: {self.data}, tick: {self.tick})\"\n\n    # TODO: make this look better\n    def __str__(self):\n        return f\"({self.__class__.__name__}: [{self.spirv_line_no}:{self.spirv_id}], type_id: [{self.type_id}], left: [{None if self.input_left is None else self.input_left.spirv_id}], right: [{None if self.input_right is None else self.input_right.spirv_id}], op: {self.operation}, data: {self.data},  is_comparison: {self.is_comparison}, tick: {self.tick})\"\n\n\n    def __repr__(self):\n        return f\"({self.__class__.__name__}: [{self.spirv_line_no}:{self.spirv_id}], type_id: [{self.type_id}], left: [{self.input_left}], right: [{self.input_right}], op: {self.operation}, data: {self.data},  is_comparison: {self.is_comparison}, tick: {self.tick})\"\n</code></pre>"},{"location":"reference-docs/compiler/dataflow/#titan.dataflow.Node.__init__","title":"<code>__init__(context)</code>","text":"<p>Init function for a node.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>NodeContext</code> <p>Node context to create the node with.</p> required Source code in <code>titan/dataflow.py</code> <pre><code>def __init__(self, context: NodeContext):\n    \"\"\" Init function for a node.\n\n        Args:\n            context: Node context to create the node with.\n    \"\"\"\n    self.spirv_line_no = context.line_no\n    self.spirv_id = context.id\n    self.type_id = context.type_id\n    self.input_left = context.input_left\n    self.input_right = context.input_right\n    self.operation = context.operation\n    self.data = context.data\n    self.is_comparison = context.is_comparison\n    self.tick = self._set_tick_during_init(context)\n</code></pre>"},{"location":"reference-docs/compiler/dataflow/#titan.dataflow.Node._calculate_tick","title":"<code>_calculate_tick(left_node, right_node, comparison_node=None)</code>  <code>staticmethod</code>","text":"<p>Calculate the correct tick for the node.</p> <p>Ticks can be set to zero if the node has no parents, or to the highest tick of the parents + 1.</p> Source code in <code>titan/dataflow.py</code> <pre><code>@staticmethod\ndef _calculate_tick(left_node, right_node, comparison_node = None):\n    \"\"\" Calculate the correct tick for the node.\n\n        Ticks can be set to zero if the node has no parents, or to the highest tick of the parents + 1.\n    \"\"\"\n    # print(\"-[_calculate_tick] hit\")\n\n    if comparison_node is None:\n        if left_node is None and right_node is None:\n            return 0\n        elif left_node is None:\n            return right_node + 1\n        elif right_node is None:\n            return left_node + 1\n        else:\n            return max(left_node, right_node) + 1\n    else:\n        if left_node is None and right_node is None:\n            return comparison_node + 1\n        elif left_node is None:\n            return max(right_node, comparison_node) + 1\n        elif right_node is None:\n            return max(left_node, comparison_node) + 1\n        else:\n            return max(left_node, right_node, comparison_node) + 1\n</code></pre>"},{"location":"reference-docs/compiler/dataflow/#titan.dataflow.Node._set_tick_during_init","title":"<code>_set_tick_during_init(context)</code>  <code>staticmethod</code>","text":"<p>Calculate the tick for the node during initialisation.</p> Source code in <code>titan/dataflow.py</code> <pre><code>@staticmethod\ndef _set_tick_during_init(context: NodeContext):\n    \"\"\" Calculate the tick for the node during initialisation.\"\"\"\n    # left_node_is_none = context.input_left == None\n    # right_node_is_none = context.input_right == None\n\n    l_node_val = None if context.input_left == None else context.input_left.tick\n    r_node_val = None if context.input_right == None else context.input_right.tick\n\n    if context.is_comparison:\n        # return Node._calculate_tick(l_node_val, r_node_val, context.data[0].tick)\n        # TODO: do we have to account for the tick of the input nodes, if the selector is guaranteed to come after?\n        #                                                                               is it even guaranteed to come right after? idk\n        return Node._calculate_tick(0, 0, context.data[0].tick) \n    else:\n        return Node._calculate_tick(l_node_val, r_node_val)\n</code></pre>"},{"location":"reference-docs/compiler/dataflow/#titan.dataflow.Node._update_tick","title":"<code>_update_tick()</code>","text":"<p>Helper function to update the tick when one of the parent nodes are changed.</p> <p>Returns:</p> Type Description <code>int</code> <p>Recalculated tick value.</p> Source code in <code>titan/dataflow.py</code> <pre><code>def _update_tick(self) -&gt; int:\n    \"\"\" Helper function to update the tick when one of the parent nodes are changed.\n\n        Returns:\n            Recalculated tick value.\n    \"\"\"\n    left_node_is_none = self.input_left == None\n    right_node_is_none = self.input_right == None\n\n    l_node_val = None if left_node_is_none else self.input_left.tick\n    r_node_val = None if right_node_is_none else self.input_right.tick\n\n    if self.is_comparison:\n        return Node._calculate_tick(l_node_val, r_node_val, self.data[0].tick)\n    else:\n        return Node._calculate_tick(l_node_val, r_node_val)\n</code></pre>"},{"location":"reference-docs/compiler/dataflow/#titan.dataflow.Node.update_input","title":"<code>update_input(pos, new_node)</code>","text":"<p>Update a parent node.</p> <p>Automatically recalculates the tick for the current node.</p> <p>Parameters:</p> Name Type Description Default <code>pos</code> <code>int</code> <p>0 = left node, 1 = right node</p> required <code>new_node</code> <code>Node</code> <p>New node to update the input with.</p> required Source code in <code>titan/dataflow.py</code> <pre><code>def update_input(self, pos: int, new_node: Node):\n    \"\"\" Update a parent node.\n\n        Automatically recalculates the tick for the current node.\n\n        Args:\n            pos: 0 = left node, 1 = right node\n            new_node (titan.dataflow.Node): New node to update the input with.\n    \"\"\"        \n    if pos == 0: # left node\n        self.input_left = new_node\n    elif pos == 1: # right node\n        self.input_right = new_node\n\n    self.tick = self._update_tick()\n</code></pre>"},{"location":"reference-docs/compiler/dataflow/#titan.dataflow.NodeContext","title":"<code>NodeContext</code>","text":"<p>             Bases: <code>NamedTuple</code></p> <p>Tuple which holds context about a node.</p> <p>Attributes:</p> Name Type Description <code>line_no</code> <code>int</code> <p>Line of the SPIR-V assembly this node referring to.</p> <code>id</code> <code>str</code> <p>Associated SPIR-V ID.</p> <code>type_id</code> <code>str</code> <p>Associated type ID.</p> <code>input_left</code> <code>Node</code> <p>Left parent node.</p> <code>input_right</code> <code>Node</code> <p>Right parent node.</p> <code>operation</code> <code>Operation</code> <p>Operation being performed by the node.</p> <code>data</code> <code>List()</code> <p>(list): Additional information stored by the node.</p> <code>is_comparison</code> <code>bool</code> <p>Set if this node doing a comparison.</p> Source code in <code>titan/dataflow.py</code> <pre><code>class NodeContext(NamedTuple):\n    \"\"\" Tuple which holds context about a node.\n\n        Attributes:\n            line_no (int): Line of the SPIR-V assembly this node referring to.\n            id (str): Associated SPIR-V ID.\n            type_id (str): Associated type ID.\n            input_left (titan.dataflow.Node): Left parent node.\n            input_right (titan.dataflow.Node): Right parent node.\n            operation (titan.common.symbols.Operation): Operation being performed by the node.\n            data: (list): Additional information stored by the node.\n            is_comparison (bool): Set if this node doing a comparison.\n    \"\"\"\n    line_no: int = 0\n    id: str = \"\"\n    type_id: str = \"\"\n    input_left: Node = None\n    input_right: Node = None\n    operation: Operation = None\n    data: List() = []\n    is_comparison: bool = False # hack because i didn't realise that OpSelect had so many parameters\n</code></pre>"},{"location":"reference-docs/compiler/generate/","title":"Documentation for <code>generate.py</code>","text":"<p>Warning</p> <p>Several functions within this file related to symbol table generation and SPIR-V generation have been replaced. Please head to dataflow.py for the new implementation.</p> <p>The following will only cover the SystemVerilog generation of this file.</p>"},{"location":"reference-docs/compiler/generate/#titan.generate._get_spirv_function_locations","title":"<code>titan.generate._get_spirv_function_locations(parsed_spirv)</code>","text":"Source code in <code>titan/generate.py</code> <pre><code>def _get_spirv_function_locations(parsed_spirv):\n    # TODO: figure out how to improve this\n    line_no = fn_start = 0\n    fn_name = \"\"\n    fn_locations = []\n    _marked_start = False\n    _marked_end = False\n    for line in parsed_spirv:\n        match line.opcode:\n            case \"Function\":\n                fn_start = line_no\n                fn_name = line.id[1:] # slice to remove '%'\n                _marked_start = True\n            case \"FunctionEnd\":\n                fn_locations.append(_FunctionLocation(fn_start, line_no, fn_name))\n                fn_name = \"\"\n                _marked_end = True      \n\n        line_no += 1\n\n    if (_marked_start and _marked_end):\n        return fn_locations\n    else:\n        logging.exception(f\"failed to determine start/end point of function (start: {_marked_start}, end: {_marked_end})\", exc_info=False)\n        raise Exception(f\"failed to determine start/end point of function (start: {_marked_start}, end: {_marked_end})\")\n</code></pre>"},{"location":"reference-docs/compiler/generate/#titan.generate.generate_verilog","title":"<code>titan.generate.generate_verilog(parsed_spirv)</code>","text":"<p>Generate SystemVerilog from parsed SPIR-V assembly.</p> <p>Loops through the parsed SPIR-V assembly, generating the corresponding SystemVerilog code.</p> <p>Parameters:</p> Name Type Description Default <code>parsed_spirv</code> <code>ParseResults</code> <p>Parsed SPIR-V assembly, in <code>pyparsing.ParseResults</code> format.</p> required <p>Attributes:</p> Name Type Description <code>verilog</code> <p>Verilog helper class.</p> <code>fn_name</code> <p>Top-level function name.</p> <code>fn_locations</code> <p>Line numbers of SPIR-V functions.</p> Source code in <code>titan/generate.py</code> <pre><code>def generate_verilog(parsed_spirv: pp.ParseResults):\n    \"\"\" Generate SystemVerilog from parsed SPIR-V assembly.\n\n        Loops through the parsed SPIR-V assembly, generating the corresponding SystemVerilog code.\n\n        Args:\n            parsed_spirv: Parsed SPIR-V assembly, in ``pyparsing.ParseResults`` format.\n\n        Attributes:\n            verilog: Verilog helper class.\n            fn_name: Top-level function name.\n            fn_locations: Line numbers of SPIR-V functions.\n    \"\"\"\n    verilog = m.Verilog_ASM()               \n\n    fn_name = \"\"\n    fn_locations = _get_spirv_function_locations(parsed_spirv)\n\n    # print(f\"SPIRV: {parsed_spirv}\")\n\n    # deal with headers\n    for x in range(0, fn_locations[0].start_pos):\n        line = parsed_spirv[x]\n        logging.debug(line)\n\n        match line.opcode:\n            case \"EntryPoint\":\n                fn_name = line.opcode_args[2][1:-1]\n                verilog.create_function(fn_name)\n\n            case \"Constant\":\n                if line.id not in verilog.declared_symbols:\n                    verilog.declared_symbols.append(line.id)\n\n                if verilog.type_exists_in_func(fn_name, line.opcode_args[0]):\n                    verilog.add_body_node_to_function(\n                        fn_name,\n                        d.Node(\n                            d.NodeContext(\n                                x,\n                                line.id,\n                                line.opcode_args[0],\n                                None, None,\n                                # s.Operation.CONSTANT_DECLARATION,\n                                s.Operation.GLOBAL_CONST_DECLARATION,\n                                [line.opcode_args[1]]\n                            )\n                        )\n                    )\n                else:\n                    logging.exception(f\"{TitanErrors.NON_EXISTENT_SYMBOL.value} ({line.opcode_args[0]} on line {x}) ({TitanErrors.NON_EXISTENT_SYMBOL.name})\", exc_info=False)\n                    raise Exception(f\"{TitanErrors.NON_EXISTENT_SYMBOL.value} ({line.opcode_args[0]} on line {x})\", TitanErrors.NON_EXISTENT_SYMBOL.name)\n\n            case \"Variable\":\n                if line.id not in verilog.declared_symbols:\n                    verilog.declared_symbols.append(line.id)\n\n                match line.opcode_args[1]:\n                    case \"Output\":\n                        verilog.add_output_to_function(fn_name, line.id[1:])\n                        verilog.add_body_node_to_function(\n                            fn_name,\n                            d.Node(\n                                d.NodeContext(\n                                    x, line.id,\n                                    verilog.get_primative_type_id_from_id(fn_name, line.opcode_args[0]),\n                                    None, None, \n                                    # s.Operation.VARIABLE_DECLARATION\n                                    s.Operation.GLOBAL_VAR_DECLARATION,\n                                    [s.Operation.FUNCTION_OUT_VAR_PARAM]\n                                )\n                            )\n                        )\n\n                    case \"Input\":\n                        verilog.add_input_to_function(fn_name, line.id[1:])\n\n                        verilog.add_body_node_to_function(\n                            fn_name,\n                            d.Node(\n                                d.NodeContext(\n                                    x, line.id,\n                                    verilog.get_primative_type_id_from_id(fn_name, line.opcode_args[0]),\n                                    None, None, s.Operation.GLOBAL_VAR_DECLARATION,\n                                    [s.Operation.FUNCTION_IN_VAR_PARAM]\n                                )\n                            )\n                        )\n\n                        # raise Exception(TitanErrors.NOT_IMPLEMENTED.value, TitanErrors.NOT_IMPLEMENTED.name)\n\n            case \"TypePointer\":\n                verilog.add_type_context_to_function(\n                    fn_name,\n                    line.id, # %ptr_something_something id\n                    m._VerilogTypeContext(\n                        verilog.get_datatype_from_id(fn_name, line.opcode_args[1]), # returns types.DataType\n                        [], True, line.opcode_args[1] # line.opcode_args[1] = %type_something (primative)\n                    )\n                )\n\n            case \"TypeInt\":\n                verilog.add_type_context_to_function(\n                    fn_name,\n                    line.id,\n                    m._VerilogTypeContext(\n                        t.DataType.INTEGER,\n                        # line.id,\n                        line.opcode_args.as_list()\n                    )\n                )\n\n            case \"TypeFloat\":\n                logging.exception(f\"{TitanErrors.NOT_IMPLEMENTED.value} TypeFloat ({TitanErrors.NOT_IMPLEMENTED.name})\", exc_info=False)\n                raise Exception(f\"{TitanErrors.NOT_IMPLEMENTED.value} TypeFloat\", TitanErrors.NOT_IMPLEMENTED.name)\n\n            case \"TypeBool\":\n                verilog.add_type_context_to_function(\n                    fn_name, line.id,\n                    m._VerilogTypeContext(\n                        t.DataType.BOOLEAN, [], False, \"\"\n                    )\n                )\n\n\n    for fn_count in range(0, len(fn_locations)):\n        fn = fn_locations[fn_count]\n\n        # for pos in range()\n        for pos in range(fn.start_pos, fn.end_pos + 1):\n            line = parsed_spirv[pos]\n            logging.debug(line)\n\n            match line.opcode:\n\n                case \"Variable\":\n                    if line.id not in verilog.declared_symbols:\n                        verilog.declared_symbols.append(line.id)\n\n                    verilog.add_body_node_to_function(\n                        fn_name,\n                        d.Node(\n                            d.NodeContext(\n                                pos, line.id, \n                                verilog.get_primative_type_id_from_id(fn_name, line.opcode_args[0]),\n                                None, None, s.Operation.VARIABLE_DECLARATION\n                            )\n                        )\n                    )\n\n\n                case \"Store\":\n                    # print(verilog.get_node(fn_name, line.opcode_args[0]))\n                    # storage_node = verilog.get_node(fn_name, line.opcode_args[0])\n\n                    # if verilog.does_node_exist()\n                    # print(f\"---fn_name {fn_name} arg {line.opcode_args[1]}\")\n\n                    if verilog.does_node_exist(fn_name, line.opcode_args[1]):\n                        value_node = verilog.get_node(fn_name, line.opcode_args[1])\n\n                        verilog.modify_node(fn_name, line.opcode_args[0], 0, value_node, s.Operation.STORE)\n                    else:\n                        logging.exception(f\"does not exist {fn_name} {line.opcode_args[1]}\", exc_info=False)\n                        raise Exception(f\"DOES NOT EXIST {fn_name} {line.opcode_args[1]}\")\n\n\n                case \"Load\":\n                    value_node = verilog.get_node(fn_name, line.opcode_args[1])\n\n                    verilog.add_body_node_to_function(\n                        fn_name,\n                        d.Node(\n                            d.NodeContext(\n                                pos, line.id, line.opcode_args[0], value_node, None,\n                                s.Operation.LOAD\n                            )\n                        )\n                    )\n\n                # TODO: these arithmetic operations practically follow the same format, is there a way to minimise this repeating code?\n                case \"IAdd\":\n                    l = verilog.get_node(fn_name, line.opcode_args[1])\n                    r = verilog.get_node(fn_name, line.opcode_args[2])\n\n                    verilog.add_body_node_to_function(\n                        fn_name,\n                        d.Node(\n                            d.NodeContext(\n                                pos, line.id, line.opcode_args[0],\n                                l, r, s.Operation.ADD\n                            )\n                        )\n                    )\n\n                case \"ISub\":\n                    l = verilog.get_node(fn_name, line.opcode_args[1])\n                    r = verilog.get_node(fn_name, line.opcode_args[2])\n\n                    verilog.add_body_node_to_function(\n                        fn_name,\n                        d.Node(\n                            d.NodeContext(\n                                pos, line.id, line.opcode_args[0],\n                                l, r, s.Operation.SUB\n                            )\n                        )\n                    )\n\n                    # raise Exception(TitanErrors.NOT_IMPLEMENTED.value, TitanErrors.NOT_IMPLEMENTED.name)\n                case \"IMul\":\n                    l = verilog.get_node(fn_name, line.opcode_args[1])\n                    r = verilog.get_node(fn_name, line.opcode_args[2])\n\n                    verilog.add_body_node_to_function(\n                        fn_name,\n                        d.Node(\n                            d.NodeContext(\n                                pos, line.id, line.opcode_args[0],\n                                l, r, s.Operation.MULT\n                            )\n                        )\n                    )\n                    # raise Exception(TitanErrors.NOT_IMPLEMENTED.value, TitanErrors.NOT_IMPLEMENTED.name)\n\n                case \"SDiv\":\n                    # print(f\"--------{line.opcode_args}\")\n                    l = verilog.get_node(fn_name, line.opcode_args[1])\n                    r = verilog.get_node(fn_name, line.opcode_args[2])\n\n                    verilog.add_body_node_to_function(\n                        fn_name,\n                        d.Node(\n                            d.NodeContext(\n                                pos, line.id, line.opcode_args[0],\n                                l, r, s.Operation.DIV\n                            )\n                        )\n                    )\n\n                case \"Select\":\n                        #                          0           1               2             3\n                        # %result_id = OpSelect %type_id %comparison_id %true_value_id %false_value_id\n\n                        l = verilog.get_node(fn_name, line.opcode_args[2])\n                        r = verilog.get_node(fn_name, line.opcode_args[3])\n\n                        compare_node = verilog.get_node(fn_name, line.opcode_args[1])\n                        # print(f\"-[generate_verilog] [select case for OpSelect] {compare_node}\")\n\n                        verilog.add_body_node_to_function(\n                            fn_name,\n                            d.Node(\n                                d.NodeContext(\n                                    pos, line.id, line.opcode_args[0],\n                                    l, r, s.Operation.DECISION, [compare_node], True\n                                )\n                            )\n                        )\n\n\n                # these comparison functions are practicaly the same except for the operation that gets added\n                case \"IEqual\" | \"FOrdEqual\":\n                    l = verilog.get_node(fn_name, line.opcode_args[1])\n                    r = verilog.get_node(fn_name, line.opcode_args[2])\n\n                    verilog.add_body_node_to_function(\n                        fn_name,\n                        d.Node(\n                            d.NodeContext(\n                                pos, line.id, line.opcode_args[0],\n                                l, r, s.Operation.EQUAL_TO\n                            )\n                        )\n                    )\n\n                case \"INotEqual\" | \"FOrdNotEqual\":\n                    l = verilog.get_node(fn_name, line.opcode_args[1])\n                    r = verilog.get_node(fn_name, line.opcode_args[2])\n\n                    verilog.add_body_node_to_function(\n                        fn_name,\n                        d.Node(\n                            d.NodeContext(\n                                pos, line.id, line.opcode_args[0],\n                                l, r, s.Operation.NOT_EQUAL_TO\n                            )\n                        )\n                    )\n\n                case \"SLessThan\" | \"FOrdLessThan\":\n                    l = verilog.get_node(fn_name, line.opcode_args[1])\n                    r = verilog.get_node(fn_name, line.opcode_args[2])\n\n                    verilog.add_body_node_to_function(\n                        fn_name,\n                        d.Node(\n                            d.NodeContext(\n                                pos, line.id, line.opcode_args[0],\n                                l, r, s.Operation.LESS_THAN\n                            )\n                        )\n                    )\n\n                case \"SLessThanEqual\" | \"FOrdLessThanEqual\":\n                    l = verilog.get_node(fn_name, line.opcode_args[1])\n                    r = verilog.get_node(fn_name, line.opcode_args[2])\n\n                    verilog.add_body_node_to_function(\n                        fn_name,\n                        d.Node(\n                            d.NodeContext(\n                                pos, line.id, line.opcode_args[0],\n                                l, r, s.Operation.LESS_OR_EQ\n                            )\n                        )\n                    )\n\n                case \"SGreaterThan\" | \"FOrdGreaterThan\":\n                    l = verilog.get_node(fn_name, line.opcode_args[1])\n                    r = verilog.get_node(fn_name, line.opcode_args[2])\n\n                    verilog.add_body_node_to_function(\n                        fn_name,\n                        d.Node(\n                            d.NodeContext(\n                                pos, line.id, line.opcode_args[0],\n                                l, r, s.Operation.GREATER_THAN\n                            )\n                        )\n                    )\n\n                case \"SGreaterThanEqual\" | \"FOrdGreaterThanEqual\":\n                    l = verilog.get_node(fn_name, line.opcode_args[1])\n                    r = verilog.get_node(fn_name, line.opcode_args[2])\n\n                    verilog.add_body_node_to_function(\n                        fn_name,\n                        d.Node(\n                            d.NodeContext(\n                                pos, line.id, line.opcode_args[0],\n                                l, r, s.Operation.GREATER_OR_EQ\n                            )\n                        )\n                    )\n\n                case \"ShiftLeftLogical\":\n                    l = verilog.get_node(fn_name, line.opcode_args[1]) # thing to shift\n                    r = verilog.get_node(fn_name, line.opcode_args[2]) # how much to shift by\n\n                    verilog.add_body_node_to_function(\n                        fn_name,\n                        d.Node(\n                            d.NodeContext(\n                                pos, line.id, line.opcode_args[0],\n                                l, r, s.Operation.SHIFT_LEFT\n                            )\n                        )\n                    )\n\n                # TODO: this might need to handle \"OpShiftRightArithmetic\"\n                case \"OpShiftRightLogical\":\n                    l = verilog.get_node(fn_name, line.opcode_args[1])\n                    r = verilog.get_node(fn_name, line.opcode_args[2])\n\n                    verilog.add_body_node_to_function(\n                        fn_name,\n                        d.Node(\n                            d.NodeContext(\n                                pos, line.id, line.opcode_args[0],\n                                l, r, s.Operation.SHIFT_RIGHT\n                            )\n                        )\n                    )\n\n\n\n                case _:\n                    # TODO: make this less ugly\n                    if line.opcode == \"Function\" or line.opcode == \"Label\" or line.opcode == \"Return\" or line.opcode == \"FunctionEnd\":\n                        continue\n                    else:\n                        logging.exception(f\"{TitanErrors.UNKNOWN_SPIRV_OPCODE.value} ({line.opcode}) ({TitanErrors.UNKNOWN_SPIRV_OPCODE.name})\", exc_info=False)\n                        raise Exception(f\"{TitanErrors.UNKNOWN_SPIRV_OPCODE.value} ({line.opcode})\", TitanErrors.UNKNOWN_SPIRV_OPCODE.name) \n\n\n\n\n\n\n    # print()\n    # print(verilog.content)\n\n    # print()\n    # for k, v in verilog.content.items():\n    #     print(f\"types: {v.types}\")\n    #     print(f\"inputs: {v.inputs}\")\n    #     print(f\"outputs: {v.outputs}\\n\")\n    #     # print(f\"body_nodes: {v.body_nodes}\")\n    #     for a, b in v.body_nodes.items():\n    #         print(f\"key: {a}\")\n    #         for node in b:\n    #             print(f\"\\t{node}\")\n    #         print()\n\n\n    # print()\n    verilog.generate_dot_graph()\n    # _generate_verilog_text(verilog)\n    print(verilog.declared_symbols)\n    verilog.clean_graph()\n    verilog.generate_dot_graph(\"clean_nodes\")\n    _generate_verilog_text(verilog)\n</code></pre>"},{"location":"reference-docs/compiler/generate/#titan.generate._generate_verilog_text","title":"<code>titan.generate._generate_verilog_text(v)</code>","text":"<p>Converts the nodes into actual Verilog code.</p> <p>Also generates a Yosys script to generate a graph of the module <code>read_verilog -sv {fn}.sv; proc; opt; memory; opt; show;</code></p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>Verilog_ASM</code> <p>Verilog object containing body nodes.</p> required Source code in <code>titan/generate.py</code> <pre><code>def _generate_verilog_text(v: m.Verilog_ASM):\n    \"\"\" Converts the nodes into actual Verilog code.\n\n        Also generates a Yosys script to generate a graph of the module\n        ``read_verilog -sv {fn}.sv; proc; opt; memory; opt; show;``\n\n        Args:\n            v: Verilog object containing body nodes.\n    \"\"\"\n\n    def __get_correct_id(node: d.Node):\n        if node.operation in s.Operation_Type.GENERIC_CONSTANT_DECLARATION:\n            return node.data[0]\n        else:\n            return node.spirv_id[1:]\n\n    logging.debug(f\"content: {v.content}\")\n    logging.debug(f\"declared symbols: {v.declared_symbols}\")\n    logging.debug(f\"marked symbols for deletion: {v.marked_symbols_for_deletion}\")\n\n    writer = m.Verilog_Text()\n\n    writer.append_code(\n        writer.Sections.MODULE_AND_PORTS,\n        f\"// generated by titan, dont modify anything otherwise it might break =)\"\n    )\n\n    for fn in v.content.keys():\n    # for i in range(len(v.content.keys())):\n        # fn = list(v.content.keys())[i]\n\n        writer.append_code(\n            writer.Sections.MODULE_AND_PORTS,\n            f\"module {fn} (\"\n        )\n\n        writer.append_code(\n            writer.Sections.MODULE_AND_PORTS,\n            f\"\\tinput wire clock,\"\n        )\n\n        writer.append_code(\n            writer.Sections.ALWAYS_BLOCK,\n            f\"\\talways_ff @ (posedge clock) begin\"\n        )\n\n        fn_data = v.content[fn]\n\n        # print(f\"types: {fn_data.types}\\n\\ninputs: {fn_data.inputs}\\toutputs: {fn_data.outputs}\\n\\nbody nodes: {fn_data.body_nodes}\")\n\n        sorted_nodes = v._sort_body_nodes_by_tick(fn)\n\n        # for tick in sorted_nodes.keys():\n        for tick in range(len(sorted_nodes.keys())):\n            logging.debug(f\"tick {tick} has {len(sorted_nodes[tick])} nodes\")\n\n            io_length_tracker = 0\n            # for node in sorted_nodes[tick]:\n            # print(f\"--=-=-=-=-= LENGTH: {len(sorted_nodes[tick])}\")\n            for x in range(len(sorted_nodes[tick])):\n                node = sorted_nodes[tick][x]\n                logging.debug(f\"\\t{node}\")\n\n                if node.operation is s.Operation.GLOBAL_VAR_DECLARATION:\n                    # this should only ever get hit on tick 0 but just in case\n                    if tick != 0:\n                        logging.exception(f\"variable declaration outside of tick 0 ({TitanErrors.UNEXPECTED.name})\", exc_info=False)\n                        raise Exception(\"variable declaration outside of tick 0\", TitanErrors.UNEXPECTED.name)\n\n                    type_ctx = v.get_type_context_from_function(fn, node.type_id)\n                    width = int(type_ctx.data[0])\n\n                    # ender = \"\\n);\" if io_length_tracker == len(sorted_nodes[tick]) - 1 else \",\"\n                    ender = \"\\n);\" if io_length_tracker == (len(fn_data.inputs) + len(fn_data.outputs)) - 1 else \",\"\n\n                    match node.data[0]:\n                        case s.Operation.FUNCTION_IN_VAR_PARAM:\n                            writer.append_code(\n                                writer.Sections.MODULE_AND_PORTS,\n                                f\"\\tinput logic [{width-1}:0] {node.spirv_id[1:]}{ender}\"\n                            )\n\n                        case s.Operation.FUNCTION_OUT_VAR_PARAM:\n                            writer.append_code(\n                                writer.Sections.MODULE_AND_PORTS,\n                                f\"\\toutput wire [{width-1}:0] {node.spirv_id[1:]}{ender}\"\n                            )\n\n                    io_length_tracker += 1\n\n\n                if node.operation is s.Operation.STORE and len(node.data) == 1:\n                    match node.data[0]:\n                        case s.Operation.FUNCTION_OUT_VAR_PARAM:\n                            writer.append_code(\n                                writer.Sections.ASSIGNMENTS,\n                                f\"\\tassign {node.spirv_id[1:]} = {node.input_left.spirv_id[1:]};\"\n                            )\n                        case _:\n                            logging.exception(f\"{TitanErrors.UNEXPECTED.value} node: {node} ({TitanErrors.UNEXPECTED.name})\", exc_info=False)\n                            raise Exception(f\"{TitanErrors.UNEXPECTED.value}\\nnode: {node}\", TitanErrors.UNEXPECTED.name)\n\n\n                if node.operation in s.Operation_Type.ARITHMETIC:\n                    if node.spirv_id not in v.declared_symbols:\n\n                        # update this with a proper function\n                        width = int(v.get_type_context_from_function(fn, node.type_id).data[0])\n\n                        writer.append_code(\n                            writer.Sections.INTERNAL,\n                            f\"\\tlogic [{width-1}:0] {node.spirv_id[1:]};\"\n                        )\n\n                    line = f\"\\t\\t{node.spirv_id[1:]} &lt;= \"\n                    op_symbol = \"\"\n\n                    match node.operation:\n                        case s.Operation.ADD:\n                            op_symbol = \"+\"\n                        case s.Operation.SUB:\n                            op_symbol = \"-\"\n                        case s.Operation.MULT:\n                            op_symbol = \"*\"\n                        case s.Operation.DIV:\n                            op_symbol = \"/\"\n\n\n                    # line += f\"{node.input_left.spirv_id[1:]} {op_symbol} {node.input_right.spirv_id[1:]};\"\n\n                    line += f\"{__get_correct_id(node.input_left)} {op_symbol} {__get_correct_id(node.input_right)};\"\n\n                    writer.append_code(\n                        writer.Sections.ALWAYS_BLOCK,\n                        line\n                    )\n\n                if node.operation in s.Operation_Type.COMPARISON:\n                    defer_node_creation = False\n\n                    logging.debug(f\"checking 1 tick ahead...({tick} + 1 = {tick+1})\")\n\n                    for future_node in sorted_nodes[tick+1]:\n                        if defer_node_creation:\n                            break\n\n                        if future_node.operation == s.Operation.DECISION:\n                            if future_node.data[0].spirv_id == node.spirv_id:\n                                logging.debug(\"found a reference\")\n                                defer_node_creation = True\n\n                            else:\n                                logging.debug(\"no reference found\")\n\n                    logging.debug(f\"stopped checking 1 tick ahead...\\n\")\n\n                    if not defer_node_creation:\n                        # TODO: add node stuff here - need to make the logic thingy and then add a line somehow idk\n\n                        # 1. make logic value\n                        # 2. assign logic value with comparison operation\n\n                        # logging.error(f\"{v.get_type_context_from_function(fn, node.type_id)}\")\n                        # width = int(v.get_type_context_from_function(fn, node.type_id).data[0])\n\n                        writer.append_code(\n                           writer.Sections.INTERNAL,\n                            f\"\\tlogic {node.spirv_id[1:]};\"\n                        )\n\n                        # TODO: need to get logical operators not bitwise... \n                        compare_op = s.Operation(node.operation).value\n                        line = f\"\\t\\t{node.spirv_id[1:]} &lt;= {__get_correct_id(node.input_left)} {compare_op} {__get_correct_id(node.input_right)};\"\n\n                        writer.append_code(\n                            writer.Sections.ALWAYS_BLOCK,\n                            line\n                        )\n\n\n\n                if node.operation is s.Operation.DECISION:\n                    # paired_decision_node = sorted_nodes[tick+1][x+1]\n                    logging.debug(f\"in decision: {node}\")\n                    comparison_node = node.data[0]\n\n                    # comparison node holds the comparison operator, and the comparison itself\n                    # the paried decision node holds the expected results\n\n                    # so i.e. c = a &gt;= 10 ? 5 : 0 would require the comparison node to construct a &gt;= 10\n                    # and the paried decision node for the ? 5 : 0 section\n\n                    # we dont want to create a logic value for the comparison node because that can just be abstracted away\n                    # so instead we will create the logic value for the decision node\n\n                    width = int(v.get_type_context_from_function(fn, node.type_id).data[0])\n\n                    writer.append_code(\n                        writer.Sections.INTERNAL,\n                        f\"\\tlogic [{width-1}:0] {node.spirv_id[1:]};\"\n                    )\n\n                    compare_op = s.Operation(comparison_node.operation).value\n\n                    # TODO: __get_correct_id(node) was returning the string representation of the node instead, why?\n                    line = f\"\\t\\t{node.spirv_id[1:]} &lt;= {__get_correct_id(comparison_node.input_left)} {compare_op} {__get_correct_id(comparison_node.input_right)} ? {__get_correct_id(node.input_left)} : {__get_correct_id(node.input_right)};\"\n\n                    writer.append_code(\n                        writer.Sections.ALWAYS_BLOCK,\n                        line\n                    )\n\n                if node.operation in s.Operation_Type.BITWISE:\n\n                    width = int(v.get_type_context_from_function(fn, node.type_id).data[0])\n\n                    writer.append_code(\n                        writer.Sections.INTERNAL,\n                        f\"\\tlogic [{width-1}:0] {node.spirv_id[1:]}\"\n                    )\n\n                    line = f\"\\t\\t{__get_correct_id(node)} &lt;= {__get_correct_id(node.input_left)} {s.Operation(node.operation).value} {__get_correct_id(node.input_right)};\"\n\n                    writer.append_code(\n                        writer.Sections.ALWAYS_BLOCK,\n                        line\n                    )\n\n        # writer.append_code(\n        #     writer.Sections.MODULE_AND_PORTS,\n        #     \")\"\n        # )\n\n        writer.append_code(\n            writer.Sections.ALWAYS_BLOCK,\n            f\"\\tend\"\n        )\n\n        writer.append_code(\n            writer.Sections.ASSIGNMENTS,\n            \"endmodule\"\n        )\n\n    print()\n    writer.print_contents()\n    writer.output_to_file(fn)\n\n    with open(f\"yosys_script_{fn}.txt\", \"w+\") as f:\n        f.write(f\"read_verilog -sv {fn}.sv; proc; opt; memory; opt; show;\")\n</code></pre>"},{"location":"reference-docs/compiler/machine/","title":"Documentation for <code>machine.py</code>","text":"<p>Warning</p> <p>Several functions within this file related to SPIR-V generation have been replaced. Visit dataflow.py for the new implementation.</p>"},{"location":"reference-docs/compiler/machine/#titan.machine","title":"<code>titan.machine</code>","text":""},{"location":"reference-docs/compiler/machine/#titan.machine.Function","title":"<code>Function</code>","text":"<p>Object to represent a function.</p> Source code in <code>titan/machine.py</code> <pre><code>class Function:\n    \"\"\" Object to represent a function.\"\"\"\n    def __init__(self, name, params, body, returns, return_type):\n        \"\"\" Init function for the class.\n\n            Args:\n                name: Name of the function.\n                params: Parameters of the function.\n                body: Body content.\n                returns: Returned values/varaibles.\n                return_type: Types of returned values/varaibles.\n        \"\"\"\n        self.name = name\n        self.params = params\n        self.body = body\n        self.returns = returns\n        self.return_type = return_type\n\n    def __str__(self):\n        return f\"{self.name}, {self.params}, {self.body}, {self.returns} with type {self.return_type}\"\n</code></pre>"},{"location":"reference-docs/compiler/machine/#titan.machine.Function.__init__","title":"<code>__init__(name, params, body, returns, return_type)</code>","text":"<p>Init function for the class.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <p>Name of the function.</p> required <code>params</code> <p>Parameters of the function.</p> required <code>body</code> <p>Body content.</p> required <code>returns</code> <p>Returned values/varaibles.</p> required <code>return_type</code> <p>Types of returned values/varaibles.</p> required Source code in <code>titan/machine.py</code> <pre><code>def __init__(self, name, params, body, returns, return_type):\n    \"\"\" Init function for the class.\n\n        Args:\n            name: Name of the function.\n            params: Parameters of the function.\n            body: Body content.\n            returns: Returned values/varaibles.\n            return_type: Types of returned values/varaibles.\n    \"\"\"\n    self.name = name\n    self.params = params\n    self.body = body\n    self.returns = returns\n    self.return_type = return_type\n</code></pre>"},{"location":"reference-docs/compiler/machine/#titan.machine.Machine","title":"<code>Machine</code>","text":"<p>Class that attempts to wrap the functionality/required components of the compiler.</p> Source code in <code>titan/machine.py</code> <pre><code>class Machine:\n    \"\"\" Class that attempts to wrap the functionality/required components of the compiler.\"\"\"\n\n    def __init__(self, args = None):\n        \"\"\" Init function for Machine.\n\n            Args:\n                args: Arguments from the ``argparse`` library ``parse_args()`` method.\n\n            Attributes:\n                options: List of options that the user provided via the CLI.\n                output_options: List of options that relate to the output of the compiler.\n                processed_text: TODO\n                files: List of files to process.\n                parsed_modules: TODO\n                functions: TODO\n                name_of_top_module: TODO\n                SPIRV_asm_obj: SPIR-V ASM generator object. (unused)\n        \"\"\"\n\n        self._args = args\n        self.options = []   # parsed options (anything but output stuff)\n        self.output_options = []    # parsed outputting options\n        self.processed_text = []    # preprocessed python\n        self.files = []     # file names\n        self.parsed_modules = []\n        self.functions = []\n        self.name_of_top_module = None\n        self.SPIRV_asm_obj: SPIRV_ASM = None\n\n        self._legacy_arg_setter()\n\n    def _legacy_arg_setter(self):\n        \"\"\" Legacy method to set the arguments.\n\n            I changed my mind about the original implementation,\n            so this is a slight work-around.\n        \"\"\"\n\n        if self._args.top is not None:\n            self.options.append(Options.DEFINE_TOP_MODULE)\n            self.name_of_top_module = self._args.top\n\n        if self._args.asm:\n            self.output_options.append(Options.OUTPUT_SPIRV_ASM)\n\n        self.files.append(self._args.source_file)\n</code></pre>"},{"location":"reference-docs/compiler/machine/#titan.machine.Machine.__init__","title":"<code>__init__(args=None)</code>","text":"<p>Init function for Machine.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <p>Arguments from the <code>argparse</code> library <code>parse_args()</code> method.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>options</code> <p>List of options that the user provided via the CLI.</p> <code>output_options</code> <p>List of options that relate to the output of the compiler.</p> <code>processed_text</code> <p>TODO</p> <code>files</code> <p>List of files to process.</p> <code>parsed_modules</code> <p>TODO</p> <code>functions</code> <p>TODO</p> <code>name_of_top_module</code> <p>TODO</p> <code>SPIRV_asm_obj</code> <p>SPIR-V ASM generator object. (unused)</p> Source code in <code>titan/machine.py</code> <pre><code>def __init__(self, args = None):\n    \"\"\" Init function for Machine.\n\n        Args:\n            args: Arguments from the ``argparse`` library ``parse_args()`` method.\n\n        Attributes:\n            options: List of options that the user provided via the CLI.\n            output_options: List of options that relate to the output of the compiler.\n            processed_text: TODO\n            files: List of files to process.\n            parsed_modules: TODO\n            functions: TODO\n            name_of_top_module: TODO\n            SPIRV_asm_obj: SPIR-V ASM generator object. (unused)\n    \"\"\"\n\n    self._args = args\n    self.options = []   # parsed options (anything but output stuff)\n    self.output_options = []    # parsed outputting options\n    self.processed_text = []    # preprocessed python\n    self.files = []     # file names\n    self.parsed_modules = []\n    self.functions = []\n    self.name_of_top_module = None\n    self.SPIRV_asm_obj: SPIRV_ASM = None\n\n    self._legacy_arg_setter()\n</code></pre>"},{"location":"reference-docs/compiler/machine/#titan.machine.SPIRV_ASM","title":"<code>SPIRV_ASM</code>","text":"<p>SPIR-V assembly generator class. </p> Warning <p>No longer used.</p> Source code in <code>titan/machine.py</code> <pre><code>class SPIRV_ASM:\n    \"\"\" SPIR-V assembly generator class. \n\n        Warning:\n            No longer used.\n    \"\"\"\n\n    class Sections(Enum):\n        CAPABILITY_AND_EXTENSION = auto()\n        ENTRY_AND_EXEC_MODES = auto()\n        DEBUG_STATEMENTS = auto()\n        ANNOTATIONS = auto()\n        TYPES_CONSTS_VARS = auto()\n        FUNCTIONS = auto()\n\n    class TypeContext(NamedTuple):\n        primative_type: type.DataType = None\n        storage_type: type.StorageType = None\n        is_constant: bool = False\n        is_pointer: bool = False\n\n    class ConstContext(NamedTuple):\n        primative_type: Union[int, float] = None\n        value: Union[int, float] = None\n\n    def __init__(self):\n        self.generated_spirv = {\n            self.Sections.CAPABILITY_AND_EXTENSION.name: [],\n            self.Sections.ENTRY_AND_EXEC_MODES.name: [],\n            self.Sections.DEBUG_STATEMENTS.name: [],\n            self.Sections.ANNOTATIONS.name: [],\n            self.Sections.TYPES_CONSTS_VARS.name: [],\n            self.Sections.FUNCTIONS.name: []\n        }\n\n        # scuffed type hinting\n        # but using typing.Dict or dict or Dict just throws numerous errors\n        # https://stackoverflow.com/questions/51031757/how-to-type-hint-a-dictionary-with-values-of-different-types\n        class declared_type_dict_hint(TypedDict):\n            type_context: self.TypeContext\n            id: str\n\n        class declared_func_type_dict_hint(TypedDict):\n            type: type.DataType\n            id: str\n\n        class declared_consts_dict_hint(TypedDict):\n            type: self.ConstContext\n            id: str\n\n        class generated_line_dict_hint(TypedDict):\n            id: str\n            type: type.DataType\n\n        self.declared_types: declared_type_dict_hint = {}\n        self.declared_function_types: declared_func_type_dict_hint = {}\n        self.declared_consts: declared_consts_dict_hint = {}\n\n        # lines that were generated as a result of parsing arithmetic, they'll have something like \"%titan_id_0\" as their id\n        self.generated_lines: generated_line_dict_hint = {}\n\n        self.location = 0\n        self.id = 0\n\n\n    def append_code(self, section: Sections, code):\n        self.generated_spirv[section.name].append(code)\n\n    def print_contents(self):\n        logging.debug(f\"---- printing spirv ----\")\n        for section, code in self.generated_spirv.items():\n            logging.debug(f\"{section}\")\n            for entry in code:\n                logging.debug(f\"\\t{entry}\")\n        logging.debug(f\"---- end printing spirv ----\")\n\n    def create_file_as_string(self):\n\n        fake_file = \"\"\n\n        for k, v in self.generated_spirv.items():\n            for line in v:\n                fake_file += f\"{line}\\n\"\n\n        return fake_file\n\n\n    def output_to_file(self, name):\n\n        logging.info(f\"Writing SPIR-V to file ({name}.spvasm)\")\n        with open(f\"{name}.spvasm\", \"w\") as f:\n            for k, v in self.generated_spirv.items():\n                logging.debug(f\"writing {k}\")\n\n                for line in v:\n                    f.write(line)\n                    f.write(f\"\\n\")\n\n\n    # ==== type helper functions ====\n    def type_exists(self, type: TypeContext):\n        # can this be simplified to \"return type in self.declared_types\" ?\n        return True if type in self.declared_types else False\n\n    def add_type(self, type: TypeContext, id: str):\n        self.declared_types[type] = id\n\n    def get_type_id(self, type: TypeContext):\n        return self.declared_types[type]\n\n\n    # ==== function helper functions ====\n    def func_type_exists(self, type: type.DataType):\n        return True if type in self.declared_function_types else False\n\n    def add_func_type(self, type: type.DataType, id: str):\n        self.declared_function_types[type] = id\n\n    def get_func_id(self, type: type.DataType):\n        return self.declared_function_types[type]\n\n\n    # === consts helper functions ===\n    def const_exists(self, const: ConstContext):\n        return True if const in self.declared_consts else False\n\n    def add_const(self, c_ctx: ConstContext, id: str):\n        self.declared_consts[c_ctx] = id\n\n    def get_const_id(self, c_ctx: ConstContext):\n        return self.declared_consts[c_ctx]\n\n\n    # === generated line helper functions ===\n    def line_exists(self, id: str):\n        return True if id in self.generated_lines else False\n\n    def get_line_type(self, id: str):\n        return self.generated_lines[id]\n\n    def add_line(self, id: str, type: type.DataType):\n        self.generated_lines[id] = type\n</code></pre>"},{"location":"reference-docs/compiler/machine/#titan.machine.Verilog_ASM","title":"<code>Verilog_ASM</code>","text":"<p>Verilog code generator object.</p> <p>Contains helper functions to manipuate and generate Verilog source code.</p> Note <p>Verilog and SystemVerilog are used interchangeably throughout this project.</p> Source code in <code>titan/machine.py</code> <pre><code>class Verilog_ASM():\n    \"\"\" Verilog code generator object.\n\n        Contains helper functions to manipuate and generate Verilog source code.\n\n        Note:\n            Verilog and SystemVerilog are used interchangeably throughout this project.\n    \"\"\"\n\n    class Sections(Enum):\n        \"\"\" Enum describing the sections commonly found within Verilog source code.\n        \"\"\"\n        MODULE_NAME = auto()\n        PARAMETER_LIST = auto()\n        PORTS_LIST = auto()\n        BODY = auto()\n        END = auto()\n\n\n    def __init__(self):\n        \"\"\" Init function for Verilog_ASM.\n\n            Attributes:\n                content (TypedDict): Dictionary with name of function as key, and value as ``_VerilogFunctionData``.\n                declared_symbols (List): List of declared symbols.\n                marked_symbols_for_deletion (List): Unused.\n        \"\"\"\n        class function_name_and_data_dict_hint(TypedDict):\n            name: str\n            data: _VerilogFunctionData\n\n        self.content: function_name_and_data_dict_hint = {}\n        self.declared_symbols = []\n        self.marked_symbols_for_deletion = []\n\n\n    ## helper functions\n    def _overwrite_body_nodes(self, fn_name, nodes):\n        new_vfd = _VerilogFunctionData(\n            self.content[fn_name].types,\n            self.content[fn_name].inputs,\n            self.content[fn_name].outputs,\n            nodes\n        )\n\n        self.content[fn_name] = new_vfd\n\n\n    def create_function(self, function_name: str):\n        \"\"\" Method to create a new, empty function tuple.\n\n            Args:\n                function_name: Name of the function.\n        \"\"\"\n        self.content[function_name] = _VerilogFunctionData()\n\n    def add_body_node_to_function(self, fn_name: str, node: d.Node):\n        \"\"\" Add a body node to an existing function.\n\n            Checks if the node exists by using the associated SPIR-V ID, creating it if not.\n            Then appends the node to that SPIR-V ID.\n\n            Args:\n                fn_name: Function to add to.\n                node: Node to add.\n        \"\"\"\n        # self.content[name].body_nodes[node.spirv_id] = node\n        # self.content[name].body_nodes[node.spirv_id].append(node)\n\n        if not self.does_node_exist(fn_name, node.spirv_id):\n            self.content[fn_name].body_nodes[node.spirv_id] = []\n\n        # print(f\"-[Verilog_ASM.add_body_node_to_function] adding {node} with id {node.spirv_id} to function {fn_name}\")\n        self.content[fn_name].body_nodes[node.spirv_id].append(node)\n\n    def add_type_context_to_function(self, fn_name: str, type_id: str, type_context: _VerilogTypeContext):\n        \"\"\" Add a type context to a function.\n\n            Args:\n                fn_name: Function to add to.\n                type_id: ID to associate with the type.\n                type_context: Information about the type.\n        \"\"\"\n        # self.content[function_name].types.append(type_context)\n        self.content[fn_name].types[type_id] = type_context\n\n    def get_type_context_from_function(self, fn_name:str, type_id: str) -&gt; _VerilogTypeContext:\n        \"\"\" Get a type context from a function using a type ID.\n\n            Args:\n                fn_name: Function to add to.\n                type_id: ID of type to query.\n\n            Returns:\n                Context of the type.\n        \"\"\"\n        return self.content[fn_name].types[type_id]\n\n    def type_exists_in_func(self, fn_name: str, type_id: str) -&gt; bool:\n        \"\"\" Check if a type exists for a given function.\n\n            Args:\n                fn_name: Function to check in.\n                type_id: Type ID to check for.\n\n            Returns:\n                True if ID exists in function, else False.\n        \"\"\"\n        # return True if type_id in \n        return True if type_id in self.content[fn_name].types else False\n\n    def add_output_to_function(self, fn_name:str, symbol:str):\n        \"\"\" Add an output to a function.\n\n            Args:\n                fn_name: Function to add to.\n                symbol: Symbol to add.\n        \"\"\"\n        self.content[fn_name].outputs.append(symbol)\n\n    def add_input_to_function(self, fn_name:str, symbol:str):\n        \"\"\" Add an input to a function.\n\n            Args:\n                fn_name: Function to add to.\n                symbol: Symbol to add.\n        \"\"\"\n        self.content[fn_name].inputs.append(symbol)\n\n    def get_datatype_from_id(self, fn_name:str, id:str) -&gt; type.DataType:\n        \"\"\" Return primative type from ID.\n\n            Args:\n                fn_name: Function to check in.\n                id: ID to query.\n\n            Returns:\n                Primative datatype of ID, if exists.\n        \"\"\"\n        return self.content[fn_name].types[id].type\n\n    def get_primative_type_id_from_id(self, fn_name:str, id:str) -&gt; str:\n        \"\"\" Returns the associated primative type ID given an ID of a symbol.\n\n            Can handle pointers too.\n\n            Args:\n                fn_name: Function to fetch from.\n                id: ID to fetch from.\n\n            Returns:\n                Returns primative type ID.\n        \"\"\"\n        x = self.content[fn_name].types[id]\n        if x.is_pointer:\n            return x.alias\n        else:\n            return id\n\n    def does_node_exist(self, fn_name:str, node_id:str) -&gt; bool:\n        \"\"\" Checks if a node exists in a given function.\n\n            Args:\n                fn_name: Function to check in.\n                node_id: Node ID to check for.\n\n            Returns:\n                True if node exists, else False.\n        \"\"\"\n        return True if node_id in self.content[fn_name].body_nodes else False\n\n    def does_node_exist_in_dict(self, node_dict, node_id) -&gt; bool:\n        \"\"\" Checks if a node exists in the node dictionary.\n\n            Args:\n                node_dict: Dictionary containing Nodes.\n                node_id: ID of the node to check for.\n\n            Returns:\n                True if node exists in the node dictionary.\n        \"\"\"\n        return True if node_id in node_dict else False\n\n    def get_node(self, fn_name:str, node_id: str) -&gt; d.Node:\n        \"\"\" Gets the latest node given a node ID in a given function.\n\n            Args:\n                fn_name: Function to check in.\n                node_id: Node ID to check for.\n\n            Returns:\n                Latest node for the given node ID.\n        \"\"\"\n        return self.content[fn_name].body_nodes[node_id][-1]\n\n    def modify_node(self, fn_name:str, target_node_id:str, pos:int,  value_node: d.Node, operation: Operation = Operation.NOP):\n        \"\"\" Modify the parents of a node within a function.\n\n            Args:\n                fn_name: Function to modify node in.\n                target_node_id: Node to modify.\n                pos: Which parent of the node to modify. (0 = left, 1 = right)\n                value_node: New parent node.\n                operation: Operation that the node is performing.\n        \"\"\"\n\n        # self.content[name].body_nodes[target_node_id].update_input(pos, value_node)\n        x = self.get_node(fn_name, target_node_id)\n        # print(x)\n        # print(x.spirv_id)\n\n        # new_ctx = d.NodeContext(\n            # x.spirv_line_no, x.spirv_id, x.type_id, x.input_left, x.input_right, x.operation, x.data\n        # )\n\n        # dirty, maybe need to use a dataclass instead\n        if pos == 0:\n            # new_ctx.input_left = value_node\n            new_ctx = d.NodeContext(\n               x.spirv_line_no, x.spirv_id, x.type_id, value_node, x.input_right, operation, x.data\n        )\n        elif pos == 1:\n            # new_ctx.input_right = value_node\n            new_ctx = d.NodeContext(\n               x.spirv_line_no, x.spirv_id, x.type_id, x.input_left, value_node, operation, x.data\n        )\n\n        self.content[fn_name].body_nodes[target_node_id].append(d.Node(new_ctx))\n\n\n    def _sort_body_nodes_by_tick(self, fn_name: str) -&gt; dict:\n        \"\"\" Sorts the nodes in ascending order (0 -&gt; max).\n\n            Args:\n                fn_name: Name of function to sort nodes for.\n\n            Returns:\n                New dictionary containing sorted nodes, with the tick as the key.\n        \"\"\"\n        tick_dict = {}\n\n        # TODO: can we just use list comprehension on this?\n        for symbols in self.content[fn_name].body_nodes:\n            for node in self.content[fn_name].body_nodes[symbols]:\n\n                if node.tick not in tick_dict.keys():\n                    tick_dict[node.tick] = []\n\n                tick_dict[node.tick].append(node)\n\n        return tick_dict\n\n    @staticmethod\n    def _parent_exists(node: d.Node) -&gt; bool:\n        \"\"\" Check whether the node has any parents.\n\n            Args:\n                node: Node to check parents of.\n\n            Returns:\n                True if any parents exist, else False.\n        \"\"\"\n        return True if node.input_left is not None or node.input_right is not None else False\n\n    @staticmethod\n    def _encode_parents(node: d.Node):\n        \"\"\" Numerically encode the position of the parents.\n\n            Note:\n                - 0: No parents exist.\n                - 1: Left parent exists.\n                - 2: Right parent exists.\n                - 3: Both parents exist.\n\n            Args:\n                node: Node to encode the parents.\n        \"\"\"\n        count = 0\n\n        if node.input_left is not None:\n            count += 1\n        if node.input_right is not None:\n            count += 2\n\n        # if left exists, return 1\n        # if right exists, return 2\n        # if both exist, return 3\n        # if none exist, return 0\n        return count\n\n\n    def generate_dot_graph(self, file_name_suffix: str = \"\", clean_nodes = None):\n        \"\"\" Generates Graphviz dot graphs of the dataflow of a function. Requires the ``graphviz`` package.\n\n            Args:\n                file_name_suffix: String to append to file name.\n                clean_nodes: List of clean nodes. (Optimised list)\n        \"\"\"\n        for key in self.content.keys():\n            dot = graphviz.Digraph(comment=f\"digraph for {key}\", filename=f\"digraph_{key}{file_name_suffix}.dot\", directory=\"dots\") \n            dot.attr(bgcolor=\"gray10\")\n            dot.attr(color=\"white\")\n            dot.attr(fontcolor=\"white\")\n\n            if clean_nodes is None:\n                x = self._sort_body_nodes_by_tick(key)\n            else:\n                x = clean_nodes\n\n            for k in range(0, len(x.keys())):\n            # for k in x.keys():\n                # print(f\"tick: {k}\")\n\n                with dot.subgraph(name=f\"cluster_tick_{k}\") as ds:\n                    ds.attr(style=\"dashed\")\n                    ds.attr(label=f\"tick {k}\")\n\n                    try:\n                        for v in x[k]:\n                            # print(f\"\\t{v}, parents? {self._parent_exists(v)}, pos: {self._encode_parents(v)}\")\n                            current_node_label = f\"{v.spirv_id}_{k}\"\n                            ds.node(current_node_label, f\"{v.spirv_id} at tick {k} \\n({v.operation})\", color=\"white\", fontcolor=\"white\")\n\n                            if self._parent_exists(v):\n                                # check which parents exist\n                                parent_num = self._encode_parents(v)\n                                match parent_num:\n                                    case 1:\n                                        # ds.edge()\n                                        # get parent name/spirv id\n                                        # print(f\"\\t\\tL: {v.input_left.spirv_id} at tick {v.input_left.tick}\")\n                                        parent_id_label = f\"{v.input_left.spirv_id}_{v.input_left.tick}\"\n                                        ds.edge(parent_id_label, current_node_label, color=\"white\")\n\n                                    case 2:\n                                        # print(f\"\\t\\tR: {v.input_right.spirv_id} at tick {v.input_right.tick}\")\n                                        parent_id_label = f\"{v.input_right.spirv_id}_{v.input_right.tick}\"\n                                        ds.edge(parent_id_label, current_node_label, color=\"white\")\n                                    case 3:\n                                        # print(f\"\\t\\tL: {v.input_left.spirv_id} at tick {v.input_left.tick}\")\n                                        # print(f\"\\t\\tR: {v.input_right.spirv_id} at tick {v.input_right.tick}\")\n\n                                        parent_l_id_label = f\"{v.input_left.spirv_id}_{v.input_left.tick}\"\n                                        parent_r_id_label = f\"{v.input_right.spirv_id}_{v.input_right.tick}\"\n\n                                        ds.edge(parent_l_id_label, current_node_label, color=\"white\" if not v.is_comparison else \"green\")\n                                        ds.edge(parent_r_id_label, current_node_label, color=\"white\" if not v.is_comparison else \"red\")\n\n                                        if v.is_comparison:\n                                            parent_compare_id_label = f\"{v.data[0].spirv_id}_{v.data[0].tick}\"\n                                            ds.edge(parent_compare_id_label, current_node_label, color=\"white\")\n\n                                    case _:\n                                        # should be unreachable\n                                        raise Exception(f\"{TitanErrors.UNEXPECTED.value} - got {parent_num} parents, but parents exist.\", TitanErrors.UNEXPECTED.name)\n                    except KeyError:\n                        continue\n\n            # print(dot.source)\n            dot.render(view=False, overwrite_source=True)\n\n\n    def __find_best_parents(self, subject_node: d.Node):\n        \"\"\" Attempt to find the best parents.\n\n            TODO:\n                What's actually defined as being the best parent? AFAIK it was any non-temporary \n                node but will need to double check.\n\n            FIXME:\n                Avoid mixing different returns. This method can either return a single Node or \n                a tuple of Nodes.\n\n            Args:\n                subject_node: Node to determine best parents for.\n\n            Returns:\n                best_node: Best parent (single).\n                best_nodes: Best parents (tuple).\n\n        \"\"\"\n\n        # if the node is a constant declaration, return itself\n        if subject_node.operation in Operation_Type.GENERIC_CONSTANT_DECLARATION:\n          return subject_node\n\n        # if node is a GLOBAL variable and is declared, return itself as being the best (this assumes that it is either an input or output of the function)\n        if subject_node.operation in Operation_Type.GENERIC_VARIABLE_DECLARATION and subject_node.spirv_id in self.declared_symbols:\n            return subject_node\n\n        # if variable is just storing a constant\n        if subject_node.operation is Operation.STORE and subject_node.input_left.operation in Operation_Type.GENERIC_CONSTANT_DECLARATION:\n            return subject_node.input_left\n\n        if subject_node.operation is Operation.STORE:\n            return subject_node.input_left\n\n            # TODO: this is probably just redundant\n            # if subject_node.input_left.operation in Operation_Type.GENERIC_CONSTANT_DECLARATION:\n            #     return subject_node.input_left\n\n            # if subject_node.input_left.operation in Operation_Type.ARITHMETIC:\n            #     return subject_node.input_left\n\n            # if subject_node.input_left.operation in Operation_Type.COMPARISON:\n            #     return subject_node.input_left\n\n        # a non existant id means that it was created for either loading or arithmetic\n        if subject_node.spirv_id not in self.declared_symbols:\n\n            # if a temp id was only created for loading an existing value\n            if subject_node.operation is Operation.LOAD:\n\n                # if subject_node.spirv_id not in self.marked_symbols_for_deletion:\n                    # self.marked_symbols_for_deletion.append(subject_node.spirv_id)\n                    # print(f\"mark node for deletion {subject_node.spirv_id}\")\n\n                return self.__find_best_parents(subject_node.input_left)\n            elif subject_node.operation in Operation_Type.ARITHMETIC:\n                # tandem arithmetic means that this node references a previous node that is also an arithmetic node\n                # for example:\n                # %titan_id_0 = OpIAdd %int %const_3 %const_5\n                # %titan_id_1 = OpIMul %int %titan_id_0 %const_2\n                # \n                # we want to retain the refereced arithmetic node id (%titan_id_0) in this case, because it is the best parent for the left side\n                # so tandem_arith_left will be True\n                tandem_arith_left = True if subject_node.input_left.operation in Operation_Type.ARITHMETIC else False\n                tandem_arith_right = True if subject_node.input_right.operation in Operation_Type.ARITHMETIC else False\n                # print(f\"tal: {tandem_arith_left} - tar: {tandem_arith_right}\")\n\n                if tandem_arith_left and tandem_arith_right:\n                    return (subject_node.input_left, subject_node.input_right)\n                elif tandem_arith_left:\n                    return (subject_node.input_left, self.__find_best_parents(subject_node.input_right))\n                elif tandem_arith_right:\n                    return (self.__find_best_parents(subject_node.input_left), subject_node.input_right)\n                else:\n                    return (self.__find_best_parents(subject_node.input_left), self.__find_best_parents(subject_node.input_right))\n\n            # if its an actual comparison (and not a decision node), find the best parent nodes\n            elif subject_node.operation in Operation_Type.COMPARISON and subject_node.operation is not Operation.DECISION:\n                return (self.__find_best_parents(subject_node.input_left), self.__find_best_parents(subject_node.input_right))\n\n            # if its a decision node, the best node will be the comparison node that just came before it, so return it\n            elif subject_node.operation is Operation.DECISION:\n                return subject_node.data[0] \n\n            elif subject_node.operation in Operation_Type.BITWISE:\n                return (self.__find_best_parents(subject_node.input_left), self.__find_best_parents(subject_node.input_right))\n\n\n    def _eval_parents_for_non_temp_id(self, current_node: d.Node) -&gt; list:\n        \"\"\" Method to evaluate the parents of a node for non-temporary IDs.\n\n            Calls ``titan.machine.__find_best_parents`` internally, kinda acts like a wrapper function\n            to handle the scuffed returns.\n\n            Args:\n                current_node: Node to determine best parents for.\n\n            Returns:\n                The ID(s) of the best parent(s). Can either be a one or two-element list.\n        \"\"\"\n        # a temp id is defined as a LOAD instruction which references an existing symbol\n        # in spirv, this looks something like:\n        #   %1 = OpLoad %type_int %a\n        # where %1 is a temporary id containing the value of %a\n\n        best = self.__find_best_parents(current_node)\n        node_names = []\n\n        # print(f\"BEST EVAL---- {best}\")\n\n        # print(f\"best parents for node {current_node} is:\")\n\n        try:\n            # print(f\"L: {best[0]} ({best[0].spirv_id})\\nR: {best[1]} ({best[1].spirv_id})\")\n            # new_ctx = d.NodeContext(\n            #     current_node.spirv_line_no, current_node.spirv_id,\n            #     current_node.type_id, \n            #     best[0], best[1],\n            #     current_node.operation, current_node.data\n            # )\n            node_names = [best[0].spirv_id, best[1].spirv_id]\n        except:\n            # print(f\"O:{best} ({best.spirv_id})\")\n            # new_ctx = d.NodeContext(\n            #     current_node.spirv_line_no, current_node.spirv_id,\n            #     current_node.type_id, \n            #     best, current_node.input_right,\n            #     current_node.operation, current_node.data\n            # )\n            node_names = [best.spirv_id]\n\n        # return new_ctx\n        return node_names\n\n    def clean_graph(self):\n        \"\"\" Method to remove temporary nodes generated by SPIR-V. \n\n            Does not return anything, overwrites the existing node list.\n        \"\"\"\n        # for function in self.content.keys():\n        #     for symbol in self.content[function].body_nodes.keys():\n        #         for node in self.content[function].body_nodes[symbol]:\n\n        #             is_node_a_declaration = node.operation in Operation_Type.GENERIC_CONSTANT_DECLARATION or node.operation in Operation_Type.GENERIC_VARIABLE_DECLARATION\n\n        #             if not is_node_a_declaration:\n        #                 print(f\"{node.spirv_id} {node.operation} -- {is_node_a_declaration}\")\n        #                 self._eval_parents_for_non_temp_id(node)\n\n\n        def _fetch_last_node(node_dict, node_name: str):\n            if node_name in node_dict:\n                return node_dict[node_name][-1]\n            else:\n                # return None\n                raise Exception(TitanErrors.UNEXPECTED.value, TitanErrors.UNEXPECTED.name)\n\n        def _update_node_dict(node_dict, node_name: str, node_ctx: d.NodeContext):\n            if node_name in node_dict:\n                node_dict[node_name].append(d.Node(node_ctx))\n            else:\n                node_dict[node_name] = [d.Node(node_ctx)]\n\n\n\n        for function in self.content.keys():\n            clean_nodes: _id_and_node_dict_hint = {}\n            # print(self.content[functions].body_nodes)\n            tick_ordered_nodes = self._sort_body_nodes_by_tick(function)\n\n            # print(f\"-[Verilog_ASM.clean_graph] tick_ordered_nodes: {tick_ordered_nodes}\")\n\n            # shift all declarations into the new dict (tick=0, consts + vars)\n            # print('='*10)\n            # handle all nodes at tick = 0\n            for node in tick_ordered_nodes[0]:\n                # print(f\"-[Verilog_ASM.clean_graph] node: {node}\", end=\"\")\n                if node.spirv_id not in clean_nodes:\n                    # print(f\"...was not in clean nodes as was added into {node.spirv_id}\")\n                    clean_nodes[node.spirv_id] = [node]\n                else:\n                    # print(f\"...was appended to {node.spirv_id}\")\n                    clean_nodes[node.spirv_id].append(node)\n            # print('='*10)\n\n            # print(f\"-[Verilog_ASM.clean_graph] clean_nodes: {clean_nodes}\")\n\n            # print()\n            for tick in range(1, len(tick_ordered_nodes.keys())): #TODO: remove .keys() call\n                logging.debug(f\"tick: {tick}\")\n                _debug_str = f\"node: {node}\"\n                for node in tick_ordered_nodes[tick]:\n                    # print(f\"\\tnode: {node}\", end=\"\")\n\n                    if node.spirv_id not in self.declared_symbols and node.operation is Operation.LOAD:\n                        # print(f\"....ignored ({node.spirv_id})\")\n                        _debug_str = _debug_str + f\"....ignored ({node.spirv_id})\"\n                        continue\n\n                    # print()\n                    logging.debug(_debug_str)\n\n                    # if _eval_parents_for_non_temp_id(node) returns a spirv id\n                    # we should just try and reference the latest one in the clean\n                    # nodes dict\n                    # print(f\"--&gt;[Verilog_ASM.clean_graph] current node: {node}\")\n                    logging.debug(f\"current node: {node}\")\n                    best_node_names = self._eval_parents_for_non_temp_id(node)\n                    # print(f\"--&gt;[Verilog_ASM.clean_graph] returned with {best_node_names}\")\n                    logging.debug(f\"returned with {best_node_names}\")\n\n                    if len(best_node_names) == 1:\n                        # print(f\"returned with one node: {best_node_names[0]}\")\n                        logging.debug(f\"returned with one node: {best_node_names[0]}\")\n\n                        if self.does_node_exist_in_dict(clean_nodes, node.spirv_id):\n                            n = _fetch_last_node(clean_nodes, best_node_names[0])\n\n                            new_ctx = d.NodeContext(\n                                node.spirv_line_no, node.spirv_id, node.type_id,\n                                n, None, node.operation, node.data\n                            )\n\n                            _update_node_dict(clean_nodes, node.spirv_id, new_ctx)\n                        else:\n\n                            # print(f\"-[Verilog_ASM.clean_graph] node {node} does not exist in clean dict\")\n\n                            if node.is_comparison:\n                                # accessing the node data should fetch the related comparison line &amp; its info\n                                # we assume that it is in the 0th index\n                                n = _fetch_last_node(clean_nodes, node.data[0].spirv_id)\n\n                                new_ctx = d.NodeContext(\n                                    node.spirv_line_no, node.spirv_id, node.type_id,\n                                    node.input_left, node.input_right,\n                                    node.operation, [n], node.is_comparison\n                                )\n                            else:\n                                # TODO: does this every actually get hit? may be something redundant\n                                new_ctx = d.NodeContext(\n                                    node.spirv_line_no, node.spirv_id, node.type_id,\n                                    node.input_left, node.input_right, \n                                    node.operation, node.data, node.is_comparison\n                                )\n\n                            _update_node_dict(clean_nodes, node.spirv_id, new_ctx)\n\n\n\n                    elif len(best_node_names) == 2:\n                        # print(f\"returned with two nodes: {best_node_names}\")\n                        logging.debug(f\"returned with two nodes: {best_node_names}\")\n                        n1 = _fetch_last_node(clean_nodes, best_node_names[0])\n                        n2 = _fetch_last_node(clean_nodes, best_node_names[1])\n\n                        # print(f\"\\t{n1}\\n\\t{n2}\")\n                        logging.debug(f\"\\tnode 1:{n1}\")\n                        logging.debug(f\"\\tnode 2: {n2}\")\n\n                        new_ctx = d.NodeContext(\n                            node.spirv_line_no, node.spirv_id, node.type_id,\n                            n1, n2, node.operation, node.data\n                        )\n\n                        _update_node_dict(clean_nodes, node.spirv_id, new_ctx)\n                        # if node.spirv_id in clean_nodes:\n                            # clean_nodes[node.spirv_id].append(d.Node(new_ctx))\n                        # else:\n                            # clean_nodes[node.spirv_id] = [d.Node(new_ctx)]\n\n\n            # print(\"=\"*10)\n            # print(clean_nodes)\n            logging.debug(f\"---- symbol dump ----\")\n            for symbol in clean_nodes:\n                logging.debug(symbol)\n                # print(symbol)\n                for node in clean_nodes[symbol]:\n                    # print(f\"\\t{node}\")\n                    logging.debug(f\"\\t{node}\")\n                # print()\n            logging.debug(f\"---- end symbol dump ----\")\n            # print(\"=\"*10)\n\n            # print(type(self.content[function].body_nodes))\n            # self.content[function].body_nodes = clean_nodes\n            self._overwrite_body_nodes(function, clean_nodes)\n</code></pre>"},{"location":"reference-docs/compiler/machine/#titan.machine.Verilog_ASM.Sections","title":"<code>Sections</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Enum describing the sections commonly found within Verilog source code.</p> Source code in <code>titan/machine.py</code> <pre><code>class Sections(Enum):\n    \"\"\" Enum describing the sections commonly found within Verilog source code.\n    \"\"\"\n    MODULE_NAME = auto()\n    PARAMETER_LIST = auto()\n    PORTS_LIST = auto()\n    BODY = auto()\n    END = auto()\n</code></pre>"},{"location":"reference-docs/compiler/machine/#titan.machine.Verilog_ASM.__find_best_parents","title":"<code>__find_best_parents(subject_node)</code>","text":"<p>Attempt to find the best parents.</p> TODO <p>What's actually defined as being the best parent? AFAIK it was any non-temporary  node but will need to double check.</p> FIXME <p>Avoid mixing different returns. This method can either return a single Node or  a tuple of Nodes.</p> <p>Parameters:</p> Name Type Description Default <code>subject_node</code> <code>Node</code> <p>Node to determine best parents for.</p> required <p>Returns:</p> Name Type Description <code>best_node</code> <p>Best parent (single).</p> <code>best_nodes</code> <p>Best parents (tuple).</p> Source code in <code>titan/machine.py</code> <pre><code>def __find_best_parents(self, subject_node: d.Node):\n    \"\"\" Attempt to find the best parents.\n\n        TODO:\n            What's actually defined as being the best parent? AFAIK it was any non-temporary \n            node but will need to double check.\n\n        FIXME:\n            Avoid mixing different returns. This method can either return a single Node or \n            a tuple of Nodes.\n\n        Args:\n            subject_node: Node to determine best parents for.\n\n        Returns:\n            best_node: Best parent (single).\n            best_nodes: Best parents (tuple).\n\n    \"\"\"\n\n    # if the node is a constant declaration, return itself\n    if subject_node.operation in Operation_Type.GENERIC_CONSTANT_DECLARATION:\n      return subject_node\n\n    # if node is a GLOBAL variable and is declared, return itself as being the best (this assumes that it is either an input or output of the function)\n    if subject_node.operation in Operation_Type.GENERIC_VARIABLE_DECLARATION and subject_node.spirv_id in self.declared_symbols:\n        return subject_node\n\n    # if variable is just storing a constant\n    if subject_node.operation is Operation.STORE and subject_node.input_left.operation in Operation_Type.GENERIC_CONSTANT_DECLARATION:\n        return subject_node.input_left\n\n    if subject_node.operation is Operation.STORE:\n        return subject_node.input_left\n\n        # TODO: this is probably just redundant\n        # if subject_node.input_left.operation in Operation_Type.GENERIC_CONSTANT_DECLARATION:\n        #     return subject_node.input_left\n\n        # if subject_node.input_left.operation in Operation_Type.ARITHMETIC:\n        #     return subject_node.input_left\n\n        # if subject_node.input_left.operation in Operation_Type.COMPARISON:\n        #     return subject_node.input_left\n\n    # a non existant id means that it was created for either loading or arithmetic\n    if subject_node.spirv_id not in self.declared_symbols:\n\n        # if a temp id was only created for loading an existing value\n        if subject_node.operation is Operation.LOAD:\n\n            # if subject_node.spirv_id not in self.marked_symbols_for_deletion:\n                # self.marked_symbols_for_deletion.append(subject_node.spirv_id)\n                # print(f\"mark node for deletion {subject_node.spirv_id}\")\n\n            return self.__find_best_parents(subject_node.input_left)\n        elif subject_node.operation in Operation_Type.ARITHMETIC:\n            # tandem arithmetic means that this node references a previous node that is also an arithmetic node\n            # for example:\n            # %titan_id_0 = OpIAdd %int %const_3 %const_5\n            # %titan_id_1 = OpIMul %int %titan_id_0 %const_2\n            # \n            # we want to retain the refereced arithmetic node id (%titan_id_0) in this case, because it is the best parent for the left side\n            # so tandem_arith_left will be True\n            tandem_arith_left = True if subject_node.input_left.operation in Operation_Type.ARITHMETIC else False\n            tandem_arith_right = True if subject_node.input_right.operation in Operation_Type.ARITHMETIC else False\n            # print(f\"tal: {tandem_arith_left} - tar: {tandem_arith_right}\")\n\n            if tandem_arith_left and tandem_arith_right:\n                return (subject_node.input_left, subject_node.input_right)\n            elif tandem_arith_left:\n                return (subject_node.input_left, self.__find_best_parents(subject_node.input_right))\n            elif tandem_arith_right:\n                return (self.__find_best_parents(subject_node.input_left), subject_node.input_right)\n            else:\n                return (self.__find_best_parents(subject_node.input_left), self.__find_best_parents(subject_node.input_right))\n\n        # if its an actual comparison (and not a decision node), find the best parent nodes\n        elif subject_node.operation in Operation_Type.COMPARISON and subject_node.operation is not Operation.DECISION:\n            return (self.__find_best_parents(subject_node.input_left), self.__find_best_parents(subject_node.input_right))\n\n        # if its a decision node, the best node will be the comparison node that just came before it, so return it\n        elif subject_node.operation is Operation.DECISION:\n            return subject_node.data[0] \n\n        elif subject_node.operation in Operation_Type.BITWISE:\n            return (self.__find_best_parents(subject_node.input_left), self.__find_best_parents(subject_node.input_right))\n</code></pre>"},{"location":"reference-docs/compiler/machine/#titan.machine.Verilog_ASM.__init__","title":"<code>__init__()</code>","text":"<p>Init function for Verilog_ASM.</p> <p>Attributes:</p> Name Type Description <code>content</code> <code>TypedDict</code> <p>Dictionary with name of function as key, and value as <code>_VerilogFunctionData</code>.</p> <code>declared_symbols</code> <code>List</code> <p>List of declared symbols.</p> <code>marked_symbols_for_deletion</code> <code>List</code> <p>Unused.</p> Source code in <code>titan/machine.py</code> <pre><code>def __init__(self):\n    \"\"\" Init function for Verilog_ASM.\n\n        Attributes:\n            content (TypedDict): Dictionary with name of function as key, and value as ``_VerilogFunctionData``.\n            declared_symbols (List): List of declared symbols.\n            marked_symbols_for_deletion (List): Unused.\n    \"\"\"\n    class function_name_and_data_dict_hint(TypedDict):\n        name: str\n        data: _VerilogFunctionData\n\n    self.content: function_name_and_data_dict_hint = {}\n    self.declared_symbols = []\n    self.marked_symbols_for_deletion = []\n</code></pre>"},{"location":"reference-docs/compiler/machine/#titan.machine.Verilog_ASM.add_body_node_to_function","title":"<code>add_body_node_to_function(fn_name, node)</code>","text":"<p>Add a body node to an existing function.</p> <p>Checks if the node exists by using the associated SPIR-V ID, creating it if not. Then appends the node to that SPIR-V ID.</p> <p>Parameters:</p> Name Type Description Default <code>fn_name</code> <code>str</code> <p>Function to add to.</p> required <code>node</code> <code>Node</code> <p>Node to add.</p> required Source code in <code>titan/machine.py</code> <pre><code>def add_body_node_to_function(self, fn_name: str, node: d.Node):\n    \"\"\" Add a body node to an existing function.\n\n        Checks if the node exists by using the associated SPIR-V ID, creating it if not.\n        Then appends the node to that SPIR-V ID.\n\n        Args:\n            fn_name: Function to add to.\n            node: Node to add.\n    \"\"\"\n    # self.content[name].body_nodes[node.spirv_id] = node\n    # self.content[name].body_nodes[node.spirv_id].append(node)\n\n    if not self.does_node_exist(fn_name, node.spirv_id):\n        self.content[fn_name].body_nodes[node.spirv_id] = []\n\n    # print(f\"-[Verilog_ASM.add_body_node_to_function] adding {node} with id {node.spirv_id} to function {fn_name}\")\n    self.content[fn_name].body_nodes[node.spirv_id].append(node)\n</code></pre>"},{"location":"reference-docs/compiler/machine/#titan.machine.Verilog_ASM.add_input_to_function","title":"<code>add_input_to_function(fn_name, symbol)</code>","text":"<p>Add an input to a function.</p> <p>Parameters:</p> Name Type Description Default <code>fn_name</code> <code>str</code> <p>Function to add to.</p> required <code>symbol</code> <code>str</code> <p>Symbol to add.</p> required Source code in <code>titan/machine.py</code> <pre><code>def add_input_to_function(self, fn_name:str, symbol:str):\n    \"\"\" Add an input to a function.\n\n        Args:\n            fn_name: Function to add to.\n            symbol: Symbol to add.\n    \"\"\"\n    self.content[fn_name].inputs.append(symbol)\n</code></pre>"},{"location":"reference-docs/compiler/machine/#titan.machine.Verilog_ASM.add_output_to_function","title":"<code>add_output_to_function(fn_name, symbol)</code>","text":"<p>Add an output to a function.</p> <p>Parameters:</p> Name Type Description Default <code>fn_name</code> <code>str</code> <p>Function to add to.</p> required <code>symbol</code> <code>str</code> <p>Symbol to add.</p> required Source code in <code>titan/machine.py</code> <pre><code>def add_output_to_function(self, fn_name:str, symbol:str):\n    \"\"\" Add an output to a function.\n\n        Args:\n            fn_name: Function to add to.\n            symbol: Symbol to add.\n    \"\"\"\n    self.content[fn_name].outputs.append(symbol)\n</code></pre>"},{"location":"reference-docs/compiler/machine/#titan.machine.Verilog_ASM.add_type_context_to_function","title":"<code>add_type_context_to_function(fn_name, type_id, type_context)</code>","text":"<p>Add a type context to a function.</p> <p>Parameters:</p> Name Type Description Default <code>fn_name</code> <code>str</code> <p>Function to add to.</p> required <code>type_id</code> <code>str</code> <p>ID to associate with the type.</p> required <code>type_context</code> <code>_VerilogTypeContext</code> <p>Information about the type.</p> required Source code in <code>titan/machine.py</code> <pre><code>def add_type_context_to_function(self, fn_name: str, type_id: str, type_context: _VerilogTypeContext):\n    \"\"\" Add a type context to a function.\n\n        Args:\n            fn_name: Function to add to.\n            type_id: ID to associate with the type.\n            type_context: Information about the type.\n    \"\"\"\n    # self.content[function_name].types.append(type_context)\n    self.content[fn_name].types[type_id] = type_context\n</code></pre>"},{"location":"reference-docs/compiler/machine/#titan.machine.Verilog_ASM.clean_graph","title":"<code>clean_graph()</code>","text":"<p>Method to remove temporary nodes generated by SPIR-V. </p> <p>Does not return anything, overwrites the existing node list.</p> Source code in <code>titan/machine.py</code> <pre><code>def clean_graph(self):\n    \"\"\" Method to remove temporary nodes generated by SPIR-V. \n\n        Does not return anything, overwrites the existing node list.\n    \"\"\"\n    # for function in self.content.keys():\n    #     for symbol in self.content[function].body_nodes.keys():\n    #         for node in self.content[function].body_nodes[symbol]:\n\n    #             is_node_a_declaration = node.operation in Operation_Type.GENERIC_CONSTANT_DECLARATION or node.operation in Operation_Type.GENERIC_VARIABLE_DECLARATION\n\n    #             if not is_node_a_declaration:\n    #                 print(f\"{node.spirv_id} {node.operation} -- {is_node_a_declaration}\")\n    #                 self._eval_parents_for_non_temp_id(node)\n\n\n    def _fetch_last_node(node_dict, node_name: str):\n        if node_name in node_dict:\n            return node_dict[node_name][-1]\n        else:\n            # return None\n            raise Exception(TitanErrors.UNEXPECTED.value, TitanErrors.UNEXPECTED.name)\n\n    def _update_node_dict(node_dict, node_name: str, node_ctx: d.NodeContext):\n        if node_name in node_dict:\n            node_dict[node_name].append(d.Node(node_ctx))\n        else:\n            node_dict[node_name] = [d.Node(node_ctx)]\n\n\n\n    for function in self.content.keys():\n        clean_nodes: _id_and_node_dict_hint = {}\n        # print(self.content[functions].body_nodes)\n        tick_ordered_nodes = self._sort_body_nodes_by_tick(function)\n\n        # print(f\"-[Verilog_ASM.clean_graph] tick_ordered_nodes: {tick_ordered_nodes}\")\n\n        # shift all declarations into the new dict (tick=0, consts + vars)\n        # print('='*10)\n        # handle all nodes at tick = 0\n        for node in tick_ordered_nodes[0]:\n            # print(f\"-[Verilog_ASM.clean_graph] node: {node}\", end=\"\")\n            if node.spirv_id not in clean_nodes:\n                # print(f\"...was not in clean nodes as was added into {node.spirv_id}\")\n                clean_nodes[node.spirv_id] = [node]\n            else:\n                # print(f\"...was appended to {node.spirv_id}\")\n                clean_nodes[node.spirv_id].append(node)\n        # print('='*10)\n\n        # print(f\"-[Verilog_ASM.clean_graph] clean_nodes: {clean_nodes}\")\n\n        # print()\n        for tick in range(1, len(tick_ordered_nodes.keys())): #TODO: remove .keys() call\n            logging.debug(f\"tick: {tick}\")\n            _debug_str = f\"node: {node}\"\n            for node in tick_ordered_nodes[tick]:\n                # print(f\"\\tnode: {node}\", end=\"\")\n\n                if node.spirv_id not in self.declared_symbols and node.operation is Operation.LOAD:\n                    # print(f\"....ignored ({node.spirv_id})\")\n                    _debug_str = _debug_str + f\"....ignored ({node.spirv_id})\"\n                    continue\n\n                # print()\n                logging.debug(_debug_str)\n\n                # if _eval_parents_for_non_temp_id(node) returns a spirv id\n                # we should just try and reference the latest one in the clean\n                # nodes dict\n                # print(f\"--&gt;[Verilog_ASM.clean_graph] current node: {node}\")\n                logging.debug(f\"current node: {node}\")\n                best_node_names = self._eval_parents_for_non_temp_id(node)\n                # print(f\"--&gt;[Verilog_ASM.clean_graph] returned with {best_node_names}\")\n                logging.debug(f\"returned with {best_node_names}\")\n\n                if len(best_node_names) == 1:\n                    # print(f\"returned with one node: {best_node_names[0]}\")\n                    logging.debug(f\"returned with one node: {best_node_names[0]}\")\n\n                    if self.does_node_exist_in_dict(clean_nodes, node.spirv_id):\n                        n = _fetch_last_node(clean_nodes, best_node_names[0])\n\n                        new_ctx = d.NodeContext(\n                            node.spirv_line_no, node.spirv_id, node.type_id,\n                            n, None, node.operation, node.data\n                        )\n\n                        _update_node_dict(clean_nodes, node.spirv_id, new_ctx)\n                    else:\n\n                        # print(f\"-[Verilog_ASM.clean_graph] node {node} does not exist in clean dict\")\n\n                        if node.is_comparison:\n                            # accessing the node data should fetch the related comparison line &amp; its info\n                            # we assume that it is in the 0th index\n                            n = _fetch_last_node(clean_nodes, node.data[0].spirv_id)\n\n                            new_ctx = d.NodeContext(\n                                node.spirv_line_no, node.spirv_id, node.type_id,\n                                node.input_left, node.input_right,\n                                node.operation, [n], node.is_comparison\n                            )\n                        else:\n                            # TODO: does this every actually get hit? may be something redundant\n                            new_ctx = d.NodeContext(\n                                node.spirv_line_no, node.spirv_id, node.type_id,\n                                node.input_left, node.input_right, \n                                node.operation, node.data, node.is_comparison\n                            )\n\n                        _update_node_dict(clean_nodes, node.spirv_id, new_ctx)\n\n\n\n                elif len(best_node_names) == 2:\n                    # print(f\"returned with two nodes: {best_node_names}\")\n                    logging.debug(f\"returned with two nodes: {best_node_names}\")\n                    n1 = _fetch_last_node(clean_nodes, best_node_names[0])\n                    n2 = _fetch_last_node(clean_nodes, best_node_names[1])\n\n                    # print(f\"\\t{n1}\\n\\t{n2}\")\n                    logging.debug(f\"\\tnode 1:{n1}\")\n                    logging.debug(f\"\\tnode 2: {n2}\")\n\n                    new_ctx = d.NodeContext(\n                        node.spirv_line_no, node.spirv_id, node.type_id,\n                        n1, n2, node.operation, node.data\n                    )\n\n                    _update_node_dict(clean_nodes, node.spirv_id, new_ctx)\n                    # if node.spirv_id in clean_nodes:\n                        # clean_nodes[node.spirv_id].append(d.Node(new_ctx))\n                    # else:\n                        # clean_nodes[node.spirv_id] = [d.Node(new_ctx)]\n\n\n        # print(\"=\"*10)\n        # print(clean_nodes)\n        logging.debug(f\"---- symbol dump ----\")\n        for symbol in clean_nodes:\n            logging.debug(symbol)\n            # print(symbol)\n            for node in clean_nodes[symbol]:\n                # print(f\"\\t{node}\")\n                logging.debug(f\"\\t{node}\")\n            # print()\n        logging.debug(f\"---- end symbol dump ----\")\n        # print(\"=\"*10)\n\n        # print(type(self.content[function].body_nodes))\n        # self.content[function].body_nodes = clean_nodes\n        self._overwrite_body_nodes(function, clean_nodes)\n</code></pre>"},{"location":"reference-docs/compiler/machine/#titan.machine.Verilog_ASM.create_function","title":"<code>create_function(function_name)</code>","text":"<p>Method to create a new, empty function tuple.</p> <p>Parameters:</p> Name Type Description Default <code>function_name</code> <code>str</code> <p>Name of the function.</p> required Source code in <code>titan/machine.py</code> <pre><code>def create_function(self, function_name: str):\n    \"\"\" Method to create a new, empty function tuple.\n\n        Args:\n            function_name: Name of the function.\n    \"\"\"\n    self.content[function_name] = _VerilogFunctionData()\n</code></pre>"},{"location":"reference-docs/compiler/machine/#titan.machine.Verilog_ASM.does_node_exist","title":"<code>does_node_exist(fn_name, node_id)</code>","text":"<p>Checks if a node exists in a given function.</p> <p>Parameters:</p> Name Type Description Default <code>fn_name</code> <code>str</code> <p>Function to check in.</p> required <code>node_id</code> <code>str</code> <p>Node ID to check for.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if node exists, else False.</p> Source code in <code>titan/machine.py</code> <pre><code>def does_node_exist(self, fn_name:str, node_id:str) -&gt; bool:\n    \"\"\" Checks if a node exists in a given function.\n\n        Args:\n            fn_name: Function to check in.\n            node_id: Node ID to check for.\n\n        Returns:\n            True if node exists, else False.\n    \"\"\"\n    return True if node_id in self.content[fn_name].body_nodes else False\n</code></pre>"},{"location":"reference-docs/compiler/machine/#titan.machine.Verilog_ASM.does_node_exist_in_dict","title":"<code>does_node_exist_in_dict(node_dict, node_id)</code>","text":"<p>Checks if a node exists in the node dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>node_dict</code> <p>Dictionary containing Nodes.</p> required <code>node_id</code> <p>ID of the node to check for.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if node exists in the node dictionary.</p> Source code in <code>titan/machine.py</code> <pre><code>def does_node_exist_in_dict(self, node_dict, node_id) -&gt; bool:\n    \"\"\" Checks if a node exists in the node dictionary.\n\n        Args:\n            node_dict: Dictionary containing Nodes.\n            node_id: ID of the node to check for.\n\n        Returns:\n            True if node exists in the node dictionary.\n    \"\"\"\n    return True if node_id in node_dict else False\n</code></pre>"},{"location":"reference-docs/compiler/machine/#titan.machine.Verilog_ASM.generate_dot_graph","title":"<code>generate_dot_graph(file_name_suffix='', clean_nodes=None)</code>","text":"<p>Generates Graphviz dot graphs of the dataflow of a function. Requires the <code>graphviz</code> package.</p> <p>Parameters:</p> Name Type Description Default <code>file_name_suffix</code> <code>str</code> <p>String to append to file name.</p> <code>''</code> <code>clean_nodes</code> <p>List of clean nodes. (Optimised list)</p> <code>None</code> Source code in <code>titan/machine.py</code> <pre><code>def generate_dot_graph(self, file_name_suffix: str = \"\", clean_nodes = None):\n    \"\"\" Generates Graphviz dot graphs of the dataflow of a function. Requires the ``graphviz`` package.\n\n        Args:\n            file_name_suffix: String to append to file name.\n            clean_nodes: List of clean nodes. (Optimised list)\n    \"\"\"\n    for key in self.content.keys():\n        dot = graphviz.Digraph(comment=f\"digraph for {key}\", filename=f\"digraph_{key}{file_name_suffix}.dot\", directory=\"dots\") \n        dot.attr(bgcolor=\"gray10\")\n        dot.attr(color=\"white\")\n        dot.attr(fontcolor=\"white\")\n\n        if clean_nodes is None:\n            x = self._sort_body_nodes_by_tick(key)\n        else:\n            x = clean_nodes\n\n        for k in range(0, len(x.keys())):\n        # for k in x.keys():\n            # print(f\"tick: {k}\")\n\n            with dot.subgraph(name=f\"cluster_tick_{k}\") as ds:\n                ds.attr(style=\"dashed\")\n                ds.attr(label=f\"tick {k}\")\n\n                try:\n                    for v in x[k]:\n                        # print(f\"\\t{v}, parents? {self._parent_exists(v)}, pos: {self._encode_parents(v)}\")\n                        current_node_label = f\"{v.spirv_id}_{k}\"\n                        ds.node(current_node_label, f\"{v.spirv_id} at tick {k} \\n({v.operation})\", color=\"white\", fontcolor=\"white\")\n\n                        if self._parent_exists(v):\n                            # check which parents exist\n                            parent_num = self._encode_parents(v)\n                            match parent_num:\n                                case 1:\n                                    # ds.edge()\n                                    # get parent name/spirv id\n                                    # print(f\"\\t\\tL: {v.input_left.spirv_id} at tick {v.input_left.tick}\")\n                                    parent_id_label = f\"{v.input_left.spirv_id}_{v.input_left.tick}\"\n                                    ds.edge(parent_id_label, current_node_label, color=\"white\")\n\n                                case 2:\n                                    # print(f\"\\t\\tR: {v.input_right.spirv_id} at tick {v.input_right.tick}\")\n                                    parent_id_label = f\"{v.input_right.spirv_id}_{v.input_right.tick}\"\n                                    ds.edge(parent_id_label, current_node_label, color=\"white\")\n                                case 3:\n                                    # print(f\"\\t\\tL: {v.input_left.spirv_id} at tick {v.input_left.tick}\")\n                                    # print(f\"\\t\\tR: {v.input_right.spirv_id} at tick {v.input_right.tick}\")\n\n                                    parent_l_id_label = f\"{v.input_left.spirv_id}_{v.input_left.tick}\"\n                                    parent_r_id_label = f\"{v.input_right.spirv_id}_{v.input_right.tick}\"\n\n                                    ds.edge(parent_l_id_label, current_node_label, color=\"white\" if not v.is_comparison else \"green\")\n                                    ds.edge(parent_r_id_label, current_node_label, color=\"white\" if not v.is_comparison else \"red\")\n\n                                    if v.is_comparison:\n                                        parent_compare_id_label = f\"{v.data[0].spirv_id}_{v.data[0].tick}\"\n                                        ds.edge(parent_compare_id_label, current_node_label, color=\"white\")\n\n                                case _:\n                                    # should be unreachable\n                                    raise Exception(f\"{TitanErrors.UNEXPECTED.value} - got {parent_num} parents, but parents exist.\", TitanErrors.UNEXPECTED.name)\n                except KeyError:\n                    continue\n\n        # print(dot.source)\n        dot.render(view=False, overwrite_source=True)\n</code></pre>"},{"location":"reference-docs/compiler/machine/#titan.machine.Verilog_ASM.get_datatype_from_id","title":"<code>get_datatype_from_id(fn_name, id)</code>","text":"<p>Return primative type from ID.</p> <p>Parameters:</p> Name Type Description Default <code>fn_name</code> <code>str</code> <p>Function to check in.</p> required <code>id</code> <code>str</code> <p>ID to query.</p> required <p>Returns:</p> Type Description <code>DataType</code> <p>Primative datatype of ID, if exists.</p> Source code in <code>titan/machine.py</code> <pre><code>def get_datatype_from_id(self, fn_name:str, id:str) -&gt; type.DataType:\n    \"\"\" Return primative type from ID.\n\n        Args:\n            fn_name: Function to check in.\n            id: ID to query.\n\n        Returns:\n            Primative datatype of ID, if exists.\n    \"\"\"\n    return self.content[fn_name].types[id].type\n</code></pre>"},{"location":"reference-docs/compiler/machine/#titan.machine.Verilog_ASM.get_node","title":"<code>get_node(fn_name, node_id)</code>","text":"<p>Gets the latest node given a node ID in a given function.</p> <p>Parameters:</p> Name Type Description Default <code>fn_name</code> <code>str</code> <p>Function to check in.</p> required <code>node_id</code> <code>str</code> <p>Node ID to check for.</p> required <p>Returns:</p> Type Description <code>Node</code> <p>Latest node for the given node ID.</p> Source code in <code>titan/machine.py</code> <pre><code>def get_node(self, fn_name:str, node_id: str) -&gt; d.Node:\n    \"\"\" Gets the latest node given a node ID in a given function.\n\n        Args:\n            fn_name: Function to check in.\n            node_id: Node ID to check for.\n\n        Returns:\n            Latest node for the given node ID.\n    \"\"\"\n    return self.content[fn_name].body_nodes[node_id][-1]\n</code></pre>"},{"location":"reference-docs/compiler/machine/#titan.machine.Verilog_ASM.get_primative_type_id_from_id","title":"<code>get_primative_type_id_from_id(fn_name, id)</code>","text":"<p>Returns the associated primative type ID given an ID of a symbol.</p> <p>Can handle pointers too.</p> <p>Parameters:</p> Name Type Description Default <code>fn_name</code> <code>str</code> <p>Function to fetch from.</p> required <code>id</code> <code>str</code> <p>ID to fetch from.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Returns primative type ID.</p> Source code in <code>titan/machine.py</code> <pre><code>def get_primative_type_id_from_id(self, fn_name:str, id:str) -&gt; str:\n    \"\"\" Returns the associated primative type ID given an ID of a symbol.\n\n        Can handle pointers too.\n\n        Args:\n            fn_name: Function to fetch from.\n            id: ID to fetch from.\n\n        Returns:\n            Returns primative type ID.\n    \"\"\"\n    x = self.content[fn_name].types[id]\n    if x.is_pointer:\n        return x.alias\n    else:\n        return id\n</code></pre>"},{"location":"reference-docs/compiler/machine/#titan.machine.Verilog_ASM.get_type_context_from_function","title":"<code>get_type_context_from_function(fn_name, type_id)</code>","text":"<p>Get a type context from a function using a type ID.</p> <p>Parameters:</p> Name Type Description Default <code>fn_name</code> <code>str</code> <p>Function to add to.</p> required <code>type_id</code> <code>str</code> <p>ID of type to query.</p> required <p>Returns:</p> Type Description <code>_VerilogTypeContext</code> <p>Context of the type.</p> Source code in <code>titan/machine.py</code> <pre><code>def get_type_context_from_function(self, fn_name:str, type_id: str) -&gt; _VerilogTypeContext:\n    \"\"\" Get a type context from a function using a type ID.\n\n        Args:\n            fn_name: Function to add to.\n            type_id: ID of type to query.\n\n        Returns:\n            Context of the type.\n    \"\"\"\n    return self.content[fn_name].types[type_id]\n</code></pre>"},{"location":"reference-docs/compiler/machine/#titan.machine.Verilog_ASM.modify_node","title":"<code>modify_node(fn_name, target_node_id, pos, value_node, operation=Operation.NOP)</code>","text":"<p>Modify the parents of a node within a function.</p> <p>Parameters:</p> Name Type Description Default <code>fn_name</code> <code>str</code> <p>Function to modify node in.</p> required <code>target_node_id</code> <code>str</code> <p>Node to modify.</p> required <code>pos</code> <code>int</code> <p>Which parent of the node to modify. (0 = left, 1 = right)</p> required <code>value_node</code> <code>Node</code> <p>New parent node.</p> required <code>operation</code> <code>Operation</code> <p>Operation that the node is performing.</p> <code>NOP</code> Source code in <code>titan/machine.py</code> <pre><code>def modify_node(self, fn_name:str, target_node_id:str, pos:int,  value_node: d.Node, operation: Operation = Operation.NOP):\n    \"\"\" Modify the parents of a node within a function.\n\n        Args:\n            fn_name: Function to modify node in.\n            target_node_id: Node to modify.\n            pos: Which parent of the node to modify. (0 = left, 1 = right)\n            value_node: New parent node.\n            operation: Operation that the node is performing.\n    \"\"\"\n\n    # self.content[name].body_nodes[target_node_id].update_input(pos, value_node)\n    x = self.get_node(fn_name, target_node_id)\n    # print(x)\n    # print(x.spirv_id)\n\n    # new_ctx = d.NodeContext(\n        # x.spirv_line_no, x.spirv_id, x.type_id, x.input_left, x.input_right, x.operation, x.data\n    # )\n\n    # dirty, maybe need to use a dataclass instead\n    if pos == 0:\n        # new_ctx.input_left = value_node\n        new_ctx = d.NodeContext(\n           x.spirv_line_no, x.spirv_id, x.type_id, value_node, x.input_right, operation, x.data\n    )\n    elif pos == 1:\n        # new_ctx.input_right = value_node\n        new_ctx = d.NodeContext(\n           x.spirv_line_no, x.spirv_id, x.type_id, x.input_left, value_node, operation, x.data\n    )\n\n    self.content[fn_name].body_nodes[target_node_id].append(d.Node(new_ctx))\n</code></pre>"},{"location":"reference-docs/compiler/machine/#titan.machine.Verilog_ASM.type_exists_in_func","title":"<code>type_exists_in_func(fn_name, type_id)</code>","text":"<p>Check if a type exists for a given function.</p> <p>Parameters:</p> Name Type Description Default <code>fn_name</code> <code>str</code> <p>Function to check in.</p> required <code>type_id</code> <code>str</code> <p>Type ID to check for.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if ID exists in function, else False.</p> Source code in <code>titan/machine.py</code> <pre><code>def type_exists_in_func(self, fn_name: str, type_id: str) -&gt; bool:\n    \"\"\" Check if a type exists for a given function.\n\n        Args:\n            fn_name: Function to check in.\n            type_id: Type ID to check for.\n\n        Returns:\n            True if ID exists in function, else False.\n    \"\"\"\n    # return True if type_id in \n    return True if type_id in self.content[fn_name].types else False\n</code></pre>"},{"location":"reference-docs/compiler/machine/#titan.machine.Verilog_Text","title":"<code>Verilog_Text</code>","text":"<p>Object that provides text writing capabilities for Verilog code.</p> Source code in <code>titan/machine.py</code> <pre><code>class Verilog_Text():\n    \"\"\" Object that provides text writing capabilities for Verilog code.\"\"\"\n\n    class Sections(Enum):\n        \"\"\" Sections of Verilog file.\"\"\"\n        MODULE_AND_PORTS = auto()\n        INTERNAL = auto()\n        ALWAYS_BLOCK = auto()\n        ASSIGNMENTS = auto()\n\n    def __init__(self):\n        \"\"\" Init function for Verilog_Text.\n\n            Attributes:\n                generated_verilog: Dictionary using ``titan.machine.Verilog_Text.Sections`` as keys, a list of code as value.\n        \"\"\"\n        self.generated_verilog = {\n            self.Sections.MODULE_AND_PORTS.name: [],\n            self.Sections.INTERNAL.name: [],\n            self.Sections.ALWAYS_BLOCK.name: [],\n            self.Sections.ASSIGNMENTS.name: []\n        }\n\n    def append_code(self, section: Sections, code:str):\n        \"\"\" Append code to a given section.\n\n            Args:\n                section: Section to append to.\n                code: String to append.\n        \"\"\"\n        self.generated_verilog[section.name].append(code)\n\n    def print_contents(self):\n        \"\"\" Debug function to print all generated Verilog code.\n\n            Dumps every entry in ``generated_verilog``.\n        \"\"\"\n        logging.debug(f\"---- printing generated verilog ---\")\n        for section, code_list in self.generated_verilog.items():\n            logging.debug(f\"{section}\")\n\n            for entry in code_list:\n                logging.debug(f\"{entry}\")\n\n        logging.debug(f\"---- end generated verilog ---\")\n\n    def output_to_file(self, name):\n        \"\"\" Writes the contents of ``generated_verilog`` to a file.\n\n            Args:\n                name: Name to give to file. Automatically appended with \".sv\".\n        \"\"\"\n        logging.info(f\"Writing SystemVerilog to file ({name}.sv)\")\n        with open(f\"{name}.sv\", \"w\") as f:\n            for k, v in self.generated_verilog.items():\n                logging.debug(f\"writing {k}\")\n\n                for line in v:\n                    f.write(line)\n                    f.write(f\"\\n\")\n</code></pre>"},{"location":"reference-docs/compiler/machine/#titan.machine.Verilog_Text.Sections","title":"<code>Sections</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Sections of Verilog file.</p> Source code in <code>titan/machine.py</code> <pre><code>class Sections(Enum):\n    \"\"\" Sections of Verilog file.\"\"\"\n    MODULE_AND_PORTS = auto()\n    INTERNAL = auto()\n    ALWAYS_BLOCK = auto()\n    ASSIGNMENTS = auto()\n</code></pre>"},{"location":"reference-docs/compiler/machine/#titan.machine.Verilog_Text.__init__","title":"<code>__init__()</code>","text":"<p>Init function for Verilog_Text.</p> <p>Attributes:</p> Name Type Description <code>generated_verilog</code> <p>Dictionary using <code>titan.machine.Verilog_Text.Sections</code> as keys, a list of code as value.</p> Source code in <code>titan/machine.py</code> <pre><code>def __init__(self):\n    \"\"\" Init function for Verilog_Text.\n\n        Attributes:\n            generated_verilog: Dictionary using ``titan.machine.Verilog_Text.Sections`` as keys, a list of code as value.\n    \"\"\"\n    self.generated_verilog = {\n        self.Sections.MODULE_AND_PORTS.name: [],\n        self.Sections.INTERNAL.name: [],\n        self.Sections.ALWAYS_BLOCK.name: [],\n        self.Sections.ASSIGNMENTS.name: []\n    }\n</code></pre>"},{"location":"reference-docs/compiler/machine/#titan.machine.Verilog_Text.append_code","title":"<code>append_code(section, code)</code>","text":"<p>Append code to a given section.</p> <p>Parameters:</p> Name Type Description Default <code>section</code> <code>Sections</code> <p>Section to append to.</p> required <code>code</code> <code>str</code> <p>String to append.</p> required Source code in <code>titan/machine.py</code> <pre><code>def append_code(self, section: Sections, code:str):\n    \"\"\" Append code to a given section.\n\n        Args:\n            section: Section to append to.\n            code: String to append.\n    \"\"\"\n    self.generated_verilog[section.name].append(code)\n</code></pre>"},{"location":"reference-docs/compiler/machine/#titan.machine.Verilog_Text.output_to_file","title":"<code>output_to_file(name)</code>","text":"<p>Writes the contents of <code>generated_verilog</code> to a file.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <p>Name to give to file. Automatically appended with \".sv\".</p> required Source code in <code>titan/machine.py</code> <pre><code>def output_to_file(self, name):\n    \"\"\" Writes the contents of ``generated_verilog`` to a file.\n\n        Args:\n            name: Name to give to file. Automatically appended with \".sv\".\n    \"\"\"\n    logging.info(f\"Writing SystemVerilog to file ({name}.sv)\")\n    with open(f\"{name}.sv\", \"w\") as f:\n        for k, v in self.generated_verilog.items():\n            logging.debug(f\"writing {k}\")\n\n            for line in v:\n                f.write(line)\n                f.write(f\"\\n\")\n</code></pre>"},{"location":"reference-docs/compiler/machine/#titan.machine.Verilog_Text.print_contents","title":"<code>print_contents()</code>","text":"<p>Debug function to print all generated Verilog code.</p> <p>Dumps every entry in <code>generated_verilog</code>.</p> Source code in <code>titan/machine.py</code> <pre><code>def print_contents(self):\n    \"\"\" Debug function to print all generated Verilog code.\n\n        Dumps every entry in ``generated_verilog``.\n    \"\"\"\n    logging.debug(f\"---- printing generated verilog ---\")\n    for section, code_list in self.generated_verilog.items():\n        logging.debug(f\"{section}\")\n\n        for entry in code_list:\n            logging.debug(f\"{entry}\")\n\n    logging.debug(f\"---- end generated verilog ---\")\n</code></pre>"},{"location":"reference-docs/compiler/main/","title":"Documentation for <code>main</code>","text":""},{"location":"reference-docs/compiler/main/#titan.main","title":"<code>titan.main</code>","text":""},{"location":"reference-docs/compiler/main/#titan.main.main","title":"<code>main()</code>","text":"<p>Entry point for the program.</p> <p>Calls to handle CLI options, parsing, generating and writing.</p> Source code in <code>titan/main.py</code> <pre><code>def main():\n    \"\"\" Entry point for the program.\n\n        Calls to handle CLI options, parsing, generating and writing.\n    \"\"\"\n    logging.basicConfig(\n        level=logging.DEBUG,\n        handlers=[\n            logging.FileHandler(\"compiler_log.txt\"),\n            logging.StreamHandler()\n        ],\n        format=f\"[%(levelname)s] [%(module)s.%(funcName)s, line: %(lineno)d]: %(message)s\"\n    )\n\n    logging.info(f\"--- New run, time is: {datetime.datetime.now().strftime('%d/%m/%Y %H:%M:%S')} ---\")\n    logging.debug(f\"Arguments: {sys.argv}\")\n\n    parser = argparse.ArgumentParser(\n        description = \"Compile a subset of Python into SystemVerilog. Visit https://titan-compiler-project.github.io/titan for more info.\"\n    )\n\n    parser.add_argument(\"source_file\", help=\"python source file to compile\")\n    parser.add_argument(\"-t\", \"--top\", help=\"specify the top function\")\n    parser.add_argument(\"-asm\", help=\"output the SPIR-V assembly code\", action=\"store_true\")\n\n    args = parser.parse_args()\n    logging.info(f\"args: {args}\")\n\n    machine_object = machine.Machine(args)\n    # machine_object.set_args(args)\n\n    symbol_table = symbols.SymbolTable()\n\n    # argument parse call and error handle\n    # if len(sys.argv[1:]) == 0:\n    #     logging.error(\"Got no arguments. Exiting.\")\n    #     return -1\n    # else:\n    #     try:\n    #         common.options.parse_options(machine_object, sys.argv)\n    #     except Exception as err:\n    #         logging.error(f\"{err.args[0]} ({err.args[1]})\")\n    #         return -1                    \n\n    # handle python -&gt; spirv\n    # parse.preprocess(machine_object)\n    # parse.parse_processed_python(machine_object)\n    # generate.generate_symbols(machine_object, symbol_table)\n    # generate.generate_spirv_asm(machine_object, symbol_table)\n\n    # handle spirv -&gt; verilog\n    # parse_result = parse.parse_spriv(machine_object)\n\n\n    logging.info(f\"Generating SPIR-V from {machine_object.files[0]} ...\")\n    # assumes that there is only one file\n    input_python_file = machine_object.files[0]\n    x = ast_crawl.GenerateSPIRVFromAST(input_python_file)\n    x.crawl() # generates spirv TODO: rename function probably\n\n    if args.asm:\n        x.output_to_file(os.path.basename(machine_object.files[0])[:-3])\n\n    parse_result = None\n    with io.StringIO(x.create_file_as_string()) as y:\n        parse_result = parse.TitanSPIRVGrammar.spirv_body.parse_file(y)\n\n    logging.info(f\"Generating RTL...\")\n    generate.generate_verilog(parse_result)\n</code></pre>"},{"location":"reference-docs/compiler/parse/","title":"Documentation for <code>parse</code>","text":"<p>Warning</p> <p>Some portions of this file are no longer used, due to switching to Python's AST module. Therefore only the SPIR-V related functions are documented.</p>"},{"location":"reference-docs/compiler/parse/#titan.parse.parse_spriv","title":"<code>titan.parse.parse_spriv(m)</code>","text":"<p>Reads SPIR-V and parses it using <code>pyparsing</code>.</p> <p>Slightly convoluted method since it does not read from a file, but rather creates an IO object and gets used when reading the SPIR-V assembly from an internal object.</p> TODO <p>Fix function name typo.</p> <p>Returns:</p> Type Description <p>Pyparsing parse result for SPIR-V assembly.</p> Source code in <code>titan/parse.py</code> <pre><code>def parse_spriv(m: machine.Machine):\n    \"\"\" Reads SPIR-V and parses it using ``pyparsing``.\n\n        Slightly convoluted method since it does not read from a file, but rather\n        creates an IO object and gets used when reading the SPIR-V assembly from an\n        internal object.\n\n        TODO:\n            Fix function name typo.\n\n        Args:\n            Machine object containing SPIR-V object that contains the SPIR-V assembly code.\n\n        Returns:\n            Pyparsing parse result for SPIR-V assembly.\n    \"\"\"\n    # creates file in memory using what has already been generated\n    with io.StringIO(m.SPIRV_asm_obj.create_file_as_string()) as x:\n        # applies grammar\n        parse_result = TitanSPIRVGrammar.spirv_body.parse_file(x)\n\n    return parse_result\n</code></pre>"},{"location":"reference-docs/compiler/common/errors/","title":"Documentation for <code>errors.py</code>","text":""},{"location":"reference-docs/compiler/common/errors/#titan.common.errors","title":"<code>titan.common.errors</code>","text":""},{"location":"reference-docs/compiler/common/errors/#titan.common.errors.LoggedException","title":"<code>LoggedException</code>","text":"<p>             Bases: <code>Exception</code></p> <p>An exception that also logs the message to the given logger.</p> Source code in <code>titan/common/errors.py</code> <pre><code>class LoggedException(Exception):\n    \"\"\" An exception that also logs the message to the given logger. \"\"\"\n    def __init__(self, logger: logging.Logger, msg: str):\n        logger.error(msg)\n        super().__init__(msg)\n</code></pre>"},{"location":"reference-docs/compiler/common/errors/#titan.common.errors.TitanErrors","title":"<code>TitanErrors</code>","text":"<p>             Bases: <code>Enum</code></p> <p>A collection of symbolic names for errors, and associated error messages.</p> Source code in <code>titan/common/errors.py</code> <pre><code>class TitanErrors(Enum):\n    \"\"\" A collection of symbolic names for errors, and associated error messages.\"\"\"\n\n    PARSE_BAD_OPTION = \"unknown option\"\n    PARSE_OPTION_FAILURE = \"unable to parse option\" \n    NON_EXISTENT_FILE = \"file does not exist or could not be found\"\n    NO_PARSED_SOURCE_CODE = \"no parsed source code to generate SPIR-V from\"\n    UNDEFINED_TOP_MODULE = \"undefined top module when there are multiple modules, use the -t option to set the top\"\n    PARSED_UNKNOWN_TYPE = \"got unknown type while trying to generate SPIR-V\"\n    NOT_IMPLEMENTED = \"feature not implemented (yet)\"\n    TYPE_EXTRACT_FAILED = \"unable to extract type\"\n    UNKNOWN_TYPE_EXTRACTED = \"got unknown type while extracting\"\n    UNKNOWN_TYPE_IN_ARITHMETIC = \"got unknown type whilst parsing arithmetic\"\n    TYPE_MISMATCH = \"type mismatch\"\n    UNKNOWN_OPERATOR_DURING_GENERATION = \"got unknown operator whilst trying to generate opcode\"\n    UNKNOWN_TYPE_DURING_GENERATION = \"got unknown type when trying to generate opcode\"\n    NON_EXISTENT_SYMBOL = \"symbol does not exist\"\n    UNKNOWN_SPIRV_OPCODE = \"unknown SPIR-V opcode\"\n    UNEXPECTED = \"unexpected exception\"\n    BAD_TYPES = \"bad/unsupported type(s) for operation\"\n</code></pre>"},{"location":"reference-docs/compiler/common/grammar/","title":"Documentation for <code>grammar.py</code>","text":""},{"location":"reference-docs/compiler/common/grammar/#titan.common.grammar","title":"<code>titan.common.grammar</code>","text":""},{"location":"reference-docs/compiler/common/grammar/#titan.common.grammar.TitanPythonGrammar","title":"<code>TitanPythonGrammar</code>","text":"<p>             Bases: <code>NamedTuple</code></p> <p>Grammar for parsing Python.</p> Warning <p>This has been deprecated in favour for Python's AST module. This grammar should not be used at all.</p> Source code in <code>titan/common/grammar.py</code> <pre><code>class TitanPythonGrammar(NamedTuple):\n    \"\"\" Grammar for parsing Python.\n\n        Warning:\n            This has been deprecated in favour for Python's AST module. This grammar should not be used at all.\n    \"\"\"\n\n    # keywords\n    keyword_def = pp.Keyword(\"def\")\n    keyword_return = pp.Keyword(\"return\")\n    keyword_None = pp.Keyword(\"None\")\n\n    function_name = pp.pyparsing_common.identifier\n    variable_name = pp.pyparsing_common.identifier\n\n    # symbols\n    l_br, r_br = map(pp.Literal, \"()\")\n    l_cbr, r_cbr = map(pp.Literal, \"{}\")\n    colon = pp.Literal(\":\")\n    semicolon = pp.Literal(\";\")\n    return_arrow = pp.Literal(\"-&gt;\")\n\n    number = pp.pyparsing_common.number\n\n    type = pp.one_of([\"int\", \"float\", \"bool\"])\n\n    parameter_with_type_hint = pp.Group(variable_name.set_results_name(\"parameter\") + colon.suppress() + type.set_results_name(\"type\"))\n    function_parameter_list_with_type_hint = pp.delimited_list(parameter_with_type_hint) | pp.empty\n\n    function_parameter_list = pp.delimited_list(variable_name) | pp.empty\n    function_return_list = pp.Group(pp.delimited_list(variable_name | number | keyword_None))\n    function_call = function_name + l_br + function_parameter_list + r_br\n    # function_definition = keyword_def.suppress() + function_name.set_results_name(\"function_name\") + l_br.suppress() + function_parameter_list.set_results_name(\"function_param_list\") + r_br.suppress() + colon.suppress()\n    function_definition = keyword_def.suppress() + function_name.set_results_name(\"function_name\") + l_br.suppress() + function_parameter_list_with_type_hint.set_results_name(\"function_param_list\") + r_br.suppress() + return_arrow.suppress() + (type | keyword_None).set_results_name(\"function_return_type\") + colon.suppress()\n\n    # TODO: this doesn't like parsing \"a + b - 3\" or anything that isn't nicely seperated by brackets\n    #       - tried the github ver down below but it also has the same issue, the operators.py file needs to be looked at\n    # precendece reference for the comparison operators https://en.cppreference.com/w/c/language/operator_precedence\n    # TODO: perhaps this should have its name changed, it is no longer only handling only arithmetic, but also comparison and bitwise operators\n    arithmetic_expression = pp.infix_notation(variable_name | number, [\n        (\"-\", 1, pp.OpAssoc.RIGHT, o.UnaryOp),\n        (\"~\", 1, pp.OpAssoc.RIGHT, o.UnaryOp),\n        (pp.one_of(\"* /\"), 2, pp.OpAssoc.LEFT, o.BinaryOp),\n        (pp.one_of(\"+ -\"), 2, pp.OpAssoc.LEFT, o.BinaryOp),\n        (pp.one_of(\"&amp; | ^\"), 2, pp.OpAssoc.LEFT, o.BinaryOp),\n        (pp.one_of(\"&lt; &lt;= &gt;= &gt; == !=\"), 2, pp.OpAssoc.LEFT, o.BinaryOp),\n        (pp.one_of(\"&lt;&lt; &gt;&gt;\"), 2, pp.OpAssoc.LEFT, o.BinaryOp)\n    ])\n\n    # TODO: should these be separate or merged with the arithmetic_expression object\n    bitwise_expression = pp.infix_notation(variable_name | number, [\n        (\"~\", 1, pp.OpAssoc.RIGHT, o.UnaryOp),\n        (pp.one_of(\"&amp; | ^\"), 2, pp.OpAssoc.LEFT, o.BinaryOp)\n    ])\n\n\n    comparison_expression = pp.infix_notation(variable_name | number | arithmetic_expression, [\n        (pp.one_of(\"&lt; &lt;= &gt;= &gt; == !=\"), 2, pp.OpAssoc.LEFT, o.BinaryOp)\n    ])\n\n\n    # combo_expression = arithmetic_expression ^ bitwise_expression ^ comparison_expression\n\n    combo_expression = number ^ variable_name ^ arithmetic_expression\n\n    conditional_ternary_expr = (combo_expression + pp.Literal(\"if\").suppress() + comparison_expression + pp.Literal(\"else\").suppress() + combo_expression).set_parse_action(o.TernaryCondOp)\n\n\n    # https://github.com/pyparsing/pyparsing/blob/master/examples/simpleArith.py\n    # arithmetic_expression = pp.infix_notation(variable_name | number, [\n    #     (pp.one_of(\"+ -\"), 1, pp.OpAssoc.RIGHT, o.UnaryOp),\n    #     (pp.one_of(\"* /\"), 2, pp.OpAssoc.LEFT, o.BinaryOp),\n    #     (pp.one_of(\"+ -\"), 2, pp.OpAssoc.LEFT, o.BinaryOp)\n    # ])\n\n    assignment = (variable_name + \"=\" + (combo_expression ^ conditional_ternary_expr ^ function_call)).set_results_name(\"assignment\")\n    # assignment = (variable_name + \"=\" + (combo_expression | function_call)).set_results_name(\"assignment\")\n\n    # an optional \";\" was added to the end of the statement and function return grammars, this is so that it can still match\n    # when doing the preprocessing step, and when it comes to parsing the file itself\n    # TODO: this might cause issues, maybe split into two seperate variables?\n    statement = (pp.Group(assignment) | pp.Group(function_call)) + pp.Opt(semicolon.suppress())\n\n    function_body = pp.Group(pp.ZeroOrMore(statement)).set_results_name(\"function_statements\") + pp.Optional(keyword_return.suppress()  + function_return_list.set_results_name(\"function_returns\") + pp.Opt(semicolon.suppress()))\n\n    module = pp.ZeroOrMore(\n        pp.Group(\n            function_definition + l_cbr.suppress() + function_body + r_cbr.suppress()\n            )\n    )\n</code></pre>"},{"location":"reference-docs/compiler/common/grammar/#titan.common.grammar.TitanSPIRVGrammar","title":"<code>TitanSPIRVGrammar</code>","text":"<p>             Bases: <code>NamedTuple</code></p> <p>Grammar for parsing SPIR-V assembly.</p> <p>Requires <code>pyparsing</code> to function.</p> Source code in <code>titan/common/grammar.py</code> <pre><code>class TitanSPIRVGrammar(NamedTuple):\n    \"\"\" Grammar for parsing SPIR-V assembly.\n\n        Requires ``pyparsing`` to function.\n    \"\"\"\n\n    pp.ParserElement.set_default_whitespace_chars(\" \\t\")\n    nl = pp.Literal(\"\\n\")\n    eq = pp.Literal(\"=\").suppress()\n    op = pp.Literal(\"Op\").suppress()\n\n    id = pp.Combine(pp.Literal(\"%\") + pp.pyparsing_common.identifier).set_results_name(\"id\")\n    literal_string = pp.quoted_string # https://pyparsing-docs.readthedocs.io/en/latest/HowToUsePyparsing.html?highlight=string#common-string-and-token-constants\n\n    opcode = op + pp.Word(pp.alphanums).set_results_name(\"opcode\")\n\n    opcode_args = pp.Group(pp.delimited_list(\n        pp.ZeroOrMore(id | literal_string | pp.Word(pp.alphanums) | pp.pyparsing_common.number),\n        delim=\" \",\n        allow_trailing_delim=False\n    )).set_results_name(\"opcode_args\")\n\n\n    operation = opcode + pp.Opt(opcode_args) + nl.suppress()\n    assignment = id + eq + operation\n\n    line = pp.Group(operation | assignment)\n\n    spirv_body = pp.ZeroOrMore(\n        line\n    )\n</code></pre>"},{"location":"reference-docs/compiler/common/options/","title":"Documentation for <code>options.py</code>","text":""},{"location":"reference-docs/compiler/common/options/#titan.common.options","title":"<code>titan.common.options</code>","text":""},{"location":"reference-docs/compiler/common/options/#titan.common.options.Options","title":"<code>Options</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Enum containing all valid options.</p> Source code in <code>titan/common/options.py</code> <pre><code>class Options(Enum):\n    \"\"\" Enum containing all valid options.\"\"\"\n    OUTPUT_PREPROCESSED = \"oPP\"\n    OUTPUT_SPIRV_ASM = \"oSA\"\n    DEFINE_TOP_MODULE = \"t\"\n</code></pre>"},{"location":"reference-docs/compiler/common/options/#titan.common.options.parse_options","title":"<code>parse_options(machine_object, args)</code>","text":"<p>Method responsible for parsing the CLI options and assigning them to the appropriate places.</p> TODO <p>This method should get replaced with Python's own <code>argparse</code> library.</p> Source code in <code>titan/common/options.py</code> <pre><code>def parse_options(machine_object, args):\n    \"\"\" Method responsible for parsing the CLI options and assigning them to the appropriate places.\n\n        TODO:\n            This method should get replaced with Python's own ``argparse`` library.\n    \"\"\"\n    got_top_module = False\n    dont_repeat = False\n\n    for i in range(1, len(args)):\n        option = args[i]\n\n        if got_top_module and not dont_repeat:\n            dont_repeat = True\n            continue\n\n        if option[0] == \"-\":\n            option_string = option[1:]\n\n            match option_string:\n                case Options.OUTPUT_PREPROCESSED.value:\n                    machine_object.output_options.append(Options.OUTPUT_PREPROCESSED)\n\n                case Options.OUTPUT_SPIRV_ASM.value:\n                    machine_object.output_options.append(Options.OUTPUT_SPIRV_ASM)\n\n                case Options.DEFINE_TOP_MODULE.value:\n                    machine_object.options.append(Options.DEFINE_TOP_MODULE)\n                    machine_object.name_of_top_module = args[i + 1]\n                    got_top_module = True\n\n                case _:\n                    logging.exception(f\"{common.errors.TitanErrors.PARSE_BAD_OPTION.value} \\\"{option}\\\" ({common.errors.TitanErrors.PARSE_BAD_OPTION.name})\")\n                    raise Exception(f\"{common.errors.TitanErrors.PARSE_BAD_OPTION.value} \\\"{option}\\\" ({common.errors.TitanErrors.PARSE_BAD_OPTION.name})\")\n\n        elif option[-3:] == \".py\":\n            file_exists = Path(option).is_file()\n\n            if file_exists:\n                machine_object.files.append(option)\n            else:\n                logging.exception(f\"{common.errors.TitanErrors.PARSE_OPTION_FAILURE.value} \\\"{option}\\\" ({common.errors.TitanErrors.PARSE_OPTION_FAILURE.name})\")\n                raise Exception(f\"{common.errors.TitanErrors.PARSE_OPTION_FAILURE.value} \\\"{option}\\\" ({common.errors.TitanErrors.PARSE_OPTION_FAILURE.name})\")\n</code></pre>"},{"location":"reference-docs/compiler/common/symbols/","title":"Documentation for <code>symbols.py</code>","text":""},{"location":"reference-docs/compiler/common/symbols/#titan.common.symbols","title":"<code>titan.common.symbols</code>","text":""},{"location":"reference-docs/compiler/common/symbols/#titan.common.symbols.Information","title":"<code>Information</code>","text":"<p>             Bases: <code>NamedTuple</code></p> <p>Tuple to store information about the datatype and what operation is being performed.</p> Source code in <code>titan/common/symbols.py</code> <pre><code>class Information(NamedTuple):\n    \"\"\" Tuple to store information about the datatype and what operation is being performed.\"\"\"\n    datatype: DataType\n    operation: Operation\n</code></pre>"},{"location":"reference-docs/compiler/common/symbols/#titan.common.symbols.LiteralSymbolGroup","title":"<code>LiteralSymbolGroup</code>","text":"<p>             Bases: <code>set</code>, <code>Enum</code></p> <p>Enum containing symbols corresponding to operations.</p> Source code in <code>titan/common/symbols.py</code> <pre><code>class LiteralSymbolGroup(set, Enum):\n    \"\"\" Enum containing symbols corresponding to operations.\"\"\"\n    ARITHMETIC = {\"+\", \"-\", \"*\", \"/\"}\n    COMPARISON = {\"&gt;=\", \"&gt;\", \"&lt;\", \"&lt;=\", \"==\", \"!=\"}\n    BITWISE = {\"&lt;&lt;\" , \"&gt;&gt;\"}\n</code></pre>"},{"location":"reference-docs/compiler/common/symbols/#titan.common.symbols.Operation","title":"<code>Operation</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Enum containing possible operations, such as declaration or arithmetic.</p> Source code in <code>titan/common/symbols.py</code> <pre><code>class Operation(Enum):\n    \"\"\" Enum containing possible operations, such as declaration or arithmetic.\"\"\"\n    # vars\n    VARIABLE_DECLARATION = auto()\n    CONSTANT_DECLARATION = auto()\n    GLOBAL_VAR_DECLARATION = auto()\n    GLOBAL_CONST_DECLARATION = auto()\n\n    # funcs\n    FUNCTION_DECLARATION = auto()\n    FUNCTION_IN_VAR_PARAM = auto()\n    FUNCTION_OUT_VAR_PARAM = auto()\n\n    # operations\n    ASSIGNMENT = auto()\n    STORE = auto()\n    LOAD = auto()\n    ADD = \"+\"\n    SUB = \"-\"\n    MULT = \"*\"\n    DIV = \"/\"\n\n    # comparisons\n    DECISION = auto()\n    LESS_THAN = \"&lt;\"\n    LESS_OR_EQ = \"&lt;=\"\n    GREATER_THAN = \"&gt;\"\n    GREATER_OR_EQ = \"&gt;=\"\n    EQUAL_TO = \"==\"\n    NOT_EQUAL_TO = \"!=\"\n\n    # logical\n    SHIFT_LEFT = \"&lt;&lt;\"\n    SHIFT_RIGHT = \"&gt;&gt;\"\n\n    # misc\n    NOP = auto()\n</code></pre>"},{"location":"reference-docs/compiler/common/symbols/#titan.common.symbols.Operation_Type","title":"<code>Operation_Type</code>","text":"<p>             Bases: <code>set</code>, <code>Enum</code></p> <p>Enum containing sets of <code>titan.common.symbols.Operation</code>, bundled into common groups.</p> Note <p>These groups are:</p> <ul> <li><code>ARITHMETIC</code></li> <li><code>GENERIC_CONSTANT_DECLARATION</code></li> <li><code>GENERIC_VARAIBLE_DECLARATION</code></li> <li><code>COMPARISON</code></li> <li><code>BITWISE</code></li> </ul> Source code in <code>titan/common/symbols.py</code> <pre><code>class Operation_Type(set, Enum):\n    \"\"\" Enum containing sets of ``titan.common.symbols.Operation``, bundled into common groups.\n\n        Note:\n            These groups are:\n\n            - ``ARITHMETIC``\n            - ``GENERIC_CONSTANT_DECLARATION``\n            - ``GENERIC_VARAIBLE_DECLARATION``\n            - ``COMPARISON``\n            - ``BITWISE``\n    \"\"\"\n    ARITHMETIC = {Operation.ADD, Operation.SUB, Operation.MULT, Operation.DIV}\n    GENERIC_CONSTANT_DECLARATION = {Operation.CONSTANT_DECLARATION, Operation.GLOBAL_CONST_DECLARATION}\n    GENERIC_VARIABLE_DECLARATION = {Operation.VARIABLE_DECLARATION, Operation.GLOBAL_VAR_DECLARATION}\n    COMPARISON = {Operation.LESS_THAN, Operation.LESS_OR_EQ, \n                  Operation.GREATER_THAN, Operation.GREATER_OR_EQ, \n                  Operation.EQUAL_TO, Operation.NOT_EQUAL_TO}\n    BITWISE = {Operation.SHIFT_LEFT, Operation.SHIFT_RIGHT}\n</code></pre>"},{"location":"reference-docs/compiler/common/symbols/#titan.common.symbols.SymbolTable","title":"<code>SymbolTable</code>","text":"<p>Simple symbol table class.</p> <p>Attributes:</p> Name Type Description <code>content</code> <p>Dictionary to store the symbols.</p> Source code in <code>titan/common/symbols.py</code> <pre><code>class SymbolTable():\n    \"\"\" Simple symbol table class.\n\n        Attributes:\n            content: Dictionary to store the symbols.\n    \"\"\"\n    # TODO: come up with a better solution -- using a dict for unique\n    # variable names will not work when the scope changes\n    # OR ---- new symbol table every scope change?\n    content = {}\n\n    def __init__(self):\n        pass\n\n    # add entry\n    def add(self, expression, information: Information):\n        \"\"\" Add an entry to the symbol table.\n\n            Args:\n                expression: Symbol to add.\n                information: Store information about the operation.\n        \"\"\"\n        self.content.update({expression: information})\n\n    # delete entry\n    def delete(self, expression):\n        \"\"\" Delete an entry from the symbol table.\n\n            Args:\n                expression: Symbol to delete.\n        \"\"\"\n        del self.content[expression]\n\n    # return using key\n    def get(self, expression) -&gt; Information:\n        \"\"\" Get information about the symbol.\n\n            Args:\n                expression: Symbol to query.\n\n            Returns:\n                Information about the symbol.\n        \"\"\"\n        return self.content.get(expression)\n\n    # if exists bool\n    def exists(self, expression) -&gt; bool:\n        \"\"\" Check if a symbol exists.\n\n            Args:\n                expression: Symbol to check.\n\n            Returns:\n                True if symbol exists, else False.\n        \"\"\"\n        return True if expression in self.content else False\n</code></pre>"},{"location":"reference-docs/compiler/common/symbols/#titan.common.symbols.SymbolTable.add","title":"<code>add(expression, information)</code>","text":"<p>Add an entry to the symbol table.</p> <p>Parameters:</p> Name Type Description Default <code>expression</code> <p>Symbol to add.</p> required <code>information</code> <code>Information</code> <p>Store information about the operation.</p> required Source code in <code>titan/common/symbols.py</code> <pre><code>def add(self, expression, information: Information):\n    \"\"\" Add an entry to the symbol table.\n\n        Args:\n            expression: Symbol to add.\n            information: Store information about the operation.\n    \"\"\"\n    self.content.update({expression: information})\n</code></pre>"},{"location":"reference-docs/compiler/common/symbols/#titan.common.symbols.SymbolTable.delete","title":"<code>delete(expression)</code>","text":"<p>Delete an entry from the symbol table.</p> <p>Parameters:</p> Name Type Description Default <code>expression</code> <p>Symbol to delete.</p> required Source code in <code>titan/common/symbols.py</code> <pre><code>def delete(self, expression):\n    \"\"\" Delete an entry from the symbol table.\n\n        Args:\n            expression: Symbol to delete.\n    \"\"\"\n    del self.content[expression]\n</code></pre>"},{"location":"reference-docs/compiler/common/symbols/#titan.common.symbols.SymbolTable.exists","title":"<code>exists(expression)</code>","text":"<p>Check if a symbol exists.</p> <p>Parameters:</p> Name Type Description Default <code>expression</code> <p>Symbol to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if symbol exists, else False.</p> Source code in <code>titan/common/symbols.py</code> <pre><code>def exists(self, expression) -&gt; bool:\n    \"\"\" Check if a symbol exists.\n\n        Args:\n            expression: Symbol to check.\n\n        Returns:\n            True if symbol exists, else False.\n    \"\"\"\n    return True if expression in self.content else False\n</code></pre>"},{"location":"reference-docs/compiler/common/symbols/#titan.common.symbols.SymbolTable.get","title":"<code>get(expression)</code>","text":"<p>Get information about the symbol.</p> <p>Parameters:</p> Name Type Description Default <code>expression</code> <p>Symbol to query.</p> required <p>Returns:</p> Type Description <code>Information</code> <p>Information about the symbol.</p> Source code in <code>titan/common/symbols.py</code> <pre><code>def get(self, expression) -&gt; Information:\n    \"\"\" Get information about the symbol.\n\n        Args:\n            expression: Symbol to query.\n\n        Returns:\n            Information about the symbol.\n    \"\"\"\n    return self.content.get(expression)\n</code></pre>"},{"location":"reference-docs/compiler/common/type/","title":"Documentation for <code>type.py</code>","text":""},{"location":"reference-docs/compiler/common/type/#titan.common.type","title":"<code>titan.common.type</code>","text":""},{"location":"reference-docs/compiler/common/type/#titan.common.type.DataType","title":"<code>DataType</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Enum to map primative (Python) datatypes onto more abstract keys.</p> Source code in <code>titan/common/type.py</code> <pre><code>class DataType(Enum):\n    \"\"\" Enum to map primative (Python) datatypes onto more abstract keys.\"\"\"\n    VOID = auto()\n    NONE = None\n    INTEGER = int\n    FLOAT = float\n    BOOLEAN = bool\n</code></pre>"},{"location":"reference-docs/compiler/common/type/#titan.common.type.StorageType","title":"<code>StorageType</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Enum to define an analog to SPIR-V's own storage operations.</p> <p>This is required because SPIR-V can define variables as being inputs or outputs, or function variables depending on where they are declared. It's important to keep track of these so that the generated SPIR-V is correct.</p> Source code in <code>titan/common/type.py</code> <pre><code>class StorageType(Enum):\n    \"\"\" Enum to define an analog to SPIR-V's own storage operations.\n\n        This is required because SPIR-V can define variables as being inputs or outputs, or function variables\n        depending on where they are declared. It's important to keep track of these so that the generated SPIR-V\n        is correct.\n    \"\"\"\n    IN = auto()\n    OUT = auto()\n    FUNCTION_VAR = auto()\n    NONE = auto()\n</code></pre>"},{"location":"reference-docs/library/TitanComms.cpp/","title":"Class TitanComms","text":"<p>ClassList &gt; TitanComms</p>"},{"location":"reference-docs/library/TitanComms.cpp/#classes","title":"Classes","text":"Type Name struct u_int24"},{"location":"reference-docs/library/TitanComms.cpp/#public-types","title":"Public Types","text":"Type Name enum instruction"},{"location":"reference-docs/library/TitanComms.cpp/#public-functions","title":"Public Functions","text":"Type Name TitanComms (int cs_pin, SPISettings spi_settings)  void begin ()  void bind_address (u_int24 address)  u_int32_t read (u_int24 address)  void set_core_interrupt (u_int24 address)  void set_stream_read_address (u_int32_t address)  void set_stream_write_address (u_int32_t address)  u_int32_t stream (u_int32_t value)  void write (u_int24 address, u_int32_t value)"},{"location":"reference-docs/library/TitanComms.cpp/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"reference-docs/library/TitanComms.cpp/#enum-instruction","title":"enum instruction","text":"<pre><code>enum TitanComms::instruction {\n    NOP = 0x00,\n    WRITE = 0x01,\n    READ = 0x02,\n    STREAM = 0x03,\n    BIND_INTERRUPT = 0x04,\n    BIND_READ_ADDRESS = 0x05,\n    BIND_WRITE_ADDRESS = 0x06,\n    TRANSFER = 0x07,\n    REPEAT = 0x08,\n    GET_METADATA = 0xFF\n};\n</code></pre>"},{"location":"reference-docs/library/TitanComms.cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"reference-docs/library/TitanComms.cpp/#function-titancomms","title":"function TitanComms","text":"<pre><code>TitanComms::TitanComms (\n    int cs_pin,\n    SPISettings spi_settings\n) \n</code></pre>"},{"location":"reference-docs/library/TitanComms.cpp/#function-begin","title":"function begin","text":"<pre><code>void TitanComms::begin () \n</code></pre>"},{"location":"reference-docs/library/TitanComms.cpp/#function-bind_address","title":"function bind_address","text":"<pre><code>void TitanComms::bind_address (\n    u_int24 address\n) \n</code></pre>"},{"location":"reference-docs/library/TitanComms.cpp/#function-read","title":"function read","text":"<pre><code>u_int32_t TitanComms::read (\n    u_int24 address\n) \n</code></pre>"},{"location":"reference-docs/library/TitanComms.cpp/#function-set_core_interrupt","title":"function set_core_interrupt","text":"<pre><code>void TitanComms::set_core_interrupt (\n    u_int24 address\n) \n</code></pre>"},{"location":"reference-docs/library/TitanComms.cpp/#function-set_stream_read_address","title":"function set_stream_read_address","text":"<pre><code>void TitanComms::set_stream_read_address (\n    u_int32_t address\n) \n</code></pre>"},{"location":"reference-docs/library/TitanComms.cpp/#function-set_stream_write_address","title":"function set_stream_write_address","text":"<pre><code>void TitanComms::set_stream_write_address (\n    u_int32_t address\n) \n</code></pre>"},{"location":"reference-docs/library/TitanComms.cpp/#function-stream","title":"function stream","text":"<pre><code>u_int32_t TitanComms::stream (\n    u_int32_t value\n) \n</code></pre>"},{"location":"reference-docs/library/TitanComms.cpp/#function-write","title":"function write","text":"<pre><code>void TitanComms::write (\n    u_int24 address,\n    u_int32_t value\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>titan/comms/TitanComms/TitanComms.h</code></p>"},{"location":"user-guide/cli-options/","title":"Command Line Options Reference","text":""},{"location":"user-guide/cli-options/#available-options","title":"Available Options","text":"<ul> <li><code>oSA</code> - Output SPIR-V assembly</li> <li><code>oPP</code> - Output pre-processed python file</li> <li><code>t</code> - Define a top module</li> </ul> <p>To use an option simply do <code>python3 titan/main.py -oSA my_cool_file.py</code></p> <p>Note</p> <p>These options may not be fully implemented, take care!</p>"},{"location":"user-guide/cli-options/#source-code","title":"Source Code","text":"<p>             Bases: <code>Enum</code></p> <p>Enum containing all valid options.</p> Source code in <code>titan/common/options.py</code> <pre><code>class Options(Enum):\n    \"\"\" Enum containing all valid options.\"\"\"\n    OUTPUT_PREPROCESSED = \"oPP\"\n    OUTPUT_SPIRV_ASM = \"oSA\"\n    DEFINE_TOP_MODULE = \"t\"\n</code></pre>"},{"location":"user-guide/comms/","title":"Communications","text":"<p>In order to interface with the generated core, we need some method to get data on and off the FPGA itself. It was decided that SPI would be a good fit - it's fairly common, especially on micrcontrollers, and realtively easy to use.</p> <p>SPI connects with a hardware module on the FPGA that is waiting for an instruction &amp; the relevant data to arrive, so that it can set the appropriate buses and coordinate data.</p> <p>An Arduino library (provided by this project) can be used to abstract the communication away into a few simple function calls, helping to improve accessibility. Currently it has been tested on a Teensy 3.2 and the Raspberry Pi Pico.</p>"},{"location":"user-guide/comms/#short-introduction-into-spi","title":"Short introduction into SPI","text":"<p>Serial Protocol Interface (SPI) is a protocol that allows devices to communicate in a synchronous, full-duplex manner. It has 4 pins: clock (CLK), chip select (CS), controller-out-peripheral-in (COPI) and peripheral-out-controller-in (POCI).</p> <p>Three wires are handled by the controller (CLK, CS, COPI) and one by the peripheral (POCI). CLK and CS coordinate the communication, whilst COPI and POCI contain the data which is being transferred across the devices.</p>"},{"location":"user-guide/comms/#custom-protocol","title":"Custom Protocol","text":"<p>Since SPI does not directly define a communications protocol, instead only how it works electrically, it is necessary to outline a protocol that will allow us to communicate with the FPGA.</p> <p>Packets of information can only be 8 bytes long at maximum, being segmented into 1 byte increments.</p> <p>The first byte must be a valid instruction (<code>READ</code>, <code>WRITE</code>, <code>STREAM</code>, <code>BIND_WRITE_ADDRESS</code>, <code>BIND_READ_ADDRESS</code>, <code>TRANSFER</code>, <code>REPEAT</code>), followed up by additional information if required. For example, if you are executing a <code>WRITE</code> instruction, you need to provide a 3-byte address and a 4-byte value which gets written to the address; whilst a <code>READ</code> instruction only requires the 3-byte address as additional data.</p> <p>In theory any device which implements this protocol will be able to communicate with the FPGA, so it isn't limited to only microcontrollers. This could be done on a PC which bit-bangs the wires, though its unlikely to be useful in that context.</p>"},{"location":"user-guide/comms/#arduino-library","title":"Arduino Library","text":"<p>Info</p> <p>The library is currently on the <code>dev</code> branch, under <code>titan/titan/comms/TitanComms</code></p> <p>A very simple Arduino library is provided for use on the Pico or Teensy 3.2 microcontrollers. It provides functionality for reading, writing and streaming to the core.</p> <p>However, it is not necessary to use this library. Any device with an SPI connection that implements the protocol is able to communicate to the core.</p>"},{"location":"user-guide/getting-started/","title":"Getting Started","text":"<p>Warning</p> <p>This is currently a work-in-progress compiler. Please be aware that there will be some bugs stil rumaging around in the code. </p>"},{"location":"user-guide/getting-started/#installing-and-running","title":"Installing and Running","text":"<p>To get started, clone the compiler repository. The <code>master</code> branch usually has builds which are slightly out of date, but should be functioning. The <code>dev</code> branch is more up-to-date, but could be broken. You will need to install <code>pyparsing</code>. </p> <p>Once cloned, execute <code>titan/main.py</code> with the appropriate command line arguments to run the compiler. For example, to compile a file called <code>my_epic_module.sv</code>, we would run <code>python3 titan/main.py my_epic_module.py</code>. </p> <p>There are optional arguments available to modify the behaviour of the compiler. A reference is available here, and also provided below.</p> <p>If the compilation is successful, you will have some SystemVerilog (.sv) files within the directory. You should then be able to import these files into an FPGA project (Altera or Xilinx) and program your device.</p> <p>Info</p> <p>The compiler currently does not automatically generate the necessary interface HDL files, these are available in <code>titan/comms/verilog</code> and can be modified to suit your module. Apologies for the inconvencience. </p> <p>Note</p> <p>If you notice any bugs, feel free to make an issue on GitHub :)</p>"},{"location":"user-guide/getting-started/#subset","title":"Subset","text":"<p>Please ensure that your code fits within the defined subset so that it can be compiled.</p>"},{"location":"user-guide/getting-started/#valid-features","title":"Valid Features","text":"<ul> <li>32-bit integers &amp; floats</li> <li>Booleans</li> <li>Type hints</li> <li>Arithmetic operations</li> <li>Comparison operations</li> </ul>"},{"location":"user-guide/getting-started/#to-do","title":"To-do","text":"<ul> <li> Maps</li> <li> Delayed inputs</li> <li> Limited recursion</li> <li> Automatic interface generation from template</li> <li> Arrays</li> </ul>"},{"location":"user-guide/getting-started/#example-of-a-valid-program","title":"Example of a valid program","text":"<pre><code>def my_cool_adder(a:int, b:int) -&gt; int:\n    return a + b\n</code></pre> <p>Note</p> <p>Type hints are now required.</p>"},{"location":"user-guide/synthesised-modules/","title":"Synthesised Modules","text":"<p>The output of the Titan compiler consists of multiple SystemVerilog source files, which can then be used in conjunction with Quartus/Xilinx/other software to create a bitstream for FPGA programming, or fed through an open-source ASIC flow like OpenLane to generate chip layouts.</p> <p>The core components have been tested on an Altera Cyclone V 5CEFA2F23I7N FPGA dev board from QMTECH. The documentation for this FPGA can be found here.</p> <p>The hierarchy looks something like this: <pre><code>\u251c top\n\u2502 \u251c SPI Interface\n\u2502 \u251c Instruction Handler\n\u2502 \u2514 Core Interface\n\u2502   \u2514 User Module \n</code></pre></p>"},{"location":"user-guide/synthesised-modules/#core-modules","title":"Core Modules","text":""},{"location":"user-guide/synthesised-modules/#spi-interface","title":"SPI Interface","text":"<p>The SPI interface is provided by Coert Vonk, and is available on GitHub. This module exposes 4 wires to the user (CLK, CS, COPI, PICO) which is the only way of getting data in and out of the system. </p>"},{"location":"user-guide/synthesised-modules/#instruction-handler","title":"Instruction Handler","text":"<p>The instruction handler module is responsible for receiving bytes from the SPI interface, and interpreting them. For example, if there is no instruction currently active, then the next byte from the SPI interface must be a valid instruction for the module to perform any action. If a valid instruction byte is received, then the module will wait to receive the remaining bytes before setting any internal buses.</p> <p>Once all of the bytes have been received, internal buses will be set to appropriate values. For example, if we are attemping to write the value <code>0xDE</code> to the address <code>0x04</code> then the instruction handler will wait until the write opcode has been issued (<code>0x01</code>), then wait to receive an additional 7 bytes - 3 for the address, 4 for the value.</p> <p>The instruction bus will be set to <code>0x01</code>, address bus to <code>0x04</code> and the value bus to <code>0xDE</code>. </p> Instruction Opcode Total bytes to send Operation <code>WRITE</code> <code>0x01</code> 8 Write a value to a given address. <code>READ</code> <code>0x02</code> 4 Read a value from the core, onto an internal bus. This is not the same as transferring it across the SPI bus. <code>STREAM</code> <code>0x03</code> 5 Send a value to a predetermined address, and receive one from another. <code>BIND_READ</code> and <code>BIND_WRITE</code> must be issued first, otherwise the data is not valid. <code>BIND_INTERRUPT</code> <code>0x04</code> N/A Not implemented. <code>BIND_READ</code> <code>0x05</code> 4 Set an address which to read from whilst streaming. <code>BIND_WRITE</code> <code>0x06</code> 4 Set an address which to write to whilst streaming. <code>TRANSFER</code> <code>0x07</code> 1 Issue as many times as needed to read a value. Internally increments a pointer that selects a portion of the value to send, due to the 1-byte window of SPI. For a 32-bit value, issue this instruction 4 times. <code>REPEAT</code> <code>0x08</code> 1 Reset the internal data pointer to restart the transfer of data."},{"location":"user-guide/synthesised-modules/#core-interface","title":"Core Interface","text":"<p>The core interface is a wrapper around the user module/core that allows it to interface with the rest of the system. It interprets the current instruction on the bus and will act accordingly if it is being indexed, determined by the start and end range of its address. </p> <p>The core interface provides a memory array for both the inputs and outputs, which are written to by sending instructions. This memory array is directly connected to the inputs and ouputs of the user module, and therefore act similarly to passing parameters to a function in regular code.</p> <p>Currently only one core interface can be instanciated, as the bus does not contain a multiplexer.</p> <p>Each core interface is unique to the user module, as the memory depth must change depending on how many parameters the user wants. Furthermore, the user module is actually instanciated within this module.</p>"},{"location":"user-guide/synthesised-modules/#user-modules","title":"User Modules","text":"<p>The user module is genereated by the Titan compiler, when the user passes through a valid Python-subset source file.</p>"},{"location":"user-guide/compiler/intro/","title":"Introduction","text":"<p>The compiler is split into two sections: the \"frontend\" which takes the Python source file and converts it into SPIR-V, and the \"backend\" which takes the SPIR-V and converts it into SystemVerilog.</p> <p>The \"frontend\" makes use of Python's AST class, in order to parse the syntax into something meaningful. Using AST and its calls to relevant functions, we are able to construct the SPIR-V assembly. These functions can be seen in <code>titan/ast_crawl.py</code>.</p> <p>The \"backend\" uses Pyparsing to parse the SPIR-V assembly file, as no existing module exists for this function. The grammar is rough, but suitable for this usecase.</p> <p>The project structure is a little bit scattered, but slowly everything is getting moved into respective folders so that it is easier to follow.</p> <ul> <li><code>titan/common/</code>  holds files relevant for common tasks, and which are not directly related to compilation</li> <li><code>titan/frontend/</code> will hold files relating to the Python \u2192 SPIR-V compiler</li> <li><code>titan/backend/</code> will hold files relating to the SPIR-V \u2192 SystemVerilog compiler</li> </ul> <p>These are explained more thoroughly in the next chapters.</p>"},{"location":"user-guide/compiler/python-spirv/","title":"Python to SPIR-V","text":"<p>Warning</p> <p>Compatibility with GPUs is not guaranteed!</p> <p>A Python source file is taken as an input to the compiler. It gets parsed and eventually compiled into SPIR-V assembly. The use of SPIR-V allows the frontend and backend of the compiler to be easily swapped out, and for the SPIR-V assembly to also be used on existing parallel hardware, such as GPUs.</p> <p>The parsing of the Python source file is performed by Python's AST module. This module, when supplied with Python source code will transform it into a tree which can be programmatically traversed. This feature means that when the AST module is parsing, calls will be made to various functions depending on the expression.</p> <p>Example</p> <p>If the AST module encounters a function definition, it'll call <code>visit_FunctionDef</code>, or if you have code that is something like <code>a = 4</code>, it'll call <code>visit_Assign</code>. </p> <p>More details available at the Python Docs here.</p> <p>Some additional features (once implemented), such as total functional recursion, will be made available via Python decorators.</p>"},{"location":"user-guide/compiler/python-spirv/#brief-overview-of-functionality","title":"Brief overview of functionality","text":""},{"location":"user-guide/compiler/python-spirv/#functions-calls","title":"Functions &amp; Calls","text":"<p>Calls are currently not supported, however functions can be defined. When compiling a function definition into SPIR-V, debug information and types will be created, as well as parsing of the input and output parameters.</p> <p>Multiple returns are not supported currently, however you can have an abritrary number of inputs. Both the inputs and outputs must have type hints, so that the compiler does not have to guess the type.</p> <p>Once all the information has been created, the compiler will call <code>super().generic_visit(node)</code> to procced further.</p>"},{"location":"user-guide/compiler/python-spirv/#assignments-arithmetic-comparison","title":"Assignments, Arithmetic &amp; Comparison","text":"<p>These operations are handled by <code>titan.ast_crawl.GenerateSPIRVFromAST._eval_line</code>. It is a recursive function that will attempt to parse anything related to arithmetic or comparison operations and return the final line ID and context about the line. During its recursion, it will create any necessary types and context structures which are available to access via the SPIR-V helper class.</p> <p>Nested arithmetic expressions are evaluated with this <code>_eval_line</code> function. On each call, it'll generate an intermediate ID that will store the value of one operation. A combination of these intermediate IDs will create the final result of the calculation.</p> <p>Example</p> <p>An expression like <code>c = a + (b / 2)</code> would first have <code>b / 2</code> evaluated and the result placed into a temporary ID, and then <code>a + temporaryID</code> would get evaluated next.</p> <p>In SPIR-V context, would look something like so: <pre><code>%1 = OpSDiv %type_int %b %const_2\n%2 = OpIAdd %type_int %a %1\nOpStore %c %2\n</code></pre></p> <p>Whilst <code>_eval_line</code> also handles comparison expressions, it does not directly perform any actions. Instead this is handed off to <code>visit_Compare</code> and <code>visit_IfExp</code>. This is done because you may perform a comparison operation outside of an if-expression, so the distinction is necessary.</p>"},{"location":"user-guide/compiler/spirv-systemverilog/","title":"SPIR-V to SystemVerilog","text":"<p>The compiled SPIR-V assembly from the previous stage is passed directly to this stage, without reading or writing to an external file first. To prase the SPIR-V assembly, the compiler makes use of PyParsing. Grammar is defined in <code>titan.grammar.TitanSPIRVGrammar</code>.</p> <p>SPIR-V is returned as a PyParsing object, where each line is then indexed to create a node graph, before generating the SystemVerilog. The graph step is necessary in order to coordinate everything into the correct tick.</p> <p>Within <code>titan.generate.generate_verilog</code> the parsed SPIR-V is handled, and the nodes are constructed using the classes within <code>titan.dataflow</code>.</p>"},{"location":"user-guide/compiler/spirv-systemverilog/#anatomy-of-the-node","title":"Anatomy of the Node","text":"<p>The Node (found in <code>titan.dataflow</code>) is a class that contains information about the node itself, and left/right inputs. These inputs help to link the node with other operations, and will allow us to traverse the node tree once all of the SPIR-V is processed.</p> <p>The node accepts the <code>NodeContext</code> class upon construction, and this sets up all the relevant information. The tick of the node is automatically calculated by evaluating the ticks of the left and right input node, if present. If not, it is set to 0.</p>"},{"location":"TitanComms/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>class TitanComms <ul> <li>struct u_int24 </li> </ul> </li> <li>class VL_NOT_FINAL </li> <li>class Vtop__Syms </li> <li>class Vtop___024root </li> <li>class Vtop___024unit </li> </ul>"},{"location":"TitanComms/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir titan <ul> <li>dir comms <ul> <li>dir TitanComms <ul> <li>file TitanComms.cpp </li> <li>file TitanComms.h </li> <li>file TitanCommsDebug.h </li> </ul> </li> <li>dir verilog <ul> <li>dir tests <ul> <li>dir sim_build <ul> <li>file Vtop.cpp </li> <li>file Vtop.h </li> <li>file Vtop__ALL.cpp </li> <li>file Vtop__Dpi.cpp </li> <li>file Vtop__Dpi.h </li> <li>file Vtop__Syms.cpp </li> <li>file Vtop__Syms.h </li> <li>file Vtop__Trace__0.cpp </li> <li>file Vtop__Trace__0__Slow.cpp </li> <li>file Vtop___024root.h </li> <li>file Vtop___024root__DepSet_h84412442__0.cpp </li> <li>file Vtop___024root__DepSet_h84412442__0__Slow.cpp </li> <li>file Vtop___024root__DepSet_heccd7ead__0.cpp </li> <li>file Vtop___024root__DepSet_heccd7ead__0__Slow.cpp </li> <li>file Vtop___024root__Slow.cpp </li> <li>file Vtop___024unit.h </li> <li>file Vtop___024unit__DepSet_hff17caec__0__Slow.cpp </li> <li>file Vtop___024unit__Slow.cpp </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"TitanComms/classTitanComms/","title":"Class TitanComms","text":"<p>ClassList &gt; TitanComms</p>"},{"location":"TitanComms/classTitanComms/#classes","title":"Classes","text":"Type Name struct u_int24"},{"location":"TitanComms/classTitanComms/#public-types","title":"Public Types","text":"Type Name enum instruction"},{"location":"TitanComms/classTitanComms/#public-functions","title":"Public Functions","text":"Type Name TitanComms (int cs_pin, SPISettings spi_settings)  void begin ()  void bind_address (u_int24 address)  u_int32_t read (u_int24 address)  void set_core_interrupt (u_int24 address)  void set_stream_read_address (u_int32_t address)  void set_stream_write_address (u_int32_t address)  u_int32_t stream (u_int32_t value)  void write (u_int24 address, u_int32_t value)"},{"location":"TitanComms/classTitanComms/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"TitanComms/classTitanComms/#enum-instruction","title":"enum instruction","text":"<pre><code>enum TitanComms::instruction {\n    NOP = 0x00,\n    WRITE = 0x01,\n    READ = 0x02,\n    STREAM = 0x03,\n    BIND_INTERRUPT = 0x04,\n    BIND_READ_ADDRESS = 0x05,\n    BIND_WRITE_ADDRESS = 0x06,\n    TRANSFER = 0x07,\n    REPEAT = 0x08,\n    GET_METADATA = 0xFF\n};\n</code></pre>"},{"location":"TitanComms/classTitanComms/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"TitanComms/classTitanComms/#function-titancomms","title":"function TitanComms","text":"<pre><code>TitanComms::TitanComms (\n    int cs_pin,\n    SPISettings spi_settings\n) \n</code></pre>"},{"location":"TitanComms/classTitanComms/#function-begin","title":"function begin","text":"<pre><code>void TitanComms::begin () \n</code></pre>"},{"location":"TitanComms/classTitanComms/#function-bind_address","title":"function bind_address","text":"<pre><code>void TitanComms::bind_address (\n    u_int24 address\n) \n</code></pre>"},{"location":"TitanComms/classTitanComms/#function-read","title":"function read","text":"<pre><code>u_int32_t TitanComms::read (\n    u_int24 address\n) \n</code></pre>"},{"location":"TitanComms/classTitanComms/#function-set_core_interrupt","title":"function set_core_interrupt","text":"<pre><code>void TitanComms::set_core_interrupt (\n    u_int24 address\n) \n</code></pre>"},{"location":"TitanComms/classTitanComms/#function-set_stream_read_address","title":"function set_stream_read_address","text":"<pre><code>void TitanComms::set_stream_read_address (\n    u_int32_t address\n) \n</code></pre>"},{"location":"TitanComms/classTitanComms/#function-set_stream_write_address","title":"function set_stream_write_address","text":"<pre><code>void TitanComms::set_stream_write_address (\n    u_int32_t address\n) \n</code></pre>"},{"location":"TitanComms/classTitanComms/#function-stream","title":"function stream","text":"<pre><code>u_int32_t TitanComms::stream (\n    u_int32_t value\n) \n</code></pre>"},{"location":"TitanComms/classTitanComms/#function-write","title":"function write","text":"<pre><code>void TitanComms::write (\n    u_int24 address,\n    u_int32_t value\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>titan/comms/TitanComms/TitanComms.h</code></p>"},{"location":"TitanComms/structTitanComms_1_1u__int24/","title":"Struct TitanComms::u_int24","text":"<p>ClassList &gt; TitanComms &gt; u_int24</p>"},{"location":"TitanComms/structTitanComms_1_1u__int24/#public-attributes","title":"Public Attributes","text":"Type Name u_int32_t data"},{"location":"TitanComms/structTitanComms_1_1u__int24/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"TitanComms/structTitanComms_1_1u__int24/#variable-data","title":"variable data","text":"<pre><code>u_int32_t TitanComms::u_int24::data;\n</code></pre> <p>The documentation for this class was generated from the following file <code>titan/comms/TitanComms/TitanComms.h</code></p>"},{"location":"TitanComms/classVL__NOT__FINAL/","title":"Class VL_NOT_FINAL","text":"<p>ClassList &gt; VL_NOT_FINAL</p> <p>Inherits the following classes: VerilatedModel</p>"},{"location":"TitanComms/classVL__NOT__FINAL/#public-attributes","title":"Public Attributes","text":"Type Name VL_IN &amp; in1 VL_IN &amp; in2 VL_IN &amp; in3 VL_IN &amp; in4 VL_OUT &amp; mux_o Vtop___024root *const rootp VL_IN8 &amp; sel_i"},{"location":"TitanComms/classVL__NOT__FINAL/#public-functions","title":"Public Functions","text":"Type Name Vtop (VerilatedContext * contextp, const char * name=\"TOP\")  Vtop (const char * name=\"TOP\")  void eval () Evaluate the model. Application must call when inputs change. void eval_end_step ()  void eval_step () Evaluate when calling multiple units/models per time step. bool eventsPending () Are there scheduled events to handle? void final () Simulation complete, run final blocks. Application must call on completion. const char * hierName () override const const char * modelName () override const const char * name () constRetrieve name of this model instance (as passed to constructor). uint64_t nextTimeSlot () Returns time at next time slot. Aborts if !eventsPending() unsigned threads () override const void trace (VerilatedVcdC * tfp, int levels, int options=0) Trace signals in the model; called by application code. std::unique_ptr&lt; VerilatedTraceConfig &gt; traceConfig () override const virtual ~Vtop () Destroy the model; called (often implicitly) by application code."},{"location":"TitanComms/classVL__NOT__FINAL/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"TitanComms/classVL__NOT__FINAL/#variable-in1","title":"variable in1","text":"<pre><code>VL_IN&amp; VL_NOT_FINAL::in1;\n</code></pre>"},{"location":"TitanComms/classVL__NOT__FINAL/#variable-in2","title":"variable in2","text":"<pre><code>VL_IN&amp; VL_NOT_FINAL::in2;\n</code></pre>"},{"location":"TitanComms/classVL__NOT__FINAL/#variable-in3","title":"variable in3","text":"<pre><code>VL_IN&amp; VL_NOT_FINAL::in3;\n</code></pre>"},{"location":"TitanComms/classVL__NOT__FINAL/#variable-in4","title":"variable in4","text":"<pre><code>VL_IN&amp; VL_NOT_FINAL::in4;\n</code></pre>"},{"location":"TitanComms/classVL__NOT__FINAL/#variable-mux_o","title":"variable mux_o","text":"<pre><code>VL_OUT&amp; VL_NOT_FINAL::mux_o;\n</code></pre>"},{"location":"TitanComms/classVL__NOT__FINAL/#variable-rootp","title":"variable rootp","text":"<pre><code>Vtop___024root* const VL_NOT_FINAL::rootp;\n</code></pre>"},{"location":"TitanComms/classVL__NOT__FINAL/#variable-sel_i","title":"variable sel_i","text":"<pre><code>VL_IN8&amp; VL_NOT_FINAL::sel_i;\n</code></pre>"},{"location":"TitanComms/classVL__NOT__FINAL/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"TitanComms/classVL__NOT__FINAL/#function-vtop-12","title":"function Vtop [1/2]","text":"<pre><code>explicit VL_NOT_FINAL::Vtop (\n    VerilatedContext * contextp,\n    const char * name=\"TOP\"\n) \n</code></pre> <p>Construct the model; called by application code If contextp is null, then the model will use the default global context If name is \"\", then makes a wrapper with a single model invisible with respect to DPI scope names. </p>"},{"location":"TitanComms/classVL__NOT__FINAL/#function-vtop-22","title":"function Vtop [2/2]","text":"<pre><code>explicit VL_NOT_FINAL::Vtop (\n    const char * name=\"TOP\"\n) \n</code></pre>"},{"location":"TitanComms/classVL__NOT__FINAL/#function-eval","title":"function eval","text":"<pre><code>inline void VL_NOT_FINAL::eval () \n</code></pre>"},{"location":"TitanComms/classVL__NOT__FINAL/#function-eval_end_step","title":"function eval_end_step","text":"<pre><code>void VL_NOT_FINAL::eval_end_step () \n</code></pre> <p>Evaluate at end of a timestep for tracing, when using eval_step(). Application must call after all eval() and before time changes. </p>"},{"location":"TitanComms/classVL__NOT__FINAL/#function-eval_step","title":"function eval_step","text":"<pre><code>void VL_NOT_FINAL::eval_step () \n</code></pre>"},{"location":"TitanComms/classVL__NOT__FINAL/#function-eventspending","title":"function eventsPending","text":"<pre><code>bool VL_NOT_FINAL::eventsPending () \n</code></pre>"},{"location":"TitanComms/classVL__NOT__FINAL/#function-final","title":"function final","text":"<pre><code>void VL_NOT_FINAL::final () \n</code></pre>"},{"location":"TitanComms/classVL__NOT__FINAL/#function-hiername","title":"function hierName","text":"<pre><code>const char * VL_NOT_FINAL::hierName () override const\n</code></pre>"},{"location":"TitanComms/classVL__NOT__FINAL/#function-modelname","title":"function modelName","text":"<pre><code>const char * VL_NOT_FINAL::modelName () override const\n</code></pre>"},{"location":"TitanComms/classVL__NOT__FINAL/#function-name","title":"function name","text":"<pre><code>const char * VL_NOT_FINAL::name () const\n</code></pre>"},{"location":"TitanComms/classVL__NOT__FINAL/#function-nexttimeslot","title":"function nextTimeSlot","text":"<pre><code>uint64_t VL_NOT_FINAL::nextTimeSlot () \n</code></pre>"},{"location":"TitanComms/classVL__NOT__FINAL/#function-threads","title":"function threads","text":"<pre><code>unsigned VL_NOT_FINAL::threads () override const\n</code></pre>"},{"location":"TitanComms/classVL__NOT__FINAL/#function-trace","title":"function trace","text":"<pre><code>void VL_NOT_FINAL::trace (\n    VerilatedVcdC * tfp,\n    int levels,\n    int options=0\n) \n</code></pre>"},{"location":"TitanComms/classVL__NOT__FINAL/#function-traceconfig","title":"function traceConfig","text":"<pre><code>std::unique_ptr&lt; VerilatedTraceConfig &gt; VL_NOT_FINAL::traceConfig () override const\n</code></pre>"},{"location":"TitanComms/classVL__NOT__FINAL/#function-vtop","title":"function ~Vtop","text":"<pre><code>virtual VL_NOT_FINAL::~Vtop () \n</code></pre> <p>The documentation for this class was generated from the following file <code>titan/comms/verilog/tests/sim_build/Vtop.h</code></p>"},{"location":"TitanComms/classVtop____Syms/","title":"Class Vtop__Syms","text":"<p>ClassList &gt; Vtop__Syms</p> <p>Inherits the following classes: VerilatedSyms</p>"},{"location":"TitanComms/classVtop____Syms/#public-attributes","title":"Public Attributes","text":"Type Name Vtop___024root TOP VerilatedHierarchy __Vhier bool __Vm_activity   = = falseTrace class for $dump*. uint32_t __Vm_baseCode   = = 0Used by trace routines when tracing multiple models. bool __Vm_didInit   = = false VerilatedMutex __Vm_dumperMutex bool __Vm_dumping   = = false Vtop *const __Vm_modelp VerilatedScope __Vscope_TOP VerilatedScope __Vscope_dut_param_mux VerilatedScope __Vscope_dut_param_mux__uut_pmux"},{"location":"TitanComms/classVtop____Syms/#public-functions","title":"Public Functions","text":"Type Name VerilatedVcdC *__Vm_dumperp VL_GUARDED_BY (__Vm_dumperMutex)  Vtop__Syms (VerilatedContext * contextp, const char * namep, Vtop * modelp)  void _traceDump ()  void _traceDumpClose ()  void _traceDumpOpen ()  const char * name ()  ~Vtop__Syms ()"},{"location":"TitanComms/classVtop____Syms/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"TitanComms/classVtop____Syms/#variable-top","title":"variable TOP","text":"<pre><code>Vtop___024root Vtop__Syms::TOP;\n</code></pre>"},{"location":"TitanComms/classVtop____Syms/#variable-__vhier","title":"variable __Vhier","text":"<pre><code>VerilatedHierarchy Vtop__Syms::__Vhier;\n</code></pre>"},{"location":"TitanComms/classVtop____Syms/#variable-__vm_activity","title":"variable __Vm_activity","text":"<p>Trace class for $dump*. <pre><code>bool Vtop__Syms::__Vm_activity;\n</code></pre></p> <p>Used by trace routines to determine change occurred </p>"},{"location":"TitanComms/classVtop____Syms/#variable-__vm_basecode","title":"variable __Vm_baseCode","text":"<pre><code>uint32_t Vtop__Syms::__Vm_baseCode;\n</code></pre>"},{"location":"TitanComms/classVtop____Syms/#variable-__vm_didinit","title":"variable __Vm_didInit","text":"<pre><code>bool Vtop__Syms::__Vm_didInit;\n</code></pre>"},{"location":"TitanComms/classVtop____Syms/#variable-__vm_dumpermutex","title":"variable __Vm_dumperMutex","text":"<pre><code>VerilatedMutex Vtop__Syms::__Vm_dumperMutex;\n</code></pre>"},{"location":"TitanComms/classVtop____Syms/#variable-__vm_dumping","title":"variable __Vm_dumping","text":"<pre><code>bool Vtop__Syms::__Vm_dumping;\n</code></pre>"},{"location":"TitanComms/classVtop____Syms/#variable-__vm_modelp","title":"variable __Vm_modelp","text":"<pre><code>Vtop* const Vtop__Syms::__Vm_modelp;\n</code></pre>"},{"location":"TitanComms/classVtop____Syms/#variable-__vscope_top","title":"variable __Vscope_TOP","text":"<pre><code>VerilatedScope Vtop__Syms::__Vscope_TOP;\n</code></pre>"},{"location":"TitanComms/classVtop____Syms/#variable-__vscope_dut_param_mux","title":"variable __Vscope_dut_param_mux","text":"<pre><code>VerilatedScope Vtop__Syms::__Vscope_dut_param_mux;\n</code></pre>"},{"location":"TitanComms/classVtop____Syms/#variable-__vscope_dut_param_mux__uut_pmux","title":"variable __Vscope_dut_param_mux__uut_pmux","text":"<pre><code>VerilatedScope Vtop__Syms::__Vscope_dut_param_mux__uut_pmux;\n</code></pre>"},{"location":"TitanComms/classVtop____Syms/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"TitanComms/classVtop____Syms/#function-vl_guarded_by","title":"function VL_GUARDED_BY","text":"<pre><code>VerilatedVcdC *__Vm_dumperp Vtop__Syms::VL_GUARDED_BY (\n    __Vm_dumperMutex\n) \n</code></pre>"},{"location":"TitanComms/classVtop____Syms/#function-vtop__syms","title":"function Vtop__Syms","text":"<pre><code>Vtop__Syms::Vtop__Syms (\n    VerilatedContext * contextp,\n    const char * namep,\n    Vtop * modelp\n) \n</code></pre>"},{"location":"TitanComms/classVtop____Syms/#function-_tracedump","title":"function _traceDump","text":"<pre><code>void Vtop__Syms::_traceDump () \n</code></pre>"},{"location":"TitanComms/classVtop____Syms/#function-_tracedumpclose","title":"function _traceDumpClose","text":"<pre><code>void Vtop__Syms::_traceDumpClose () \n</code></pre>"},{"location":"TitanComms/classVtop____Syms/#function-_tracedumpopen","title":"function _traceDumpOpen","text":"<pre><code>void Vtop__Syms::_traceDumpOpen () \n</code></pre>"},{"location":"TitanComms/classVtop____Syms/#function-name","title":"function name","text":"<pre><code>inline const char * Vtop__Syms::name () \n</code></pre>"},{"location":"TitanComms/classVtop____Syms/#function-vtop__syms_1","title":"function ~Vtop__Syms","text":"<pre><code>Vtop__Syms::~Vtop__Syms () \n</code></pre> <p>The documentation for this class was generated from the following file <code>titan/comms/verilog/tests/sim_build/Vtop__Syms.h</code></p>"},{"location":"TitanComms/classVtop______024root/","title":"Class Vtop___024root","text":"<p>ClassList &gt; Vtop___024root</p> <p>Inherits the following classes: VerilatedModule</p>"},{"location":"TitanComms/classVtop______024root/#public-attributes","title":"Public Attributes","text":"Type Name CData __VactContinue IData __VactIterCount VlTriggerVec&lt; 1 &gt; __VactTriggered VlDelayScheduler __VdlySched IData __VicoIterCount VlTriggerVec&lt; 1 &gt; __VicoTriggered VlTriggerVec&lt; 1 &gt; __VnbaTriggered IData __VstlIterCount VlTriggerVec&lt; 1 &gt; __VstlTriggered VlUnpacked&lt; IData, 4 &gt; dut_param_mux__DOT____Vcellinp__uut_pmux__inputs IData dut_param_mux__DOT__in1 IData dut_param_mux__DOT__in2 IData dut_param_mux__DOT__in3 IData dut_param_mux__DOT__in4 IData dut_param_mux__DOT__mux_o CData dut_param_mux__DOT__sel_i VlUnpacked&lt; IData, 4 &gt; dut_param_mux__DOT__uut_pmux__DOT__inputs IData dut_param_mux__DOT__uut_pmux__DOT__out CData dut_param_mux__DOT__uut_pmux__DOT__selector Vtop__Syms *const vlSymsp"},{"location":"TitanComms/classVtop______024root/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr IData dut_param_mux__DOT__uut_pmux__DOT__INPUT_WIDTH   = = 0x00000020U constexpr IData dut_param_mux__DOT__uut_pmux__DOT__SELECTOR_WIDTH   = = 2U constexpr IData dut_param_mux__DOT__uut_pmux__DOT__SIGNAL_COUNT   = = 4U"},{"location":"TitanComms/classVtop______024root/#public-functions","title":"Public Functions","text":"Type Name VL_IN (in1, 31, 0)  VL_IN (in2, 31, 0)  VL_IN (in3, 31, 0)  VL_IN (in4, 31, 0)  VL_IN8 (sel_i, 1, 0)  VL_OUT (mux_o, 31, 0)  VL_UNCOPYABLE (Vtop___024root)  Vtop___024root (Vtop__Syms * symsp, const char * v__name)  void __Vconfigure (bool first)  ~Vtop___024root ()"},{"location":"TitanComms/classVtop______024root/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"TitanComms/classVtop______024root/#variable-__vactcontinue","title":"variable __VactContinue","text":"<pre><code>CData Vtop___024root::__VactContinue;\n</code></pre>"},{"location":"TitanComms/classVtop______024root/#variable-__vactitercount","title":"variable __VactIterCount","text":"<pre><code>IData Vtop___024root::__VactIterCount;\n</code></pre>"},{"location":"TitanComms/classVtop______024root/#variable-__vacttriggered","title":"variable __VactTriggered","text":"<pre><code>VlTriggerVec&lt;1&gt; Vtop___024root::__VactTriggered;\n</code></pre>"},{"location":"TitanComms/classVtop______024root/#variable-__vdlysched","title":"variable __VdlySched","text":"<pre><code>VlDelayScheduler Vtop___024root::__VdlySched;\n</code></pre>"},{"location":"TitanComms/classVtop______024root/#variable-__vicoitercount","title":"variable __VicoIterCount","text":"<pre><code>IData Vtop___024root::__VicoIterCount;\n</code></pre>"},{"location":"TitanComms/classVtop______024root/#variable-__vicotriggered","title":"variable __VicoTriggered","text":"<pre><code>VlTriggerVec&lt;1&gt; Vtop___024root::__VicoTriggered;\n</code></pre>"},{"location":"TitanComms/classVtop______024root/#variable-__vnbatriggered","title":"variable __VnbaTriggered","text":"<pre><code>VlTriggerVec&lt;1&gt; Vtop___024root::__VnbaTriggered;\n</code></pre>"},{"location":"TitanComms/classVtop______024root/#variable-__vstlitercount","title":"variable __VstlIterCount","text":"<pre><code>IData Vtop___024root::__VstlIterCount;\n</code></pre>"},{"location":"TitanComms/classVtop______024root/#variable-__vstltriggered","title":"variable __VstlTriggered","text":"<pre><code>VlTriggerVec&lt;1&gt; Vtop___024root::__VstlTriggered;\n</code></pre>"},{"location":"TitanComms/classVtop______024root/#variable-dut_param_mux__dot____vcellinp__uut_pmux__inputs","title":"variable dut_param_mux__DOT____Vcellinp__uut_pmux__inputs","text":"<pre><code>VlUnpacked&lt;IData, 4&gt; Vtop___024root::dut_param_mux__DOT____Vcellinp__uut_pmux__inputs;\n</code></pre>"},{"location":"TitanComms/classVtop______024root/#variable-dut_param_mux__dot__in1","title":"variable dut_param_mux__DOT__in1","text":"<pre><code>IData Vtop___024root::dut_param_mux__DOT__in1;\n</code></pre>"},{"location":"TitanComms/classVtop______024root/#variable-dut_param_mux__dot__in2","title":"variable dut_param_mux__DOT__in2","text":"<pre><code>IData Vtop___024root::dut_param_mux__DOT__in2;\n</code></pre>"},{"location":"TitanComms/classVtop______024root/#variable-dut_param_mux__dot__in3","title":"variable dut_param_mux__DOT__in3","text":"<pre><code>IData Vtop___024root::dut_param_mux__DOT__in3;\n</code></pre>"},{"location":"TitanComms/classVtop______024root/#variable-dut_param_mux__dot__in4","title":"variable dut_param_mux__DOT__in4","text":"<pre><code>IData Vtop___024root::dut_param_mux__DOT__in4;\n</code></pre>"},{"location":"TitanComms/classVtop______024root/#variable-dut_param_mux__dot__mux_o","title":"variable dut_param_mux__DOT__mux_o","text":"<pre><code>IData Vtop___024root::dut_param_mux__DOT__mux_o;\n</code></pre>"},{"location":"TitanComms/classVtop______024root/#variable-dut_param_mux__dot__sel_i","title":"variable dut_param_mux__DOT__sel_i","text":"<pre><code>CData Vtop___024root::dut_param_mux__DOT__sel_i;\n</code></pre>"},{"location":"TitanComms/classVtop______024root/#variable-dut_param_mux__dot__uut_pmux__dot__inputs","title":"variable dut_param_mux__DOT__uut_pmux__DOT__inputs","text":"<pre><code>VlUnpacked&lt;IData, 4&gt; Vtop___024root::dut_param_mux__DOT__uut_pmux__DOT__inputs;\n</code></pre>"},{"location":"TitanComms/classVtop______024root/#variable-dut_param_mux__dot__uut_pmux__dot__out","title":"variable dut_param_mux__DOT__uut_pmux__DOT__out","text":"<pre><code>IData Vtop___024root::dut_param_mux__DOT__uut_pmux__DOT__out;\n</code></pre>"},{"location":"TitanComms/classVtop______024root/#variable-dut_param_mux__dot__uut_pmux__dot__selector","title":"variable dut_param_mux__DOT__uut_pmux__DOT__selector","text":"<pre><code>CData Vtop___024root::dut_param_mux__DOT__uut_pmux__DOT__selector;\n</code></pre>"},{"location":"TitanComms/classVtop______024root/#variable-vlsymsp","title":"variable vlSymsp","text":"<pre><code>Vtop__Syms* const Vtop___024root::vlSymsp;\n</code></pre>"},{"location":"TitanComms/classVtop______024root/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"TitanComms/classVtop______024root/#variable-dut_param_mux__dot__uut_pmux__dot__input_width","title":"variable dut_param_mux__DOT__uut_pmux__DOT__INPUT_WIDTH","text":"<pre><code>constexpr IData Vtop___024root::dut_param_mux__DOT__uut_pmux__DOT__INPUT_WIDTH;\n</code></pre>"},{"location":"TitanComms/classVtop______024root/#variable-dut_param_mux__dot__uut_pmux__dot__selector_width","title":"variable dut_param_mux__DOT__uut_pmux__DOT__SELECTOR_WIDTH","text":"<pre><code>constexpr IData Vtop___024root::dut_param_mux__DOT__uut_pmux__DOT__SELECTOR_WIDTH;\n</code></pre>"},{"location":"TitanComms/classVtop______024root/#variable-dut_param_mux__dot__uut_pmux__dot__signal_count","title":"variable dut_param_mux__DOT__uut_pmux__DOT__SIGNAL_COUNT","text":"<pre><code>constexpr IData Vtop___024root::dut_param_mux__DOT__uut_pmux__DOT__SIGNAL_COUNT;\n</code></pre>"},{"location":"TitanComms/classVtop______024root/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"TitanComms/classVtop______024root/#function-vl_in-14","title":"function VL_IN [1/4]","text":"<pre><code>Vtop___024root::VL_IN (\n    in1,\n    31,\n    0\n) \n</code></pre>"},{"location":"TitanComms/classVtop______024root/#function-vl_in-24","title":"function VL_IN [2/4]","text":"<pre><code>Vtop___024root::VL_IN (\n    in2,\n    31,\n    0\n) \n</code></pre>"},{"location":"TitanComms/classVtop______024root/#function-vl_in-34","title":"function VL_IN [3/4]","text":"<pre><code>Vtop___024root::VL_IN (\n    in3,\n    31,\n    0\n) \n</code></pre>"},{"location":"TitanComms/classVtop______024root/#function-vl_in-44","title":"function VL_IN [4/4]","text":"<pre><code>Vtop___024root::VL_IN (\n    in4,\n    31,\n    0\n) \n</code></pre>"},{"location":"TitanComms/classVtop______024root/#function-vl_in8","title":"function VL_IN8","text":"<pre><code>Vtop___024root::VL_IN8 (\n    sel_i,\n    1,\n    0\n) \n</code></pre>"},{"location":"TitanComms/classVtop______024root/#function-vl_out","title":"function VL_OUT","text":"<pre><code>Vtop___024root::VL_OUT (\n    mux_o,\n    31,\n    0\n) \n</code></pre>"},{"location":"TitanComms/classVtop______024root/#function-vl_uncopyable","title":"function VL_UNCOPYABLE","text":"<pre><code>Vtop___024root::VL_UNCOPYABLE (\n    Vtop___024root\n) \n</code></pre>"},{"location":"TitanComms/classVtop______024root/#function-vtop___024root","title":"function Vtop___024root","text":"<pre><code>Vtop___024root::Vtop___024root (\n    Vtop__Syms * symsp,\n    const char * v__name\n) \n</code></pre>"},{"location":"TitanComms/classVtop______024root/#function-__vconfigure","title":"function __Vconfigure","text":"<pre><code>void Vtop___024root::__Vconfigure (\n    bool first\n) \n</code></pre>"},{"location":"TitanComms/classVtop______024root/#function-vtop___024root_1","title":"function ~Vtop___024root","text":"<pre><code>Vtop___024root::~Vtop___024root () \n</code></pre> <p>The documentation for this class was generated from the following file <code>titan/comms/verilog/tests/sim_build/Vtop___024root.h</code></p>"},{"location":"TitanComms/classVtop______024unit/","title":"Class Vtop___024unit","text":"<p>ClassList &gt; Vtop___024unit</p> <p>Inherits the following classes: VerilatedModule</p>"},{"location":"TitanComms/classVtop______024unit/#public-attributes","title":"Public Attributes","text":"Type Name Vtop__Syms *const vlSymsp"},{"location":"TitanComms/classVtop______024unit/#public-functions","title":"Public Functions","text":"Type Name VL_UNCOPYABLE (Vtop___024unit)  Vtop___024unit (Vtop__Syms * symsp, const char * v__name)  void __Vconfigure (bool first)  ~Vtop___024unit ()"},{"location":"TitanComms/classVtop______024unit/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"TitanComms/classVtop______024unit/#variable-vlsymsp","title":"variable vlSymsp","text":"<pre><code>Vtop__Syms* const Vtop___024unit::vlSymsp;\n</code></pre>"},{"location":"TitanComms/classVtop______024unit/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"TitanComms/classVtop______024unit/#function-vl_uncopyable","title":"function VL_UNCOPYABLE","text":"<pre><code>Vtop___024unit::VL_UNCOPYABLE (\n    Vtop___024unit\n) \n</code></pre>"},{"location":"TitanComms/classVtop______024unit/#function-vtop___024unit","title":"function Vtop___024unit","text":"<pre><code>Vtop___024unit::Vtop___024unit (\n    Vtop__Syms * symsp,\n    const char * v__name\n) \n</code></pre>"},{"location":"TitanComms/classVtop______024unit/#function-__vconfigure","title":"function __Vconfigure","text":"<pre><code>void Vtop___024unit::__Vconfigure (\n    bool first\n) \n</code></pre>"},{"location":"TitanComms/classVtop______024unit/#function-vtop___024unit_1","title":"function ~Vtop___024unit","text":"<pre><code>Vtop___024unit::~Vtop___024unit () \n</code></pre> <p>The documentation for this class was generated from the following file <code>titan/comms/verilog/tests/sim_build/Vtop___024unit.h</code></p>"},{"location":"TitanComms/dir_eedd3c7d49ee25ac76e1232870c4d0af/","title":"Dir titan","text":"<p>FileList &gt; titan</p>"},{"location":"TitanComms/dir_eedd3c7d49ee25ac76e1232870c4d0af/#directories","title":"Directories","text":"Type Name dir comms <p>The documentation for this class was generated from the following file <code>titan/</code></p>"},{"location":"TitanComms/dir_15e9a61cbc095141a3f886f43eb6818f/","title":"Dir titan/comms","text":"<p>FileList &gt; comms</p>"},{"location":"TitanComms/dir_15e9a61cbc095141a3f886f43eb6818f/#directories","title":"Directories","text":"Type Name dir TitanComms dir verilog <p>The documentation for this class was generated from the following file <code>titan/comms/</code></p>"},{"location":"TitanComms/dir_5bea15bd51704c26ebfcf0ce33d5c553/","title":"Dir titan/comms/TitanComms","text":"<p>FileList &gt; comms &gt; TitanComms</p>"},{"location":"TitanComms/dir_5bea15bd51704c26ebfcf0ce33d5c553/#files","title":"Files","text":"Type Name file TitanComms.cpp file TitanComms.h file TitanCommsDebug.h <p>The documentation for this class was generated from the following file <code>titan/comms/TitanComms/</code></p>"},{"location":"TitanComms/TitanComms_8cpp/","title":"File TitanComms.cpp","text":"<p>FileList &gt; comms &gt; TitanComms &gt; TitanComms.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Arduino.h\"</code></li> <li><code>#include \"TitanComms.h\"</code></li> <li><code>#include \"TitanCommsDebug.h\"</code></li> <li><code>#include \"SPI.h\"</code></li> </ul>"},{"location":"TitanComms/TitanComms_8cpp/#macros","title":"Macros","text":"Type Name define DEBUG"},{"location":"TitanComms/TitanComms_8cpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"TitanComms/TitanComms_8cpp/#define-debug","title":"define DEBUG","text":"<pre><code>#define DEBUG \n</code></pre> <p>The documentation for this class was generated from the following file <code>titan/comms/TitanComms/TitanComms.cpp</code></p>"},{"location":"TitanComms/TitanComms_8cpp_source/","title":"File TitanComms.cpp","text":"<p>File List &gt; comms &gt; TitanComms &gt; TitanComms.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n    TitanComms.cpp - Library/wrapper intended to help with communicating with\n                     Titan-created function blocks via the Titan Compiler (or \n                     any SPI-connected device that implements its protocol).\n*/\n#define DEBUG\n\n#include \"Arduino.h\"\n#include \"TitanComms.h\"\n#include \"TitanCommsDebug.h\"\n#include \"SPI.h\"\n\n// constructor\n#if defined(ARDUINO_TEENSY32)\n    TitanComms::TitanComms(int cs_pin, SPISettings spi_settings){\n        _cs_pin = cs_pin;\n        _spi_settings = spi_settings;\n        // _spi = SPI; // unneeded?\n    }\n#elif defined(ARDUINO_ARCH_RP2040)\n    TitanComms::TitanComms(int MISO, int MOSI, int CS, int SCLK, SPISettings spi_settings){\n        _cs_pin = CS;\n        _miso = MISO;\n        _mosi = MOSI;\n        _sclk = SCLK;\n        _spi_settings = spi_settings;\n\n        _spi = new arduino::MbedSPI(MISO, MOSI, SCLK);\n    }\n#endif\n\nvoid TitanComms::_chip_select(){\n    digitalWrite(_cs_pin, LOW);\n}\n\nvoid TitanComms::_chip_deselect(){\n    digitalWrite(_cs_pin, HIGH);\n}\n\nvoid TitanComms::begin(){\n    pinMode(_cs_pin, OUTPUT);\n    digitalWrite(_cs_pin, HIGH); // cs is active low, so setting to high means its disabled\n    _spi-&gt;begin();\n}\n\nvoid TitanComms::_extract_byte_from_int(u_int24 data, int byte_index, u_int8_t* storage_byte){\n    // byte_index should be either 0, 1 or 2\n    // byte_index:     2           1           0\n    // 24b number: xxxx xxxx | xxxx xxxx | xxxx xxxx\n    // byte mask:  1000 0000   0000 0000   0000 0000 -- 0x800000\n    //             0000 0000   1000 0000   0000 0000 -- 0x008000\n    //             0000 0000   0000 0000   1000 0000 -- 0x000080\n\n    u_int32_t byte_mask = 0x800000 &gt;&gt; (8 * byte_index);\n    u_int8_t new_byte;\n\n    int upper_limit = 7 + (8 * byte_index);\n    int lower_limit = 0 + (8 * byte_index);\n\n    int normal_pos = 0; // i is relative to the incoming value, it needs to be translated to the new byte\n    for (int i = lower_limit; i &lt; upper_limit + 1; i++){\n        if (bitRead(data.data, i)) {\n            bitSet(new_byte, normal_pos);\n        } else {\n            bitClear(new_byte, normal_pos);\n        }\n\n        normal_pos++;\n    }\n\n    *storage_byte = new_byte;\n}\n\nvoid TitanComms::write(u_int24 address, u_int32_t value){\n    byte addr_high, addr_mid, addr_low = 0;\n\n    _extract_byte_from_int(address, 0, &amp;addr_low);\n    _extract_byte_from_int(address, 1, &amp;addr_mid);\n    _extract_byte_from_int(address, 2, &amp;addr_high);\n\n    u_int16_t merged_instr_addr_high = (WRITE &lt;&lt; 8) + addr_high; // instruction + address high byte (16b)\n    u_int16_t addr_mid_and_low = (addr_mid &lt;&lt; 8) + addr_low; // address mid byte + address low byte (16b)\n    u_int16_t upper_data = (value &gt;&gt; 16);\n    u_int16_t lower_data = value; // auto truncated?\n\n\n    _spi-&gt;beginTransaction(_spi_settings);\n    _chip_select();\n    _spi-&gt;transfer16(merged_instr_addr_high);\n    _spi-&gt;transfer16(addr_mid_and_low);\n    _spi-&gt;transfer16(upper_data);\n    _spi-&gt;transfer16(lower_data);\n    _chip_deselect();\n    _spi-&gt;endTransaction();\n\n    // DEBUG_PRINT_STR(\"---L \"); DEBUG_PRINT_HEX(addr_low); DEBUG_PRINTLN();\n    // DEBUG_PRINT_STR(\"---M \"); DEBUG_PRINT_HEX(addr_mid); DEBUG_PRINTLN();\n    // DEBUG_PRINT_STR(\"---H \"); DEBUG_PRINT_HEX(addr_high);  DEBUG_PRINTLN();\n}\n\nbyte TitanComms::_nop_and_read8(){\n    byte temp = _spi-&gt;transfer(TRANSFER);\n    return temp;\n}\n\nu_int16_t TitanComms::_nop_and_read16(){\n    // pack byte instruction into a 2 byte one\n    // i.e. INSTRUCTION = 0x01\n    // formatted = 0x0101 etc\n    u_int16_t temp = _spi-&gt;transfer16(((TRANSFER &lt;&lt; 8) + TRANSFER));\n    return temp;\n}\n\nvoid TitanComms::_repeat() {\n    _spi-&gt;beginTransaction(_spi_settings);\n    _chip_select();\n    _spi-&gt;transfer(REPEAT);\n    _chip_deselect();\n    _spi-&gt;endTransaction();\n}\n\n\nu_int32_t TitanComms::read(u_int24 address){\n    // send: instruction + address --&gt; 8 bits + 24 bits\n    // recieve: value + checksum --&gt; 32 bits + 8 bits\n\n    u_int8_t addr_high;\n    _extract_byte_from_int(address, 2, &amp;addr_high); // should get the highest byte from address\n\n    u_int16_t merged_instr_addr_high = (READ &lt;&lt; 8) + addr_high;\n    u_int16_t addr_mid_and_low = address.data;\n\n    u_int16_t value_high, value_low;\n    u_int8_t recieved_checksum, calculated_checksum;\n\n\n    _spi-&gt;beginTransaction(_spi_settings);\n\n    _chip_select();\n    _spi-&gt;transfer16(merged_instr_addr_high);\n    _spi-&gt;transfer16(addr_mid_and_low);\n\n    value_high = _nop_and_read16();\n    value_low = _nop_and_read16();\n\n    // TODO: checksum, and repeating if necessary\n    // recieved_checksum = _nop_and_read8();\n\n    _chip_deselect();\n    _spi-&gt;endTransaction();\n\n    u_int32_t final_val = (value_high &lt;&lt; 16) + value_low;\n\n    return final_val;\n}\n\nu_int32_t TitanComms::stream(u_int32_t value){\n    u_int16_t ans1, ans2;\n\n    _spi-&gt;beginTransaction(_spi_settings);\n    _chip_select();\n    _spi-&gt;transfer((u_int8_t)STREAM);\n    ans1 = _spi-&gt;transfer16(value &gt;&gt; 16);\n    ans2 = _spi-&gt;transfer16((u_int16_t)value);\n    _chip_deselect();\n    _spi-&gt;endTransaction();\n\n    // DEBUG_PRINT_STR(\"[stream (rx)]: \");\n    // DEBUG_PRINT_HEX(ans1); DEBUG_PRINT_STR(\" \");\n    // DEBUG_PRINT_HEX(ans2); DEBUG_PRINT_STR(\" \");\n    // DEBUG_PRINT_HEX(ans3); DEBUG_PRINTLN();\n\n    return (u_int32_t) ((ans1 &lt;&lt; 16) + ans2);\n}\n\n// void TitanComms::bind_address(u_int24 address){\n//     u_int16_t instr_addr_hi = (BIND_ADDRESS) &lt;&lt; 8 + (address.data &gt;&gt; 16);\n\n//     DEBUG_PRINT_HEX(instr_addr_hi); DEBUG_PRINT_STR(\" \");\n//     DEBUG_PRINT_HEX((uint16_t)address.data); DEBUG_PRINTLN();\n\n//     _spi-&gt;beginTransaction(_spi_settings);\n//     _chip_select();\n//     _spi-&gt;transfer16(instr_addr_hi);\n//     _spi-&gt;transfer16((uint16_t)address.data);\n//     _chip_deselect();\n//     _spi-&gt;endTransaction();\n// }\n\nvoid TitanComms::set_stream_read_address(u_int32_t address){\n    u_int16_t instr_addr_hi = (BIND_READ_ADDRESS &lt;&lt; 8) + ((address &lt;&lt; 8) &gt;&gt; 24);\n    u_int16_t addr_mid_lo = address;\n\n    _spi-&gt;beginTransaction(_spi_settings);\n    _chip_select();\n    _spi-&gt;transfer16(instr_addr_hi);\n    _spi-&gt;transfer16(addr_mid_lo);\n    _chip_deselect();\n    _spi-&gt;endTransaction();\n}\n\nvoid TitanComms::set_stream_write_address(u_int32_t address){\n    u_int16_t instr_addr_hi = (BIND_WRITE_ADDRESS &lt;&lt; 8) + ((address &lt;&lt; 8) &gt;&gt; 24);\n    u_int16_t addr_mid_lo = address;\n\n    DEBUG_PRINT_STR(\"[set_stream_write_address] \");\n    DEBUG_PRINT_HEX(instr_addr_hi); DEBUG_PRINT_STR(\" \"); DEBUG_PRINT_HEX(addr_mid_lo);\n    DEBUG_PRINTLN();\n\n    _spi-&gt;beginTransaction(_spi_settings);\n    _chip_select();\n    _spi-&gt;transfer16(instr_addr_hi);\n    _spi-&gt;transfer16(addr_mid_lo);\n    _chip_deselect();\n    _spi-&gt;endTransaction();\n}\n\nvoid TitanComms::set_core_interrupt(u_int24 address){\n    u_int8_t addr_hi;\n    _extract_byte_from_int(address, 2, &amp;addr_hi);\n\n    u_int16_t merged_instr_addr_hi = (BIND_INTERRUPT &lt;&lt; 8) + addr_hi;\n    u_int16_t addr_mid_lo = address.data;\n\n    _spi-&gt;beginTransaction(_spi_settings);\n    _chip_select();\n    _spi-&gt;transfer16(merged_instr_addr_hi);\n    _spi-&gt;transfer16(addr_mid_lo);\n    _chip_deselect();\n    _spi-&gt;endTransaction();\n}\n</code></pre>"},{"location":"TitanComms/TitanComms_8h/","title":"File TitanComms.h","text":"<p>FileList &gt; comms &gt; TitanComms &gt; TitanComms.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Arduino.h\"</code></li> <li><code>#include \"SPI.h\"</code></li> </ul>"},{"location":"TitanComms/TitanComms_8h/#classes","title":"Classes","text":"Type Name class TitanComms struct u_int24 <p>The documentation for this class was generated from the following file <code>titan/comms/TitanComms/TitanComms.h</code></p>"},{"location":"TitanComms/TitanComms_8h_source/","title":"File TitanComms.h","text":"<p>File List &gt; comms &gt; TitanComms &gt; TitanComms.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n    TitanComms.h - Library/wrapper intended to help with communicating with\n                   Titan-created function blocks via the Titan Compiler (or \n                   any SPI-connected device that implements its protocol).\n*/\n#ifndef TitanComms_h\n#define TitanComms_h\n\n#include \"Arduino.h\"\n#include \"SPI.h\"\n\nclass TitanComms {\n    public:\n        #if !defined(ARDUINO_ARCH_RP2040)\n            TitanComms(int cs_pin, SPISettings spi_settings); // pass cs &amp; spi settings?\n        #elif defined(ARDUINO_ARCH_RP2040)\n            TitanComms(int MISO, int MOSI, int CS, int SCLK, SPISettings spi_settings);\n        #else\n            #error \"unsupported target\"\n        #endif\n\n        enum instruction {\n            NOP = 0x00,\n            WRITE = 0x01,\n            READ = 0x02,\n            STREAM = 0x03,\n            BIND_INTERRUPT = 0x04,\n            BIND_READ_ADDRESS = 0x05,\n            BIND_WRITE_ADDRESS = 0x06,\n            TRANSFER = 0x07,\n            REPEAT = 0x08,\n            GET_METADATA = 0xFF\n        };\n\n        struct u_int24 {\n            u_int32_t data : 24;\n        };\n        void begin(); // handles hardware config\n        u_int32_t read(u_int24 address);\n        void write(u_int24 address, u_int32_t value);\n        u_int32_t stream(u_int32_t value);\n        void set_stream_write_address(u_int32_t address);\n        void set_stream_read_address(u_int32_t address);\n\n        // do not use\n        void bind_address(u_int24 address);\n        void set_core_interrupt(u_int24 address);\n    private:\n        int _cs_pin;\n        SPISettings _spi_settings;\n        u_int8_t _nop_and_read8();\n        u_int16_t _nop_and_read16();\n        void _repeat();\n        void _extract_byte_from_int(u_int24 data, int byte_index, u_int8_t* storage_byte);\n        void _chip_select();\n        void _chip_deselect();\n        u_int8_t _xor_checksum(u_int32_t input);\n\n        // create different class depending on target architecture\n        //              v extract from verbose compilation\n        // target rpi: ARDUINO_ARCH_RP2040\n        // target teensy3.2: ARDUINO_TEENSY32\n        #if defined(ARDUINO_TEENSY32)\n            SPIClass *_spi;\n        #elif defined(ARDUINO_ARCH_RP2040)\n            arduino::MbedSPI *_spi;\n            int _miso, _mosi, _sclk;\n        #else\n            #error \"unsupported target\"\n        #endif\n};\n\n#endif\n</code></pre>"},{"location":"TitanComms/TitanCommsDebug_8h/","title":"File TitanCommsDebug.h","text":"<p>FileList &gt; comms &gt; TitanComms &gt; TitanCommsDebug.h</p> <p>Go to the source code of this file</p>"},{"location":"TitanComms/TitanCommsDebug_8h/#macros","title":"Macros","text":"Type Name define DEBUG_PRINT (x)  define DEBUG_PRINTLN ()  define DEBUG_PRINTLN_STR (x)  define DEBUG_PRINT_BIN (x)  define DEBUG_PRINT_HEX (x)  define DEBUG_PRINT_INT (x)  define DEBUG_PRINT_SIZEOF (x)  define DEBUG_PRINT_STR (x)"},{"location":"TitanComms/TitanCommsDebug_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"TitanComms/TitanCommsDebug_8h/#define-debug_print","title":"define DEBUG_PRINT","text":"<pre><code>#define DEBUG_PRINT (\n    x\n) \n</code></pre>"},{"location":"TitanComms/TitanCommsDebug_8h/#define-debug_println","title":"define DEBUG_PRINTLN","text":"<pre><code>#define DEBUG_PRINTLN (\n\n) \n</code></pre>"},{"location":"TitanComms/TitanCommsDebug_8h/#define-debug_println_str","title":"define DEBUG_PRINTLN_STR","text":"<pre><code>#define DEBUG_PRINTLN_STR (\n    x\n) \n</code></pre>"},{"location":"TitanComms/TitanCommsDebug_8h/#define-debug_print_bin","title":"define DEBUG_PRINT_BIN","text":"<pre><code>#define DEBUG_PRINT_BIN (\n    x\n) \n</code></pre>"},{"location":"TitanComms/TitanCommsDebug_8h/#define-debug_print_hex","title":"define DEBUG_PRINT_HEX","text":"<pre><code>#define DEBUG_PRINT_HEX (\n    x\n) \n</code></pre>"},{"location":"TitanComms/TitanCommsDebug_8h/#define-debug_print_int","title":"define DEBUG_PRINT_INT","text":"<pre><code>#define DEBUG_PRINT_INT (\n    x\n) \n</code></pre>"},{"location":"TitanComms/TitanCommsDebug_8h/#define-debug_print_sizeof","title":"define DEBUG_PRINT_SIZEOF","text":"<pre><code>#define DEBUG_PRINT_SIZEOF (\n    x\n) \n</code></pre>"},{"location":"TitanComms/TitanCommsDebug_8h/#define-debug_print_str","title":"define DEBUG_PRINT_STR","text":"<pre><code>#define DEBUG_PRINT_STR (\n    x\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>titan/comms/TitanComms/TitanCommsDebug.h</code></p>"},{"location":"TitanComms/TitanCommsDebug_8h_source/","title":"File TitanCommsDebug.h","text":"<p>File List &gt; comms &gt; TitanComms &gt; TitanCommsDebug.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifdef DEBUG\n    #define DEBUG_PRINT_VALUE(x) \\\n        Serial.print(x); \\\n        Serial.print(\" as hex: \"); \\\n        Serial.print(x, HEX); \\\n        Serial.print(\" , as bin: \"); \\\n        Serial.print(x, BIN); \\\n        Serial.println();\n\n    #define DEBUG_PRINT_STR(x) Serial.print(x);\n    #define DEBUG_PRINTLN() Serial.println();\n    #define DEBUG_PRINTLN_STR(x) Serial.println(x);\n    #define DEBUG_PRINT_HEX(x) Serial.print(x, HEX);\n    #define DEBUG_PRINT_INT(x) Serial.print(x);\n    #define DEBUG_PRINT_BIN(x) Serial.print(x, BIN);\n    #define DEBUG_PRINT_SIZEOF(x) Serial.print(sizeof(x));\n\n#else\n    #define DEBUG_PRINT(x)\n    #define DEBUG_PRINT_STR(x)\n    #define DEBUG_PRINTLN()\n    #define DEBUG_PRINTLN_STR(x)\n    #define DEBUG_PRINT_HEX(x)\n    #define DEBUG_PRINT_INT(x)\n    #define DEBUG_PRINT_BIN(x)\n    #define DEBUG_PRINT_SIZEOF(x)\n#endif\n</code></pre>"},{"location":"TitanComms/dir_549b42112f6dc36cf8af5f13bada3f17/","title":"Dir titan/comms/verilog","text":"<p>FileList &gt; comms &gt; verilog</p>"},{"location":"TitanComms/dir_549b42112f6dc36cf8af5f13bada3f17/#directories","title":"Directories","text":"Type Name dir tests <p>The documentation for this class was generated from the following file <code>titan/comms/verilog/</code></p>"},{"location":"TitanComms/dir_359bc3875cb3adaee3d3f269dbe0d6e4/","title":"Dir titan/comms/verilog/tests","text":"<p>FileList &gt; comms &gt; verilog &gt; tests</p>"},{"location":"TitanComms/dir_359bc3875cb3adaee3d3f269dbe0d6e4/#directories","title":"Directories","text":"Type Name dir sim_build <p>The documentation for this class was generated from the following file <code>titan/comms/verilog/tests/</code></p>"},{"location":"TitanComms/dir_816ed350c72cf5de8127e0b7e8b74e54/","title":"Dir titan/comms/verilog/tests/sim_build","text":"<p>FileList &gt; comms &gt; verilog &gt; tests &gt; sim_build</p>"},{"location":"TitanComms/dir_816ed350c72cf5de8127e0b7e8b74e54/#files","title":"Files","text":"Type Name file Vtop.cpp file Vtop.h file Vtop__ALL.cpp file Vtop__Dpi.cpp file Vtop__Dpi.h file Vtop__Syms.cpp file Vtop__Syms.h file Vtop__Trace__0.cpp file Vtop__Trace__0__Slow.cpp file Vtop___024root.h file Vtop___024root__DepSet_h84412442__0.cpp file Vtop___024root__DepSet_h84412442__0__Slow.cpp file Vtop___024root__DepSet_heccd7ead__0.cpp file Vtop___024root__DepSet_heccd7ead__0__Slow.cpp file Vtop___024root__Slow.cpp file Vtop___024unit.h file Vtop___024unit__DepSet_hff17caec__0__Slow.cpp file Vtop___024unit__Slow.cpp <p>The documentation for this class was generated from the following file <code>titan/comms/verilog/tests/sim_build/</code></p>"},{"location":"TitanComms/Vtop_8cpp/","title":"File Vtop.cpp","text":"<p>FileList &gt; comms &gt; verilog &gt; tests &gt; sim_build &gt; Vtop.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Vtop.h\"</code></li> <li><code>#include \"Vtop__Syms.h\"</code></li> <li><code>#include \"verilated_vcd_c.h\"</code></li> <li><code>#include \"verilated_dpi.h\"</code></li> </ul>"},{"location":"TitanComms/Vtop_8cpp/#public-functions","title":"Public Functions","text":"Type Name void Vtop___024root___eval (Vtop___024root * vlSelf)  void Vtop___024root___eval_final (Vtop___024root * vlSelf)  void Vtop___024root___eval_initial (Vtop___024root * vlSelf)  void Vtop___024root___eval_settle (Vtop___024root * vlSelf)  void Vtop___024root___eval_static (Vtop___024root * vlSelf)  void Vtop___024root__trace_init_top (Vtop___024root * vlSelf, VerilatedVcd * tracep)  VL_ATTR_COLD void Vtop___024root__trace_register (Vtop___024root * vlSelf, VerilatedVcd * tracep)"},{"location":"TitanComms/Vtop_8cpp/#public-static-functions","title":"Public Static Functions","text":"Type Name VL_ATTR_COLD void trace_init (void * voidSelf, VerilatedVcd * tracep, uint32_t code)"},{"location":"TitanComms/Vtop_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"TitanComms/Vtop_8cpp/#function-vtop___024root___eval","title":"function Vtop___024root___eval","text":"<pre><code>void Vtop___024root___eval (\n    Vtop___024root * vlSelf\n) \n</code></pre>"},{"location":"TitanComms/Vtop_8cpp/#function-vtop___024root___eval_final","title":"function Vtop___024root___eval_final","text":"<pre><code>void Vtop___024root___eval_final (\n    Vtop___024root * vlSelf\n) \n</code></pre>"},{"location":"TitanComms/Vtop_8cpp/#function-vtop___024root___eval_initial","title":"function Vtop___024root___eval_initial","text":"<pre><code>void Vtop___024root___eval_initial (\n    Vtop___024root * vlSelf\n) \n</code></pre>"},{"location":"TitanComms/Vtop_8cpp/#function-vtop___024root___eval_settle","title":"function Vtop___024root___eval_settle","text":"<pre><code>void Vtop___024root___eval_settle (\n    Vtop___024root * vlSelf\n) \n</code></pre>"},{"location":"TitanComms/Vtop_8cpp/#function-vtop___024root___eval_static","title":"function Vtop___024root___eval_static","text":"<pre><code>void Vtop___024root___eval_static (\n    Vtop___024root * vlSelf\n) \n</code></pre>"},{"location":"TitanComms/Vtop_8cpp/#function-vtop___024root__trace_init_top","title":"function Vtop___024root__trace_init_top","text":"<pre><code>void Vtop___024root__trace_init_top (\n    Vtop___024root * vlSelf,\n    VerilatedVcd * tracep\n) \n</code></pre>"},{"location":"TitanComms/Vtop_8cpp/#function-vtop___024root__trace_register","title":"function Vtop___024root__trace_register","text":"<pre><code>VL_ATTR_COLD void Vtop___024root__trace_register (\n    Vtop___024root * vlSelf,\n    VerilatedVcd * tracep\n) \n</code></pre>"},{"location":"TitanComms/Vtop_8cpp/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"TitanComms/Vtop_8cpp/#function-trace_init","title":"function trace_init","text":"<pre><code>static VL_ATTR_COLD void trace_init (\n    void * voidSelf,\n    VerilatedVcd * tracep,\n    uint32_t code\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>titan/comms/verilog/tests/sim_build/Vtop.cpp</code></p>"},{"location":"TitanComms/Vtop_8cpp_source/","title":"File Vtop.cpp","text":"<p>File List &gt; comms &gt; verilog &gt; tests &gt; sim_build &gt; Vtop.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// Verilated -*- C++ -*-\n// DESCRIPTION: Verilator output: Model implementation (design independent parts)\n\n#include \"Vtop.h\"\n#include \"Vtop__Syms.h\"\n#include \"verilated_vcd_c.h\"\n#include \"verilated_dpi.h\"\n\n//============================================================\n// Constructors\n\nVtop::Vtop(VerilatedContext* _vcontextp__, const char* _vcname__)\n    : VerilatedModel{*_vcontextp__}\n    , vlSymsp{new Vtop__Syms(contextp(), _vcname__, this)}\n    , sel_i{vlSymsp-&gt;TOP.sel_i}\n    , in1{vlSymsp-&gt;TOP.in1}\n    , in2{vlSymsp-&gt;TOP.in2}\n    , in3{vlSymsp-&gt;TOP.in3}\n    , in4{vlSymsp-&gt;TOP.in4}\n    , mux_o{vlSymsp-&gt;TOP.mux_o}\n    , rootp{&amp;(vlSymsp-&gt;TOP)}\n{\n    // Register model with the context\n    contextp()-&gt;addModel(this);\n}\n\nVtop::Vtop(const char* _vcname__)\n    : Vtop(Verilated::threadContextp(), _vcname__)\n{\n}\n\n//============================================================\n// Destructor\n\nVtop::~Vtop() {\n    delete vlSymsp;\n}\n\n//============================================================\n// Evaluation function\n\n#ifdef VL_DEBUG\nvoid Vtop___024root___eval_debug_assertions(Vtop___024root* vlSelf);\n#endif  // VL_DEBUG\nvoid Vtop___024root___eval_static(Vtop___024root* vlSelf);\nvoid Vtop___024root___eval_initial(Vtop___024root* vlSelf);\nvoid Vtop___024root___eval_settle(Vtop___024root* vlSelf);\nvoid Vtop___024root___eval(Vtop___024root* vlSelf);\n\nvoid Vtop::eval_step() {\n    VL_DEBUG_IF(VL_DBG_MSGF(\"+++++TOP Evaluate Vtop::eval_step\\n\"); );\n#ifdef VL_DEBUG\n    // Debug assertions\n    Vtop___024root___eval_debug_assertions(&amp;(vlSymsp-&gt;TOP));\n#endif  // VL_DEBUG\n    vlSymsp-&gt;__Vm_activity = true;\n    if (VL_UNLIKELY(!vlSymsp-&gt;__Vm_didInit)) {\n        vlSymsp-&gt;__Vm_didInit = true;\n        VL_DEBUG_IF(VL_DBG_MSGF(\"+ Initial\\n\"););\n        Vtop___024root___eval_static(&amp;(vlSymsp-&gt;TOP));\n        Vtop___024root___eval_initial(&amp;(vlSymsp-&gt;TOP));\n        Vtop___024root___eval_settle(&amp;(vlSymsp-&gt;TOP));\n    }\n    // MTask 0 start\n    VL_DEBUG_IF(VL_DBG_MSGF(\"MTask0 starting\\n\"););\n    Verilated::mtaskId(0);\n    VL_DEBUG_IF(VL_DBG_MSGF(\"+ Eval\\n\"););\n    Vtop___024root___eval(&amp;(vlSymsp-&gt;TOP));\n    // Evaluate cleanup\n    Verilated::endOfThreadMTask(vlSymsp-&gt;__Vm_evalMsgQp);\n    Verilated::endOfEval(vlSymsp-&gt;__Vm_evalMsgQp);\n}\n\nvoid Vtop::eval_end_step() {\n    VL_DEBUG_IF(VL_DBG_MSGF(\"+eval_end_step Vtop::eval_end_step\\n\"); );\n#ifdef VM_TRACE\n    // Tracing\n    if (VL_UNLIKELY(vlSymsp-&gt;__Vm_dumping)) vlSymsp-&gt;_traceDump();\n#endif  // VM_TRACE\n}\n\n//============================================================\n// Events and timing\nbool Vtop::eventsPending() { return !vlSymsp-&gt;TOP.__VdlySched.empty(); }\n\nuint64_t Vtop::nextTimeSlot() { return vlSymsp-&gt;TOP.__VdlySched.nextTimeSlot(); }\n\n//============================================================\n// Utilities\n\nconst char* Vtop::name() const {\n    return vlSymsp-&gt;name();\n}\n\n//============================================================\n// Invoke final blocks\n\nvoid Vtop___024root___eval_final(Vtop___024root* vlSelf);\n\nVL_ATTR_COLD void Vtop::final() {\n    Vtop___024root___eval_final(&amp;(vlSymsp-&gt;TOP));\n}\n\n//============================================================\n// Implementations of abstract methods from VerilatedModel\n\nconst char* Vtop::hierName() const { return vlSymsp-&gt;name(); }\nconst char* Vtop::modelName() const { return \"Vtop\"; }\nunsigned Vtop::threads() const { return 1; }\nstd::unique_ptr&lt;VerilatedTraceConfig&gt; Vtop::traceConfig() const {\n    return std::unique_ptr&lt;VerilatedTraceConfig&gt;{new VerilatedTraceConfig{false, false, false}};\n};\n\n//============================================================\n// Trace configuration\n\nvoid Vtop___024root__trace_init_top(Vtop___024root* vlSelf, VerilatedVcd* tracep);\n\nVL_ATTR_COLD static void trace_init(void* voidSelf, VerilatedVcd* tracep, uint32_t code) {\n    // Callback from tracep-&gt;open()\n    Vtop___024root* const __restrict vlSelf VL_ATTR_UNUSED = static_cast&lt;Vtop___024root*&gt;(voidSelf);\n    Vtop__Syms* const __restrict vlSymsp VL_ATTR_UNUSED = vlSelf-&gt;vlSymsp;\n    if (!vlSymsp-&gt;_vm_contextp__-&gt;calcUnusedSigs()) {\n        VL_FATAL_MT(__FILE__, __LINE__, __FILE__,\n            \"Turning on wave traces requires Verilated::traceEverOn(true) call before time 0.\");\n    }\n    vlSymsp-&gt;__Vm_baseCode = code;\n    tracep-&gt;scopeEscape(' ');\n    tracep-&gt;pushNamePrefix(std::string{vlSymsp-&gt;name()} + ' ');\n    Vtop___024root__trace_init_top(vlSelf, tracep);\n    tracep-&gt;popNamePrefix();\n    tracep-&gt;scopeEscape('.');\n}\n\nVL_ATTR_COLD void Vtop___024root__trace_register(Vtop___024root* vlSelf, VerilatedVcd* tracep);\n\nVL_ATTR_COLD void Vtop::trace(VerilatedVcdC* tfp, int levels, int options) {\n    if (tfp-&gt;isOpen()) {\n        vl_fatal(__FILE__, __LINE__, __FILE__,\"'Vtop::trace()' shall not be called after 'VerilatedVcdC::open()'.\");\n    }\n    if (false &amp;&amp; levels &amp;&amp; options) {}  // Prevent unused\n    tfp-&gt;spTrace()-&gt;addModel(this);\n    tfp-&gt;spTrace()-&gt;addInitCb(&amp;trace_init, &amp;(vlSymsp-&gt;TOP));\n    Vtop___024root__trace_register(&amp;(vlSymsp-&gt;TOP), tfp-&gt;spTrace());\n}\n</code></pre>"},{"location":"TitanComms/Vtop_8h/","title":"File Vtop.h","text":"<p>FileList &gt; comms &gt; verilog &gt; tests &gt; sim_build &gt; Vtop.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"verilated.h\"</code></li> <li><code>#include \"svdpi.h\"</code></li> </ul>"},{"location":"TitanComms/Vtop_8h/#classes","title":"Classes","text":"Type Name class VL_NOT_FINAL"},{"location":"TitanComms/Vtop_8h/#public-attributes","title":"Public Attributes","text":"Type Name VL_IN &amp; in1 VL_IN &amp; in2 VL_IN &amp; in3 VL_IN &amp; in4 VL_OUT &amp; mux_o Vtop___024root *const rootp VL_IN8 &amp; sel_i"},{"location":"TitanComms/Vtop_8h/#public-functions","title":"Public Functions","text":"Type Name VL_NOT_FINAL VerilatedModel VL_ATTR_ALIGNED (VL_CACHE_LINE_BYTES)  Vtop (VerilatedContext * contextp, const char * name=\"TOP\")  Vtop (const char * name=\"TOP\")  void eval () Evaluate the model. Application must call when inputs change. void eval_end_step ()  void eval_step () Evaluate when calling multiple units/models per time step. bool eventsPending () Are there scheduled events to handle? void final () Simulation complete, run final blocks. Application must call on completion. const char * hierName () override const const char * modelName () override const const char * name () constRetrieve name of this model instance (as passed to constructor). uint64_t nextTimeSlot () Returns time at next time slot. Aborts if !eventsPending() unsigned threads () override const void trace (VerilatedVcdC * tfp, int levels, int options=0) Trace signals in the model; called by application code. std::unique_ptr&lt; VerilatedTraceConfig &gt; traceConfig () override const virtual ~Vtop () Destroy the model; called (often implicitly) by application code."},{"location":"TitanComms/Vtop_8h/#macros","title":"Macros","text":"Type Name define VERILATED_VTOP_H_"},{"location":"TitanComms/Vtop_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"TitanComms/Vtop_8h/#variable-in1","title":"variable in1","text":"<pre><code>VL_IN&amp; in1;\n</code></pre>"},{"location":"TitanComms/Vtop_8h/#variable-in2","title":"variable in2","text":"<pre><code>VL_IN&amp; in2;\n</code></pre>"},{"location":"TitanComms/Vtop_8h/#variable-in3","title":"variable in3","text":"<pre><code>VL_IN&amp; in3;\n</code></pre>"},{"location":"TitanComms/Vtop_8h/#variable-in4","title":"variable in4","text":"<pre><code>VL_IN&amp; in4;\n</code></pre>"},{"location":"TitanComms/Vtop_8h/#variable-mux_o","title":"variable mux_o","text":"<pre><code>VL_OUT&amp; mux_o;\n</code></pre>"},{"location":"TitanComms/Vtop_8h/#variable-rootp","title":"variable rootp","text":"<pre><code>Vtop___024root* const rootp;\n</code></pre>"},{"location":"TitanComms/Vtop_8h/#variable-sel_i","title":"variable sel_i","text":"<pre><code>VL_IN8&amp; sel_i;\n</code></pre>"},{"location":"TitanComms/Vtop_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"TitanComms/Vtop_8h/#function-vl_attr_aligned","title":"function VL_ATTR_ALIGNED","text":"<pre><code>VL_NOT_FINAL VerilatedModel VL_ATTR_ALIGNED (\n    VL_CACHE_LINE_BYTES\n) \n</code></pre>"},{"location":"TitanComms/Vtop_8h/#function-vtop","title":"function Vtop","text":"<pre><code>explicit Vtop (\n    VerilatedContext * contextp,\n    const char * name=\"TOP\"\n) \n</code></pre> <p>Construct the model; called by application code If contextp is null, then the model will use the default global context If name is \"\", then makes a wrapper with a single model invisible with respect to DPI scope names. </p>"},{"location":"TitanComms/Vtop_8h/#function-vtop_1","title":"function Vtop","text":"<pre><code>explicit Vtop (\n    const char * name=\"TOP\"\n) \n</code></pre>"},{"location":"TitanComms/Vtop_8h/#function-eval","title":"function eval","text":"<pre><code>void eval () \n</code></pre>"},{"location":"TitanComms/Vtop_8h/#function-eval_end_step","title":"function eval_end_step","text":"<pre><code>void eval_end_step () \n</code></pre> <p>Evaluate at end of a timestep for tracing, when using eval_step(). Application must call after all eval() and before time changes. </p>"},{"location":"TitanComms/Vtop_8h/#function-eval_step","title":"function eval_step","text":"<pre><code>void eval_step () \n</code></pre>"},{"location":"TitanComms/Vtop_8h/#function-eventspending","title":"function eventsPending","text":"<pre><code>bool eventsPending () \n</code></pre>"},{"location":"TitanComms/Vtop_8h/#function-final","title":"function final","text":"<pre><code>void final () \n</code></pre>"},{"location":"TitanComms/Vtop_8h/#function-hiername","title":"function hierName","text":"<pre><code>const char * hierName () override const\n</code></pre>"},{"location":"TitanComms/Vtop_8h/#function-modelname","title":"function modelName","text":"<pre><code>const char * modelName () override const\n</code></pre>"},{"location":"TitanComms/Vtop_8h/#function-name","title":"function name","text":"<pre><code>const char * name () const\n</code></pre>"},{"location":"TitanComms/Vtop_8h/#function-nexttimeslot","title":"function nextTimeSlot","text":"<pre><code>uint64_t nextTimeSlot () \n</code></pre>"},{"location":"TitanComms/Vtop_8h/#function-threads","title":"function threads","text":"<pre><code>unsigned threads () override const\n</code></pre>"},{"location":"TitanComms/Vtop_8h/#function-trace","title":"function trace","text":"<pre><code>void trace (\n    VerilatedVcdC * tfp,\n    int levels,\n    int options=0\n) \n</code></pre>"},{"location":"TitanComms/Vtop_8h/#function-traceconfig","title":"function traceConfig","text":"<pre><code>std::unique_ptr&lt; VerilatedTraceConfig &gt; traceConfig () override const\n</code></pre>"},{"location":"TitanComms/Vtop_8h/#function-vtop_2","title":"function ~Vtop","text":"<pre><code>virtual ~Vtop () \n</code></pre>"},{"location":"TitanComms/Vtop_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"TitanComms/Vtop_8h/#define-verilated_vtop_h_","title":"define VERILATED_VTOP_H_","text":"<pre><code>#define VERILATED_VTOP_H_ \n</code></pre> <p>The documentation for this class was generated from the following file <code>titan/comms/verilog/tests/sim_build/Vtop.h</code></p>"},{"location":"TitanComms/Vtop_8h_source/","title":"File Vtop.h","text":"<p>File List &gt; comms &gt; verilog &gt; tests &gt; sim_build &gt; Vtop.h</p> <p>Go to the documentation of this file</p> <pre><code>// Verilated -*- C++ -*-\n// DESCRIPTION: Verilator output: Primary model header\n//\n// This header should be included by all source files instantiating the design.\n// The class here is then constructed to instantiate the design.\n// See the Verilator manual for examples.\n\n#ifndef VERILATED_VTOP_H_\n#define VERILATED_VTOP_H_  // guard\n\n#include \"verilated.h\"\n#include \"svdpi.h\"\n\nclass Vtop__Syms;\nclass Vtop___024root;\nclass VerilatedVcdC;\n\n// This class is the main interface to the Verilated model\nclass Vtop VL_NOT_FINAL : public VerilatedModel {\n  private:\n    // Symbol table holding complete model state (owned by this class)\n    Vtop__Syms* const vlSymsp;\n\n  public:\n\n    // PORTS\n    // The application code writes and reads these signals to\n    // propagate new values into/out from the Verilated model.\n    VL_IN8(&amp;sel_i,1,0);\n    VL_IN(&amp;in1,31,0);\n    VL_IN(&amp;in2,31,0);\n    VL_IN(&amp;in3,31,0);\n    VL_IN(&amp;in4,31,0);\n    VL_OUT(&amp;mux_o,31,0);\n\n    // CELLS\n    // Public to allow access to /* verilator public */ items.\n    // Otherwise the application code can consider these internals.\n\n    // Root instance pointer to allow access to model internals,\n    // including inlined /* verilator public_flat_* */ items.\n    Vtop___024root* const rootp;\n\n    // CONSTRUCTORS\n    explicit Vtop(VerilatedContext* contextp, const char* name = \"TOP\");\n    explicit Vtop(const char* name = \"TOP\");\n    virtual ~Vtop();\n  private:\n    VL_UNCOPYABLE(Vtop);  \n\n  public:\n    // API METHODS\n    void eval() { eval_step(); eval_end_step(); }\n    void eval_step();\n    void eval_end_step();\n    void final();\n    bool eventsPending();\n    uint64_t nextTimeSlot();\n    void trace(VerilatedVcdC* tfp, int levels, int options = 0);\n    const char* name() const;\n\n    // Abstract methods from VerilatedModel\n    const char* hierName() const override final;\n    const char* modelName() const override final;\n    unsigned threads() const override final;\n    std::unique_ptr&lt;VerilatedTraceConfig&gt; traceConfig() const override final;\n} VL_ATTR_ALIGNED(VL_CACHE_LINE_BYTES);\n\n#endif  // guard\n</code></pre>"},{"location":"TitanComms/Vtop____ALL_8cpp/","title":"File Vtop__ALL.cpp","text":"<p>FileList &gt; comms &gt; verilog &gt; tests &gt; sim_build &gt; Vtop__ALL.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Vtop.cpp\"</code></li> <li><code>#include \"Vtop___024root__DepSet_h84412442__0.cpp\"</code></li> <li><code>#include \"Vtop___024root__DepSet_heccd7ead__0.cpp\"</code></li> <li><code>#include \"Vtop__Dpi.cpp\"</code></li> <li><code>#include \"Vtop__Trace__0.cpp\"</code></li> <li><code>#include \"Vtop___024root__Slow.cpp\"</code></li> <li><code>#include \"Vtop___024root__DepSet_h84412442__0__Slow.cpp\"</code></li> <li><code>#include \"Vtop___024root__DepSet_heccd7ead__0__Slow.cpp\"</code></li> <li><code>#include \"Vtop___024unit__Slow.cpp\"</code></li> <li><code>#include \"Vtop___024unit__DepSet_hff17caec__0__Slow.cpp\"</code></li> <li><code>#include \"Vtop__Syms.cpp\"</code></li> <li><code>#include \"Vtop__Trace__0__Slow.cpp\"</code></li> </ul>"},{"location":"TitanComms/Vtop____ALL_8cpp/#macros","title":"Macros","text":"Type Name define VL_INCLUDE_OPT  include"},{"location":"TitanComms/Vtop____ALL_8cpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"TitanComms/Vtop____ALL_8cpp/#define-vl_include_opt","title":"define VL_INCLUDE_OPT","text":"<pre><code>#define VL_INCLUDE_OPT include\n</code></pre> <p>The documentation for this class was generated from the following file <code>titan/comms/verilog/tests/sim_build/Vtop__ALL.cpp</code></p>"},{"location":"TitanComms/Vtop____ALL_8cpp_source/","title":"File Vtop__ALL.cpp","text":"<p>File List &gt; comms &gt; verilog &gt; tests &gt; sim_build &gt; Vtop__ALL.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// DESCRIPTION: Generated by verilator_includer via makefile\n#define VL_INCLUDE_OPT include\n#include \"Vtop.cpp\"\n#include \"Vtop___024root__DepSet_h84412442__0.cpp\"\n#include \"Vtop___024root__DepSet_heccd7ead__0.cpp\"\n#include \"Vtop__Dpi.cpp\"\n#include \"Vtop__Trace__0.cpp\"\n#include \"Vtop___024root__Slow.cpp\"\n#include \"Vtop___024root__DepSet_h84412442__0__Slow.cpp\"\n#include \"Vtop___024root__DepSet_heccd7ead__0__Slow.cpp\"\n#include \"Vtop___024unit__Slow.cpp\"\n#include \"Vtop___024unit__DepSet_hff17caec__0__Slow.cpp\"\n#include \"Vtop__Syms.cpp\"\n#include \"Vtop__Trace__0__Slow.cpp\"\n</code></pre>"},{"location":"TitanComms/Vtop____Dpi_8cpp/","title":"File Vtop__Dpi.cpp","text":"<p>FileList &gt; comms &gt; verilog &gt; tests &gt; sim_build &gt; Vtop__Dpi.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Vtop__Dpi.h\"</code></li> <li><code>#include \"Vtop.h\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>titan/comms/verilog/tests/sim_build/Vtop__Dpi.cpp</code></p>"},{"location":"TitanComms/Vtop____Dpi_8cpp_source/","title":"File Vtop__Dpi.cpp","text":"<p>File List &gt; comms &gt; verilog &gt; tests &gt; sim_build &gt; Vtop__Dpi.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// Verilated -*- C++ -*-\n// DESCRIPTION: Verilator output: Implementation of DPI export functions.\n//\n// Verilator compiles this file in when DPI functions are used.\n// If you have multiple Verilated designs with the same DPI exported\n// function names, you will get multiple definition link errors from here.\n// This is an unfortunate result of the DPI specification.\n// To solve this, either\n//    1. Call Vtop::{export_function} instead,\n//       and do not even bother to compile this file\n// or 2. Compile all __Dpi.cpp files in the same compiler run,\n//       and #ifdefs already inserted here will sort everything out.\n\n#include \"Vtop__Dpi.h\"\n#include \"Vtop.h\"\n</code></pre>"},{"location":"TitanComms/Vtop____Dpi_8h/","title":"File Vtop__Dpi.h","text":"<p>FileList &gt; comms &gt; verilog &gt; tests &gt; sim_build &gt; Vtop__Dpi.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"svdpi.h\"</code></li> </ul>"},{"location":"TitanComms/Vtop____Dpi_8h/#macros","title":"Macros","text":"Type Name define VERILATED_VTOP__DPI_H_"},{"location":"TitanComms/Vtop____Dpi_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"TitanComms/Vtop____Dpi_8h/#define-verilated_vtop__dpi_h_","title":"define VERILATED_VTOP__DPI_H_","text":"<pre><code>#define VERILATED_VTOP__DPI_H_ \n</code></pre> <p>The documentation for this class was generated from the following file <code>titan/comms/verilog/tests/sim_build/Vtop__Dpi.h</code></p>"},{"location":"TitanComms/Vtop____Dpi_8h_source/","title":"File Vtop__Dpi.h","text":"<p>File List &gt; comms &gt; verilog &gt; tests &gt; sim_build &gt; Vtop__Dpi.h</p> <p>Go to the documentation of this file</p> <pre><code>// Verilated -*- C++ -*-\n// DESCRIPTION: Verilator output: Prototypes for DPI import and export functions.\n//\n// Verilator includes this file in all generated .cpp files that use DPI functions.\n// Manually include this file where DPI .c import functions are declared to ensure\n// the C functions match the expectations of the DPI imports.\n\n#ifndef VERILATED_VTOP__DPI_H_\n#define VERILATED_VTOP__DPI_H_  // guard\n\n#include \"svdpi.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif  // guard\n</code></pre>"},{"location":"TitanComms/Vtop____Syms_8cpp/","title":"File Vtop__Syms.cpp","text":"<p>FileList &gt; comms &gt; verilog &gt; tests &gt; sim_build &gt; Vtop__Syms.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Vtop__Syms.h\"</code></li> <li><code>#include \"Vtop.h\"</code></li> <li><code>#include \"Vtop___024root.h\"</code></li> <li><code>#include \"Vtop___024unit.h\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>titan/comms/verilog/tests/sim_build/Vtop__Syms.cpp</code></p>"},{"location":"TitanComms/Vtop____Syms_8cpp_source/","title":"File Vtop__Syms.cpp","text":"<p>File List &gt; comms &gt; verilog &gt; tests &gt; sim_build &gt; Vtop__Syms.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// Verilated -*- C++ -*-\n// DESCRIPTION: Verilator output: Symbol table implementation internals\n\n#include \"Vtop__Syms.h\"\n#include \"Vtop.h\"\n#include \"Vtop___024root.h\"\n#include \"Vtop___024unit.h\"\n\n// FUNCTIONS\nVtop__Syms::~Vtop__Syms()\n{\n\n    // Tear down scope hierarchy\n    __Vhier.remove(0, &amp;__Vscope_dut_param_mux);\n    __Vhier.remove(&amp;__Vscope_dut_param_mux, &amp;__Vscope_dut_param_mux__uut_pmux);\n\n#ifdef VM_TRACE\n    if (__Vm_dumping) _traceDumpClose();\n#endif  // VM_TRACE\n}\n\nvoid Vtop__Syms::_traceDump() {\n    const VerilatedLockGuard lock(__Vm_dumperMutex);\n    __Vm_dumperp-&gt;dump(VL_TIME_Q());\n}\n\nvoid Vtop__Syms::_traceDumpOpen() {\n    const VerilatedLockGuard lock(__Vm_dumperMutex);\n    if (VL_UNLIKELY(!__Vm_dumperp)) {\n        __Vm_dumperp = new VerilatedVcdC();\n        __Vm_modelp-&gt;trace(__Vm_dumperp, 0, 0);\n        std::string dumpfile = _vm_contextp__-&gt;dumpfileCheck();\n        __Vm_dumperp-&gt;open(dumpfile.c_str());\n        __Vm_dumping = true;\n    }\n}\n\nvoid Vtop__Syms::_traceDumpClose() {\n    const VerilatedLockGuard lock(__Vm_dumperMutex);\n    __Vm_dumping = false;\n    VL_DO_CLEAR(delete __Vm_dumperp, __Vm_dumperp = nullptr);\n}\n\nVtop__Syms::Vtop__Syms(VerilatedContext* contextp, const char* namep, Vtop* modelp)\n    : VerilatedSyms{contextp}\n    // Setup internal state of the Syms class\n    , __Vm_modelp{modelp}\n    // Setup module instances\n    , TOP{this, namep}\n{\n    // Configure time unit / time precision\n    _vm_contextp__-&gt;timeunit(-9);\n    _vm_contextp__-&gt;timeprecision(-12);\n    // Setup each module's pointers to their submodules\n    // Setup each module's pointer back to symbol table (for public functions)\n    TOP.__Vconfigure(true);\n    // Setup scopes\n    __Vscope_TOP.configure(this, name(), \"TOP\", \"TOP\", 0, VerilatedScope::SCOPE_OTHER);\n    __Vscope_dut_param_mux.configure(this, name(), \"dut_param_mux\", \"dut_param_mux\", -9, VerilatedScope::SCOPE_MODULE);\n    __Vscope_dut_param_mux__uut_pmux.configure(this, name(), \"dut_param_mux.uut_pmux\", \"uut_pmux\", -9, VerilatedScope::SCOPE_MODULE);\n\n    // Set up scope hierarchy\n    __Vhier.add(0, &amp;__Vscope_dut_param_mux);\n    __Vhier.add(&amp;__Vscope_dut_param_mux, &amp;__Vscope_dut_param_mux__uut_pmux);\n\n    // Setup export functions\n    for (int __Vfinal = 0; __Vfinal &lt; 2; ++__Vfinal) {\n        __Vscope_TOP.varInsert(__Vfinal,\"in1\", &amp;(TOP.in1), false, VLVT_UINT32,VLVD_IN|VLVF_PUB_RW,1 ,31,0);\n        __Vscope_TOP.varInsert(__Vfinal,\"in2\", &amp;(TOP.in2), false, VLVT_UINT32,VLVD_IN|VLVF_PUB_RW,1 ,31,0);\n        __Vscope_TOP.varInsert(__Vfinal,\"in3\", &amp;(TOP.in3), false, VLVT_UINT32,VLVD_IN|VLVF_PUB_RW,1 ,31,0);\n        __Vscope_TOP.varInsert(__Vfinal,\"in4\", &amp;(TOP.in4), false, VLVT_UINT32,VLVD_IN|VLVF_PUB_RW,1 ,31,0);\n        __Vscope_TOP.varInsert(__Vfinal,\"mux_o\", &amp;(TOP.mux_o), false, VLVT_UINT32,VLVD_OUT|VLVF_PUB_RW,1 ,31,0);\n        __Vscope_TOP.varInsert(__Vfinal,\"sel_i\", &amp;(TOP.sel_i), false, VLVT_UINT8,VLVD_IN|VLVF_PUB_RW,1 ,1,0);\n        __Vscope_dut_param_mux.varInsert(__Vfinal,\"in1\", &amp;(TOP.dut_param_mux__DOT__in1), false, VLVT_UINT32,VLVD_NODIR|VLVF_PUB_RW,1 ,31,0);\n        __Vscope_dut_param_mux.varInsert(__Vfinal,\"in2\", &amp;(TOP.dut_param_mux__DOT__in2), false, VLVT_UINT32,VLVD_NODIR|VLVF_PUB_RW,1 ,31,0);\n        __Vscope_dut_param_mux.varInsert(__Vfinal,\"in3\", &amp;(TOP.dut_param_mux__DOT__in3), false, VLVT_UINT32,VLVD_NODIR|VLVF_PUB_RW,1 ,31,0);\n        __Vscope_dut_param_mux.varInsert(__Vfinal,\"in4\", &amp;(TOP.dut_param_mux__DOT__in4), false, VLVT_UINT32,VLVD_NODIR|VLVF_PUB_RW,1 ,31,0);\n        __Vscope_dut_param_mux.varInsert(__Vfinal,\"mux_o\", &amp;(TOP.dut_param_mux__DOT__mux_o), false, VLVT_UINT32,VLVD_NODIR|VLVF_PUB_RW,1 ,31,0);\n        __Vscope_dut_param_mux.varInsert(__Vfinal,\"sel_i\", &amp;(TOP.dut_param_mux__DOT__sel_i), false, VLVT_UINT8,VLVD_NODIR|VLVF_PUB_RW,1 ,1,0);\n        __Vscope_dut_param_mux__uut_pmux.varInsert(__Vfinal,\"INPUT_WIDTH\", const_cast&lt;void*&gt;(static_cast&lt;const void*&gt;(&amp;(TOP.dut_param_mux__DOT__uut_pmux__DOT__INPUT_WIDTH))), true, VLVT_UINT32,VLVD_NODIR|VLVF_PUB_RW,1 ,31,0);\n        __Vscope_dut_param_mux__uut_pmux.varInsert(__Vfinal,\"SELECTOR_WIDTH\", const_cast&lt;void*&gt;(static_cast&lt;const void*&gt;(&amp;(TOP.dut_param_mux__DOT__uut_pmux__DOT__SELECTOR_WIDTH))), true, VLVT_UINT32,VLVD_NODIR|VLVF_PUB_RW,1 ,31,0);\n        __Vscope_dut_param_mux__uut_pmux.varInsert(__Vfinal,\"SIGNAL_COUNT\", const_cast&lt;void*&gt;(static_cast&lt;const void*&gt;(&amp;(TOP.dut_param_mux__DOT__uut_pmux__DOT__SIGNAL_COUNT))), true, VLVT_UINT32,VLVD_NODIR|VLVF_PUB_RW,1 ,31,0);\n        __Vscope_dut_param_mux__uut_pmux.varInsert(__Vfinal,\"inputs\", &amp;(TOP.dut_param_mux__DOT__uut_pmux__DOT__inputs), false, VLVT_UINT32,VLVD_NODIR|VLVF_PUB_RW,2 ,31,0 ,0,3);\n        __Vscope_dut_param_mux__uut_pmux.varInsert(__Vfinal,\"out\", &amp;(TOP.dut_param_mux__DOT__uut_pmux__DOT__out), false, VLVT_UINT32,VLVD_NODIR|VLVF_PUB_RW,1 ,31,0);\n        __Vscope_dut_param_mux__uut_pmux.varInsert(__Vfinal,\"selector\", &amp;(TOP.dut_param_mux__DOT__uut_pmux__DOT__selector), false, VLVT_UINT8,VLVD_NODIR|VLVF_PUB_RW,1 ,1,0);\n    }\n}\n</code></pre>"},{"location":"TitanComms/Vtop____Syms_8h/","title":"File Vtop__Syms.h","text":"<p>FileList &gt; comms &gt; verilog &gt; tests &gt; sim_build &gt; Vtop__Syms.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"verilated.h\"</code></li> <li><code>#include \"verilated_vcd_c.h\"</code></li> <li><code>#include \"Vtop.h\"</code></li> <li><code>#include \"Vtop___024root.h\"</code></li> <li><code>#include \"Vtop___024unit.h\"</code></li> </ul>"},{"location":"TitanComms/Vtop____Syms_8h/#classes","title":"Classes","text":"Type Name class Vtop__Syms"},{"location":"TitanComms/Vtop____Syms_8h/#public-attributes","title":"Public Attributes","text":"Type Name Vtop___024root TOP VerilatedHierarchy __Vhier bool __Vm_activity   = = falseTrace class for $dump*. uint32_t __Vm_baseCode   = = 0Used by trace routines when tracing multiple models. bool __Vm_didInit   = = false VerilatedMutex __Vm_dumperMutex bool __Vm_dumping   = = false Vtop *const __Vm_modelp VerilatedScope __Vscope_TOP VerilatedScope __Vscope_dut_param_mux VerilatedScope __Vscope_dut_param_mux__uut_pmux"},{"location":"TitanComms/Vtop____Syms_8h/#public-functions","title":"Public Functions","text":"Type Name Vtop__Syms VerilatedSyms VL_ATTR_ALIGNED (VL_CACHE_LINE_BYTES)  VerilatedVcdC *__Vm_dumperp VL_GUARDED_BY (__Vm_dumperMutex)  Vtop__Syms (VerilatedContext * contextp, const char * namep, Vtop * modelp)  void _traceDump ()  void _traceDumpClose ()  void _traceDumpOpen ()  const char * name ()  ~Vtop__Syms ()"},{"location":"TitanComms/Vtop____Syms_8h/#macros","title":"Macros","text":"Type Name define VERILATED_VTOP__SYMS_H_"},{"location":"TitanComms/Vtop____Syms_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"TitanComms/Vtop____Syms_8h/#variable-top","title":"variable TOP","text":"<pre><code>Vtop___024root TOP;\n</code></pre>"},{"location":"TitanComms/Vtop____Syms_8h/#variable-__vhier","title":"variable __Vhier","text":"<pre><code>VerilatedHierarchy __Vhier;\n</code></pre>"},{"location":"TitanComms/Vtop____Syms_8h/#variable-__vm_activity","title":"variable __Vm_activity","text":"<p>Trace class for $dump*. <pre><code>bool __Vm_activity;\n</code></pre></p> <p>Used by trace routines to determine change occurred </p>"},{"location":"TitanComms/Vtop____Syms_8h/#variable-__vm_basecode","title":"variable __Vm_baseCode","text":"<pre><code>uint32_t __Vm_baseCode;\n</code></pre>"},{"location":"TitanComms/Vtop____Syms_8h/#variable-__vm_didinit","title":"variable __Vm_didInit","text":"<pre><code>bool __Vm_didInit;\n</code></pre>"},{"location":"TitanComms/Vtop____Syms_8h/#variable-__vm_dumpermutex","title":"variable __Vm_dumperMutex","text":"<pre><code>VerilatedMutex __Vm_dumperMutex;\n</code></pre>"},{"location":"TitanComms/Vtop____Syms_8h/#variable-__vm_dumping","title":"variable __Vm_dumping","text":"<pre><code>bool __Vm_dumping;\n</code></pre>"},{"location":"TitanComms/Vtop____Syms_8h/#variable-__vm_modelp","title":"variable __Vm_modelp","text":"<pre><code>Vtop* const __Vm_modelp;\n</code></pre>"},{"location":"TitanComms/Vtop____Syms_8h/#variable-__vscope_top","title":"variable __Vscope_TOP","text":"<pre><code>VerilatedScope __Vscope_TOP;\n</code></pre>"},{"location":"TitanComms/Vtop____Syms_8h/#variable-__vscope_dut_param_mux","title":"variable __Vscope_dut_param_mux","text":"<pre><code>VerilatedScope __Vscope_dut_param_mux;\n</code></pre>"},{"location":"TitanComms/Vtop____Syms_8h/#variable-__vscope_dut_param_mux__uut_pmux","title":"variable __Vscope_dut_param_mux__uut_pmux","text":"<pre><code>VerilatedScope __Vscope_dut_param_mux__uut_pmux;\n</code></pre>"},{"location":"TitanComms/Vtop____Syms_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"TitanComms/Vtop____Syms_8h/#function-vl_attr_aligned","title":"function VL_ATTR_ALIGNED","text":"<pre><code>Vtop__Syms VerilatedSyms VL_ATTR_ALIGNED (\n    VL_CACHE_LINE_BYTES\n) \n</code></pre>"},{"location":"TitanComms/Vtop____Syms_8h/#function-vl_guarded_by","title":"function VL_GUARDED_BY","text":"<pre><code>VerilatedVcdC *__Vm_dumperp VL_GUARDED_BY (\n    __Vm_dumperMutex\n) \n</code></pre>"},{"location":"TitanComms/Vtop____Syms_8h/#function-vtop__syms","title":"function Vtop__Syms","text":"<pre><code>Vtop__Syms (\n    VerilatedContext * contextp,\n    const char * namep,\n    Vtop * modelp\n) \n</code></pre>"},{"location":"TitanComms/Vtop____Syms_8h/#function-_tracedump","title":"function _traceDump","text":"<pre><code>void _traceDump () \n</code></pre>"},{"location":"TitanComms/Vtop____Syms_8h/#function-_tracedumpclose","title":"function _traceDumpClose","text":"<pre><code>void _traceDumpClose () \n</code></pre>"},{"location":"TitanComms/Vtop____Syms_8h/#function-_tracedumpopen","title":"function _traceDumpOpen","text":"<pre><code>void _traceDumpOpen () \n</code></pre>"},{"location":"TitanComms/Vtop____Syms_8h/#function-name","title":"function name","text":"<pre><code>const char * name () \n</code></pre>"},{"location":"TitanComms/Vtop____Syms_8h/#function-vtop__syms_1","title":"function ~Vtop__Syms","text":"<pre><code>~Vtop__Syms () \n</code></pre>"},{"location":"TitanComms/Vtop____Syms_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"TitanComms/Vtop____Syms_8h/#define-verilated_vtop__syms_h_","title":"define VERILATED_VTOP__SYMS_H_","text":"<pre><code>#define VERILATED_VTOP__SYMS_H_ \n</code></pre> <p>The documentation for this class was generated from the following file <code>titan/comms/verilog/tests/sim_build/Vtop__Syms.h</code></p>"},{"location":"TitanComms/Vtop____Syms_8h_source/","title":"File Vtop__Syms.h","text":"<p>File List &gt; comms &gt; verilog &gt; tests &gt; sim_build &gt; Vtop__Syms.h</p> <p>Go to the documentation of this file</p> <pre><code>// Verilated -*- C++ -*-\n// DESCRIPTION: Verilator output: Symbol table internal header\n//\n// Internal details; most calling programs do not need this header,\n// unless using verilator public meta comments.\n\n#ifndef VERILATED_VTOP__SYMS_H_\n#define VERILATED_VTOP__SYMS_H_  // guard\n\n#include \"verilated.h\"\n#include \"verilated_vcd_c.h\"\n\n// INCLUDE MODEL CLASS\n\n#include \"Vtop.h\"\n\n// INCLUDE MODULE CLASSES\n#include \"Vtop___024root.h\"\n#include \"Vtop___024unit.h\"\n\n// DPI TYPES for DPI Export callbacks (Internal use)\n\n// SYMS CLASS (contains all model state)\nclass Vtop__Syms final : public VerilatedSyms {\n  public:\n    // INTERNAL STATE\n    Vtop* const __Vm_modelp;\n    bool __Vm_dumping = false;  // Dumping is active\n    VerilatedMutex __Vm_dumperMutex;  // Protect __Vm_dumperp\n    VerilatedVcdC* __Vm_dumperp VL_GUARDED_BY(__Vm_dumperMutex) = nullptr;  \n    bool __Vm_activity = false;  \n    uint32_t __Vm_baseCode = 0;  \n    bool __Vm_didInit = false;\n\n    // MODULE INSTANCE STATE\n    Vtop___024root                 TOP;\n\n    // SCOPE NAMES\n    VerilatedScope __Vscope_TOP;\n    VerilatedScope __Vscope_dut_param_mux;\n    VerilatedScope __Vscope_dut_param_mux__uut_pmux;\n\n    // SCOPE HIERARCHY\n    VerilatedHierarchy __Vhier;\n\n    // CONSTRUCTORS\n    Vtop__Syms(VerilatedContext* contextp, const char* namep, Vtop* modelp);\n    ~Vtop__Syms();\n\n    // METHODS\n    const char* name() { return TOP.name(); }\n    void _traceDump();\n    void _traceDumpOpen();\n    void _traceDumpClose();\n} VL_ATTR_ALIGNED(VL_CACHE_LINE_BYTES);\n\n#endif  // guard\n</code></pre>"},{"location":"TitanComms/Vtop____Trace____0_8cpp/","title":"File Vtop__Trace__0.cpp","text":"<p>FileList &gt; comms &gt; verilog &gt; tests &gt; sim_build &gt; Vtop__Trace__0.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"verilated_vcd_c.h\"</code></li> <li><code>#include \"Vtop__Syms.h\"</code></li> </ul>"},{"location":"TitanComms/Vtop____Trace____0_8cpp/#public-functions","title":"Public Functions","text":"Type Name void Vtop___024root__trace_chg_sub_0 (Vtop___024root * vlSelf, VerilatedVcd::Buffer * bufp)  void Vtop___024root__trace_chg_top_0 (void * voidSelf, VerilatedVcd::Buffer * bufp)  void Vtop___024root__trace_cleanup (void * voidSelf, VerilatedVcd *)"},{"location":"TitanComms/Vtop____Trace____0_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"TitanComms/Vtop____Trace____0_8cpp/#function-vtop___024root__trace_chg_sub_0","title":"function Vtop___024root__trace_chg_sub_0","text":"<pre><code>void Vtop___024root__trace_chg_sub_0 (\n    Vtop___024root * vlSelf,\n    VerilatedVcd::Buffer * bufp\n) \n</code></pre>"},{"location":"TitanComms/Vtop____Trace____0_8cpp/#function-vtop___024root__trace_chg_top_0","title":"function Vtop___024root__trace_chg_top_0","text":"<pre><code>void Vtop___024root__trace_chg_top_0 (\n    void * voidSelf,\n    VerilatedVcd::Buffer * bufp\n) \n</code></pre>"},{"location":"TitanComms/Vtop____Trace____0_8cpp/#function-vtop___024root__trace_cleanup","title":"function Vtop___024root__trace_cleanup","text":"<pre><code>void Vtop___024root__trace_cleanup (\n    void * voidSelf,\n    VerilatedVcd *\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>titan/comms/verilog/tests/sim_build/Vtop__Trace__0.cpp</code></p>"},{"location":"TitanComms/Vtop____Trace____0_8cpp_source/","title":"File Vtop__Trace__0.cpp","text":"<p>File List &gt; comms &gt; verilog &gt; tests &gt; sim_build &gt; Vtop__Trace__0.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// Verilated -*- C++ -*-\n// DESCRIPTION: Verilator output: Tracing implementation internals\n#include \"verilated_vcd_c.h\"\n#include \"Vtop__Syms.h\"\n\n\nvoid Vtop___024root__trace_chg_sub_0(Vtop___024root* vlSelf, VerilatedVcd::Buffer* bufp);\n\nvoid Vtop___024root__trace_chg_top_0(void* voidSelf, VerilatedVcd::Buffer* bufp) {\n    VL_DEBUG_IF(VL_DBG_MSGF(\"+    Vtop___024root__trace_chg_top_0\\n\"); );\n    // Init\n    Vtop___024root* const __restrict vlSelf VL_ATTR_UNUSED = static_cast&lt;Vtop___024root*&gt;(voidSelf);\n    Vtop__Syms* const __restrict vlSymsp VL_ATTR_UNUSED = vlSelf-&gt;vlSymsp;\n    if (VL_UNLIKELY(!vlSymsp-&gt;__Vm_activity)) return;\n    // Body\n    Vtop___024root__trace_chg_sub_0((&amp;vlSymsp-&gt;TOP), bufp);\n}\n\nvoid Vtop___024root__trace_chg_sub_0(Vtop___024root* vlSelf, VerilatedVcd::Buffer* bufp) {\n    if (false &amp;&amp; vlSelf) {}  // Prevent unused\n    Vtop__Syms* const __restrict vlSymsp VL_ATTR_UNUSED = vlSelf-&gt;vlSymsp;\n    VL_DEBUG_IF(VL_DBG_MSGF(\"+    Vtop___024root__trace_chg_sub_0\\n\"); );\n    // Init\n    uint32_t* const oldp VL_ATTR_UNUSED = bufp-&gt;oldp(vlSymsp-&gt;__Vm_baseCode + 1);\n    // Body\n    bufp-&gt;chgIData(oldp+0,(vlSelf-&gt;in1),32);\n    bufp-&gt;chgIData(oldp+1,(vlSelf-&gt;in2),32);\n    bufp-&gt;chgIData(oldp+2,(vlSelf-&gt;in3),32);\n    bufp-&gt;chgIData(oldp+3,(vlSelf-&gt;in4),32);\n    bufp-&gt;chgCData(oldp+4,(vlSelf-&gt;sel_i),2);\n    bufp-&gt;chgIData(oldp+5,(vlSelf-&gt;mux_o),32);\n    bufp-&gt;chgIData(oldp+6,(vlSelf-&gt;dut_param_mux__DOT__in1),32);\n    bufp-&gt;chgIData(oldp+7,(vlSelf-&gt;dut_param_mux__DOT__in2),32);\n    bufp-&gt;chgIData(oldp+8,(vlSelf-&gt;dut_param_mux__DOT__in3),32);\n    bufp-&gt;chgIData(oldp+9,(vlSelf-&gt;dut_param_mux__DOT__in4),32);\n    bufp-&gt;chgCData(oldp+10,(vlSelf-&gt;dut_param_mux__DOT__sel_i),2);\n    bufp-&gt;chgIData(oldp+11,(vlSelf-&gt;dut_param_mux__DOT__mux_o),32);\n    bufp-&gt;chgCData(oldp+12,(vlSelf-&gt;dut_param_mux__DOT__uut_pmux__DOT__selector),2);\n    bufp-&gt;chgIData(oldp+13,(vlSelf-&gt;dut_param_mux__DOT__uut_pmux__DOT__inputs[0]),32);\n    bufp-&gt;chgIData(oldp+14,(vlSelf-&gt;dut_param_mux__DOT__uut_pmux__DOT__inputs[1]),32);\n    bufp-&gt;chgIData(oldp+15,(vlSelf-&gt;dut_param_mux__DOT__uut_pmux__DOT__inputs[2]),32);\n    bufp-&gt;chgIData(oldp+16,(vlSelf-&gt;dut_param_mux__DOT__uut_pmux__DOT__inputs[3]),32);\n    bufp-&gt;chgIData(oldp+17,(vlSelf-&gt;dut_param_mux__DOT__uut_pmux__DOT__out),32);\n}\n\nvoid Vtop___024root__trace_cleanup(void* voidSelf, VerilatedVcd* /*unused*/) {\n    VL_DEBUG_IF(VL_DBG_MSGF(\"+    Vtop___024root__trace_cleanup\\n\"); );\n    // Init\n    Vtop___024root* const __restrict vlSelf VL_ATTR_UNUSED = static_cast&lt;Vtop___024root*&gt;(voidSelf);\n    Vtop__Syms* const __restrict vlSymsp VL_ATTR_UNUSED = vlSelf-&gt;vlSymsp;\n    VlUnpacked&lt;CData/*0:0*/, 1&gt; __Vm_traceActivity;\n    for (int __Vi0 = 0; __Vi0 &lt; 1; ++__Vi0) {\n        __Vm_traceActivity[__Vi0] = 0;\n    }\n    // Body\n    vlSymsp-&gt;__Vm_activity = false;\n    __Vm_traceActivity[0U] = 0U;\n}\n</code></pre>"},{"location":"TitanComms/Vtop____Trace____0____Slow_8cpp/","title":"File Vtop__Trace__0__Slow.cpp","text":"<p>FileList &gt; comms &gt; verilog &gt; tests &gt; sim_build &gt; Vtop__Trace__0__Slow.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"verilated_vcd_c.h\"</code></li> <li><code>#include \"Vtop__Syms.h\"</code></li> </ul>"},{"location":"TitanComms/Vtop____Trace____0____Slow_8cpp/#public-functions","title":"Public Functions","text":"Type Name void Vtop___024root__trace_chg_top_0 (void * voidSelf, VerilatedVcd::Buffer * bufp)  void Vtop___024root__trace_cleanup (void * voidSelf, VerilatedVcd *)  VL_ATTR_COLD void Vtop___024root__trace_full_sub_0 (Vtop___024root * vlSelf, VerilatedVcd::Buffer * bufp)  VL_ATTR_COLD void Vtop___024root__trace_full_top_0 (void * voidSelf, VerilatedVcd::Buffer * bufp)  VL_ATTR_COLD void Vtop___024root__trace_init_sub__TOP__0 (Vtop___024root * vlSelf, VerilatedVcd * tracep)  VL_ATTR_COLD void Vtop___024root__trace_init_top (Vtop___024root * vlSelf, VerilatedVcd * tracep)  VL_ATTR_COLD void Vtop___024root__trace_register (Vtop___024root * vlSelf, VerilatedVcd * tracep)"},{"location":"TitanComms/Vtop____Trace____0____Slow_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"TitanComms/Vtop____Trace____0____Slow_8cpp/#function-vtop___024root__trace_chg_top_0","title":"function Vtop___024root__trace_chg_top_0","text":"<pre><code>void Vtop___024root__trace_chg_top_0 (\n    void * voidSelf,\n    VerilatedVcd::Buffer * bufp\n) \n</code></pre>"},{"location":"TitanComms/Vtop____Trace____0____Slow_8cpp/#function-vtop___024root__trace_cleanup","title":"function Vtop___024root__trace_cleanup","text":"<pre><code>void Vtop___024root__trace_cleanup (\n    void * voidSelf,\n    VerilatedVcd *\n) \n</code></pre>"},{"location":"TitanComms/Vtop____Trace____0____Slow_8cpp/#function-vtop___024root__trace_full_sub_0","title":"function Vtop___024root__trace_full_sub_0","text":"<pre><code>VL_ATTR_COLD void Vtop___024root__trace_full_sub_0 (\n    Vtop___024root * vlSelf,\n    VerilatedVcd::Buffer * bufp\n) \n</code></pre>"},{"location":"TitanComms/Vtop____Trace____0____Slow_8cpp/#function-vtop___024root__trace_full_top_0","title":"function Vtop___024root__trace_full_top_0","text":"<pre><code>VL_ATTR_COLD void Vtop___024root__trace_full_top_0 (\n    void * voidSelf,\n    VerilatedVcd::Buffer * bufp\n) \n</code></pre>"},{"location":"TitanComms/Vtop____Trace____0____Slow_8cpp/#function-vtop___024root__trace_init_sub__top__0","title":"function Vtop___024root__trace_init_sub__TOP__0","text":"<pre><code>VL_ATTR_COLD void Vtop___024root__trace_init_sub__TOP__0 (\n    Vtop___024root * vlSelf,\n    VerilatedVcd * tracep\n) \n</code></pre>"},{"location":"TitanComms/Vtop____Trace____0____Slow_8cpp/#function-vtop___024root__trace_init_top","title":"function Vtop___024root__trace_init_top","text":"<pre><code>VL_ATTR_COLD void Vtop___024root__trace_init_top (\n    Vtop___024root * vlSelf,\n    VerilatedVcd * tracep\n) \n</code></pre>"},{"location":"TitanComms/Vtop____Trace____0____Slow_8cpp/#function-vtop___024root__trace_register","title":"function Vtop___024root__trace_register","text":"<pre><code>VL_ATTR_COLD void Vtop___024root__trace_register (\n    Vtop___024root * vlSelf,\n    VerilatedVcd * tracep\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>titan/comms/verilog/tests/sim_build/Vtop__Trace__0__Slow.cpp</code></p>"},{"location":"TitanComms/Vtop____Trace____0____Slow_8cpp_source/","title":"File Vtop__Trace__0__Slow.cpp","text":"<p>File List &gt; comms &gt; verilog &gt; tests &gt; sim_build &gt; Vtop__Trace__0__Slow.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// Verilated -*- C++ -*-\n// DESCRIPTION: Verilator output: Tracing implementation internals\n#include \"verilated_vcd_c.h\"\n#include \"Vtop__Syms.h\"\n\n\nVL_ATTR_COLD void Vtop___024root__trace_init_sub__TOP__0(Vtop___024root* vlSelf, VerilatedVcd* tracep) {\n    if (false &amp;&amp; vlSelf) {}  // Prevent unused\n    Vtop__Syms* const __restrict vlSymsp VL_ATTR_UNUSED = vlSelf-&gt;vlSymsp;\n    VL_DEBUG_IF(VL_DBG_MSGF(\"+    Vtop___024root__trace_init_sub__TOP__0\\n\"); );\n    // Init\n    const int c = vlSymsp-&gt;__Vm_baseCode;\n    // Body\n    tracep-&gt;declBus(c+1,\"in1\", false,-1, 31,0);\n    tracep-&gt;declBus(c+2,\"in2\", false,-1, 31,0);\n    tracep-&gt;declBus(c+3,\"in3\", false,-1, 31,0);\n    tracep-&gt;declBus(c+4,\"in4\", false,-1, 31,0);\n    tracep-&gt;declBus(c+5,\"sel_i\", false,-1, 1,0);\n    tracep-&gt;declBus(c+6,\"mux_o\", false,-1, 31,0);\n    tracep-&gt;pushNamePrefix(\"dut_param_mux \");\n    tracep-&gt;declBus(c+7,\"in1\", false,-1, 31,0);\n    tracep-&gt;declBus(c+8,\"in2\", false,-1, 31,0);\n    tracep-&gt;declBus(c+9,\"in3\", false,-1, 31,0);\n    tracep-&gt;declBus(c+10,\"in4\", false,-1, 31,0);\n    tracep-&gt;declBus(c+11,\"sel_i\", false,-1, 1,0);\n    tracep-&gt;declBus(c+12,\"mux_o\", false,-1, 31,0);\n    tracep-&gt;pushNamePrefix(\"uut_pmux \");\n    tracep-&gt;declBus(c+19,\"INPUT_WIDTH\", false,-1, 31,0);\n    tracep-&gt;declBus(c+20,\"SELECTOR_WIDTH\", false,-1, 31,0);\n    tracep-&gt;declBus(c+21,\"SIGNAL_COUNT\", false,-1, 31,0);\n    tracep-&gt;declBus(c+13,\"selector\", false,-1, 1,0);\n    for (int i = 0; i &lt; 4; ++i) {\n        tracep-&gt;declBus(c+14+i*1,\"inputs\", true,(i+0), 31,0);\n    }\n    tracep-&gt;declBus(c+18,\"out\", false,-1, 31,0);\n    tracep-&gt;popNamePrefix(2);\n}\n\nVL_ATTR_COLD void Vtop___024root__trace_init_top(Vtop___024root* vlSelf, VerilatedVcd* tracep) {\n    if (false &amp;&amp; vlSelf) {}  // Prevent unused\n    Vtop__Syms* const __restrict vlSymsp VL_ATTR_UNUSED = vlSelf-&gt;vlSymsp;\n    VL_DEBUG_IF(VL_DBG_MSGF(\"+    Vtop___024root__trace_init_top\\n\"); );\n    // Body\n    Vtop___024root__trace_init_sub__TOP__0(vlSelf, tracep);\n}\n\nVL_ATTR_COLD void Vtop___024root__trace_full_top_0(void* voidSelf, VerilatedVcd::Buffer* bufp);\nvoid Vtop___024root__trace_chg_top_0(void* voidSelf, VerilatedVcd::Buffer* bufp);\nvoid Vtop___024root__trace_cleanup(void* voidSelf, VerilatedVcd* /*unused*/);\n\nVL_ATTR_COLD void Vtop___024root__trace_register(Vtop___024root* vlSelf, VerilatedVcd* tracep) {\n    if (false &amp;&amp; vlSelf) {}  // Prevent unused\n    Vtop__Syms* const __restrict vlSymsp VL_ATTR_UNUSED = vlSelf-&gt;vlSymsp;\n    VL_DEBUG_IF(VL_DBG_MSGF(\"+    Vtop___024root__trace_register\\n\"); );\n    // Body\n    tracep-&gt;addFullCb(&amp;Vtop___024root__trace_full_top_0, vlSelf);\n    tracep-&gt;addChgCb(&amp;Vtop___024root__trace_chg_top_0, vlSelf);\n    tracep-&gt;addCleanupCb(&amp;Vtop___024root__trace_cleanup, vlSelf);\n}\n\nVL_ATTR_COLD void Vtop___024root__trace_full_sub_0(Vtop___024root* vlSelf, VerilatedVcd::Buffer* bufp);\n\nVL_ATTR_COLD void Vtop___024root__trace_full_top_0(void* voidSelf, VerilatedVcd::Buffer* bufp) {\n    VL_DEBUG_IF(VL_DBG_MSGF(\"+    Vtop___024root__trace_full_top_0\\n\"); );\n    // Init\n    Vtop___024root* const __restrict vlSelf VL_ATTR_UNUSED = static_cast&lt;Vtop___024root*&gt;(voidSelf);\n    Vtop__Syms* const __restrict vlSymsp VL_ATTR_UNUSED = vlSelf-&gt;vlSymsp;\n    // Body\n    Vtop___024root__trace_full_sub_0((&amp;vlSymsp-&gt;TOP), bufp);\n}\n\nVL_ATTR_COLD void Vtop___024root__trace_full_sub_0(Vtop___024root* vlSelf, VerilatedVcd::Buffer* bufp) {\n    if (false &amp;&amp; vlSelf) {}  // Prevent unused\n    Vtop__Syms* const __restrict vlSymsp VL_ATTR_UNUSED = vlSelf-&gt;vlSymsp;\n    VL_DEBUG_IF(VL_DBG_MSGF(\"+    Vtop___024root__trace_full_sub_0\\n\"); );\n    // Init\n    uint32_t* const oldp VL_ATTR_UNUSED = bufp-&gt;oldp(vlSymsp-&gt;__Vm_baseCode);\n    // Body\n    bufp-&gt;fullIData(oldp+1,(vlSelf-&gt;in1),32);\n    bufp-&gt;fullIData(oldp+2,(vlSelf-&gt;in2),32);\n    bufp-&gt;fullIData(oldp+3,(vlSelf-&gt;in3),32);\n    bufp-&gt;fullIData(oldp+4,(vlSelf-&gt;in4),32);\n    bufp-&gt;fullCData(oldp+5,(vlSelf-&gt;sel_i),2);\n    bufp-&gt;fullIData(oldp+6,(vlSelf-&gt;mux_o),32);\n    bufp-&gt;fullIData(oldp+7,(vlSelf-&gt;dut_param_mux__DOT__in1),32);\n    bufp-&gt;fullIData(oldp+8,(vlSelf-&gt;dut_param_mux__DOT__in2),32);\n    bufp-&gt;fullIData(oldp+9,(vlSelf-&gt;dut_param_mux__DOT__in3),32);\n    bufp-&gt;fullIData(oldp+10,(vlSelf-&gt;dut_param_mux__DOT__in4),32);\n    bufp-&gt;fullCData(oldp+11,(vlSelf-&gt;dut_param_mux__DOT__sel_i),2);\n    bufp-&gt;fullIData(oldp+12,(vlSelf-&gt;dut_param_mux__DOT__mux_o),32);\n    bufp-&gt;fullCData(oldp+13,(vlSelf-&gt;dut_param_mux__DOT__uut_pmux__DOT__selector),2);\n    bufp-&gt;fullIData(oldp+14,(vlSelf-&gt;dut_param_mux__DOT__uut_pmux__DOT__inputs[0]),32);\n    bufp-&gt;fullIData(oldp+15,(vlSelf-&gt;dut_param_mux__DOT__uut_pmux__DOT__inputs[1]),32);\n    bufp-&gt;fullIData(oldp+16,(vlSelf-&gt;dut_param_mux__DOT__uut_pmux__DOT__inputs[2]),32);\n    bufp-&gt;fullIData(oldp+17,(vlSelf-&gt;dut_param_mux__DOT__uut_pmux__DOT__inputs[3]),32);\n    bufp-&gt;fullIData(oldp+18,(vlSelf-&gt;dut_param_mux__DOT__uut_pmux__DOT__out),32);\n    bufp-&gt;fullIData(oldp+19,(0x20U),32);\n    bufp-&gt;fullIData(oldp+20,(2U),32);\n    bufp-&gt;fullIData(oldp+21,(4U),32);\n}\n</code></pre>"},{"location":"TitanComms/Vtop______024root_8h/","title":"File Vtop___024root.h","text":"<p>FileList &gt; comms &gt; verilog &gt; tests &gt; sim_build &gt; Vtop___024root.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"verilated.h\"</code></li> <li><code>#include \"verilated_timing.h\"</code></li> </ul>"},{"location":"TitanComms/Vtop______024root_8h/#classes","title":"Classes","text":"Type Name class Vtop___024root"},{"location":"TitanComms/Vtop______024root_8h/#public-attributes","title":"Public Attributes","text":"Type Name CData __VactContinue IData __VactIterCount VlTriggerVec&lt; 1 &gt; __VactTriggered VlDelayScheduler __VdlySched IData __VicoIterCount VlTriggerVec&lt; 1 &gt; __VicoTriggered VlTriggerVec&lt; 1 &gt; __VnbaTriggered IData __VstlIterCount VlTriggerVec&lt; 1 &gt; __VstlTriggered VlUnpacked&lt; IData, 4 &gt; dut_param_mux__DOT____Vcellinp__uut_pmux__inputs IData dut_param_mux__DOT__in1 IData dut_param_mux__DOT__in2 IData dut_param_mux__DOT__in3 IData dut_param_mux__DOT__in4 IData dut_param_mux__DOT__mux_o CData dut_param_mux__DOT__sel_i VlUnpacked&lt; IData, 4 &gt; dut_param_mux__DOT__uut_pmux__DOT__inputs IData dut_param_mux__DOT__uut_pmux__DOT__out CData dut_param_mux__DOT__uut_pmux__DOT__selector Vtop__Syms *const vlSymsp"},{"location":"TitanComms/Vtop______024root_8h/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr IData dut_param_mux__DOT__uut_pmux__DOT__INPUT_WIDTH   = = 0x00000020U constexpr IData dut_param_mux__DOT__uut_pmux__DOT__SELECTOR_WIDTH   = = 2U constexpr IData dut_param_mux__DOT__uut_pmux__DOT__SIGNAL_COUNT   = = 4U"},{"location":"TitanComms/Vtop______024root_8h/#public-functions","title":"Public Functions","text":"Type Name Vtop___024root VerilatedModule VL_ATTR_ALIGNED (VL_CACHE_LINE_BYTES)  VL_IN (in1, 31, 0)  VL_IN (in2, 31, 0)  VL_IN (in3, 31, 0)  VL_IN (in4, 31, 0)  VL_IN8 (sel_i, 1, 0)  VL_OUT (mux_o, 31, 0)  VL_UNCOPYABLE (Vtop___024root)  Vtop___024root (Vtop__Syms * symsp, const char * v__name)  void __Vconfigure (bool first)  ~Vtop___024root ()"},{"location":"TitanComms/Vtop______024root_8h/#macros","title":"Macros","text":"Type Name define VERILATED_VTOP___024ROOT_H_"},{"location":"TitanComms/Vtop______024root_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"TitanComms/Vtop______024root_8h/#variable-__vactcontinue","title":"variable __VactContinue","text":"<pre><code>CData __VactContinue;\n</code></pre>"},{"location":"TitanComms/Vtop______024root_8h/#variable-__vactitercount","title":"variable __VactIterCount","text":"<pre><code>IData __VactIterCount;\n</code></pre>"},{"location":"TitanComms/Vtop______024root_8h/#variable-__vacttriggered","title":"variable __VactTriggered","text":"<pre><code>VlTriggerVec&lt;1&gt; __VactTriggered;\n</code></pre>"},{"location":"TitanComms/Vtop______024root_8h/#variable-__vdlysched","title":"variable __VdlySched","text":"<pre><code>VlDelayScheduler __VdlySched;\n</code></pre>"},{"location":"TitanComms/Vtop______024root_8h/#variable-__vicoitercount","title":"variable __VicoIterCount","text":"<pre><code>IData __VicoIterCount;\n</code></pre>"},{"location":"TitanComms/Vtop______024root_8h/#variable-__vicotriggered","title":"variable __VicoTriggered","text":"<pre><code>VlTriggerVec&lt;1&gt; __VicoTriggered;\n</code></pre>"},{"location":"TitanComms/Vtop______024root_8h/#variable-__vnbatriggered","title":"variable __VnbaTriggered","text":"<pre><code>VlTriggerVec&lt;1&gt; __VnbaTriggered;\n</code></pre>"},{"location":"TitanComms/Vtop______024root_8h/#variable-__vstlitercount","title":"variable __VstlIterCount","text":"<pre><code>IData __VstlIterCount;\n</code></pre>"},{"location":"TitanComms/Vtop______024root_8h/#variable-__vstltriggered","title":"variable __VstlTriggered","text":"<pre><code>VlTriggerVec&lt;1&gt; __VstlTriggered;\n</code></pre>"},{"location":"TitanComms/Vtop______024root_8h/#variable-dut_param_mux__dot____vcellinp__uut_pmux__inputs","title":"variable dut_param_mux__DOT____Vcellinp__uut_pmux__inputs","text":"<pre><code>VlUnpacked&lt;IData, 4&gt; dut_param_mux__DOT____Vcellinp__uut_pmux__inputs;\n</code></pre>"},{"location":"TitanComms/Vtop______024root_8h/#variable-dut_param_mux__dot__in1","title":"variable dut_param_mux__DOT__in1","text":"<pre><code>IData dut_param_mux__DOT__in1;\n</code></pre>"},{"location":"TitanComms/Vtop______024root_8h/#variable-dut_param_mux__dot__in2","title":"variable dut_param_mux__DOT__in2","text":"<pre><code>IData dut_param_mux__DOT__in2;\n</code></pre>"},{"location":"TitanComms/Vtop______024root_8h/#variable-dut_param_mux__dot__in3","title":"variable dut_param_mux__DOT__in3","text":"<pre><code>IData dut_param_mux__DOT__in3;\n</code></pre>"},{"location":"TitanComms/Vtop______024root_8h/#variable-dut_param_mux__dot__in4","title":"variable dut_param_mux__DOT__in4","text":"<pre><code>IData dut_param_mux__DOT__in4;\n</code></pre>"},{"location":"TitanComms/Vtop______024root_8h/#variable-dut_param_mux__dot__mux_o","title":"variable dut_param_mux__DOT__mux_o","text":"<pre><code>IData dut_param_mux__DOT__mux_o;\n</code></pre>"},{"location":"TitanComms/Vtop______024root_8h/#variable-dut_param_mux__dot__sel_i","title":"variable dut_param_mux__DOT__sel_i","text":"<pre><code>CData dut_param_mux__DOT__sel_i;\n</code></pre>"},{"location":"TitanComms/Vtop______024root_8h/#variable-dut_param_mux__dot__uut_pmux__dot__inputs","title":"variable dut_param_mux__DOT__uut_pmux__DOT__inputs","text":"<pre><code>VlUnpacked&lt;IData, 4&gt; dut_param_mux__DOT__uut_pmux__DOT__inputs;\n</code></pre>"},{"location":"TitanComms/Vtop______024root_8h/#variable-dut_param_mux__dot__uut_pmux__dot__out","title":"variable dut_param_mux__DOT__uut_pmux__DOT__out","text":"<pre><code>IData dut_param_mux__DOT__uut_pmux__DOT__out;\n</code></pre>"},{"location":"TitanComms/Vtop______024root_8h/#variable-dut_param_mux__dot__uut_pmux__dot__selector","title":"variable dut_param_mux__DOT__uut_pmux__DOT__selector","text":"<pre><code>CData dut_param_mux__DOT__uut_pmux__DOT__selector;\n</code></pre>"},{"location":"TitanComms/Vtop______024root_8h/#variable-vlsymsp","title":"variable vlSymsp","text":"<pre><code>Vtop__Syms* const vlSymsp;\n</code></pre>"},{"location":"TitanComms/Vtop______024root_8h/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"TitanComms/Vtop______024root_8h/#variable-dut_param_mux__dot__uut_pmux__dot__input_width","title":"variable dut_param_mux__DOT__uut_pmux__DOT__INPUT_WIDTH","text":"<pre><code>constexpr IData dut_param_mux__DOT__uut_pmux__DOT__INPUT_WIDTH;\n</code></pre>"},{"location":"TitanComms/Vtop______024root_8h/#variable-dut_param_mux__dot__uut_pmux__dot__selector_width","title":"variable dut_param_mux__DOT__uut_pmux__DOT__SELECTOR_WIDTH","text":"<pre><code>constexpr IData dut_param_mux__DOT__uut_pmux__DOT__SELECTOR_WIDTH;\n</code></pre>"},{"location":"TitanComms/Vtop______024root_8h/#variable-dut_param_mux__dot__uut_pmux__dot__signal_count","title":"variable dut_param_mux__DOT__uut_pmux__DOT__SIGNAL_COUNT","text":"<pre><code>constexpr IData dut_param_mux__DOT__uut_pmux__DOT__SIGNAL_COUNT;\n</code></pre>"},{"location":"TitanComms/Vtop______024root_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"TitanComms/Vtop______024root_8h/#function-vl_attr_aligned","title":"function VL_ATTR_ALIGNED","text":"<pre><code>Vtop___024root VerilatedModule VL_ATTR_ALIGNED (\n    VL_CACHE_LINE_BYTES\n) \n</code></pre>"},{"location":"TitanComms/Vtop______024root_8h/#function-vl_in","title":"function VL_IN","text":"<pre><code>VL_IN (\n    in1,\n    31,\n    0\n) \n</code></pre>"},{"location":"TitanComms/Vtop______024root_8h/#function-vl_in_1","title":"function VL_IN","text":"<pre><code>VL_IN (\n    in2,\n    31,\n    0\n) \n</code></pre>"},{"location":"TitanComms/Vtop______024root_8h/#function-vl_in_2","title":"function VL_IN","text":"<pre><code>VL_IN (\n    in3,\n    31,\n    0\n) \n</code></pre>"},{"location":"TitanComms/Vtop______024root_8h/#function-vl_in_3","title":"function VL_IN","text":"<pre><code>VL_IN (\n    in4,\n    31,\n    0\n) \n</code></pre>"},{"location":"TitanComms/Vtop______024root_8h/#function-vl_in8","title":"function VL_IN8","text":"<pre><code>VL_IN8 (\n    sel_i,\n    1,\n    0\n) \n</code></pre>"},{"location":"TitanComms/Vtop______024root_8h/#function-vl_out","title":"function VL_OUT","text":"<pre><code>VL_OUT (\n    mux_o,\n    31,\n    0\n) \n</code></pre>"},{"location":"TitanComms/Vtop______024root_8h/#function-vl_uncopyable","title":"function VL_UNCOPYABLE","text":"<pre><code>VL_UNCOPYABLE (\n    Vtop___024root\n) \n</code></pre>"},{"location":"TitanComms/Vtop______024root_8h/#function-vtop___024root","title":"function Vtop___024root","text":"<pre><code>Vtop___024root (\n    Vtop__Syms * symsp,\n    const char * v__name\n) \n</code></pre>"},{"location":"TitanComms/Vtop______024root_8h/#function-__vconfigure","title":"function __Vconfigure","text":"<pre><code>void __Vconfigure (\n    bool first\n) \n</code></pre>"},{"location":"TitanComms/Vtop______024root_8h/#function-vtop___024root_1","title":"function ~Vtop___024root","text":"<pre><code>~Vtop___024root () \n</code></pre>"},{"location":"TitanComms/Vtop______024root_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"TitanComms/Vtop______024root_8h/#define-verilated_vtop___024root_h_","title":"define VERILATED_VTOP___024ROOT_H_","text":"<pre><code>#define VERILATED_VTOP___024ROOT_H_ \n</code></pre> <p>The documentation for this class was generated from the following file <code>titan/comms/verilog/tests/sim_build/Vtop___024root.h</code></p>"},{"location":"TitanComms/Vtop______024root_8h_source/","title":"File Vtop___024root.h","text":"<p>File List &gt; comms &gt; verilog &gt; tests &gt; sim_build &gt; Vtop___024root.h</p> <p>Go to the documentation of this file</p> <pre><code>// Verilated -*- C++ -*-\n// DESCRIPTION: Verilator output: Design internal header\n// See Vtop.h for the primary calling header\n\n#ifndef VERILATED_VTOP___024ROOT_H_\n#define VERILATED_VTOP___024ROOT_H_  // guard\n\n#include \"verilated.h\"\n#include \"verilated_timing.h\"\n\nclass Vtop__Syms;\n\nclass Vtop___024root final : public VerilatedModule {\n  public:\n\n    // DESIGN SPECIFIC STATE\n    VL_IN8(sel_i,1,0);\n    CData/*1:0*/ dut_param_mux__DOT__sel_i;\n    CData/*1:0*/ dut_param_mux__DOT__uut_pmux__DOT__selector;\n    CData/*0:0*/ __VactContinue;\n    VL_IN(in1,31,0);\n    VL_IN(in2,31,0);\n    VL_IN(in3,31,0);\n    VL_IN(in4,31,0);\n    VL_OUT(mux_o,31,0);\n    IData/*31:0*/ dut_param_mux__DOT__in1;\n    IData/*31:0*/ dut_param_mux__DOT__in2;\n    IData/*31:0*/ dut_param_mux__DOT__in3;\n    IData/*31:0*/ dut_param_mux__DOT__in4;\n    IData/*31:0*/ dut_param_mux__DOT__mux_o;\n    IData/*31:0*/ dut_param_mux__DOT__uut_pmux__DOT__out;\n    IData/*31:0*/ __VstlIterCount;\n    IData/*31:0*/ __VicoIterCount;\n    IData/*31:0*/ __VactIterCount;\n    VlUnpacked&lt;IData/*31:0*/, 4&gt; dut_param_mux__DOT____Vcellinp__uut_pmux__inputs;\n    VlUnpacked&lt;IData/*31:0*/, 4&gt; dut_param_mux__DOT__uut_pmux__DOT__inputs;\n    VlDelayScheduler __VdlySched;\n    VlTriggerVec&lt;1&gt; __VstlTriggered;\n    VlTriggerVec&lt;1&gt; __VicoTriggered;\n    VlTriggerVec&lt;1&gt; __VactTriggered;\n    VlTriggerVec&lt;1&gt; __VnbaTriggered;\n\n    // INTERNAL VARIABLES\n    Vtop__Syms* const vlSymsp;\n\n    // PARAMETERS\n    static constexpr IData/*31:0*/ dut_param_mux__DOT__uut_pmux__DOT__INPUT_WIDTH = 0x00000020U;\n    static constexpr IData/*31:0*/ dut_param_mux__DOT__uut_pmux__DOT__SELECTOR_WIDTH = 2U;\n    static constexpr IData/*31:0*/ dut_param_mux__DOT__uut_pmux__DOT__SIGNAL_COUNT = 4U;\n\n    // CONSTRUCTORS\n    Vtop___024root(Vtop__Syms* symsp, const char* v__name);\n    ~Vtop___024root();\n    VL_UNCOPYABLE(Vtop___024root);\n\n    // INTERNAL METHODS\n    void __Vconfigure(bool first);\n} VL_ATTR_ALIGNED(VL_CACHE_LINE_BYTES);\n\n\n#endif  // guard\n</code></pre>"},{"location":"TitanComms/Vtop______024root____DepSet__h84412442____0_8cpp/","title":"File Vtop___024root__DepSet_h84412442__0.cpp","text":"<p>FileList &gt; comms &gt; verilog &gt; tests &gt; sim_build &gt; Vtop___024root__DepSet_h84412442__0.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"verilated.h\"</code></li> <li><code>#include \"verilated_dpi.h\"</code></li> <li><code>#include \"Vtop__Syms.h\"</code></li> <li><code>#include \"Vtop___024root.h\"</code></li> </ul>"},{"location":"TitanComms/Vtop______024root____DepSet__h84412442____0_8cpp/#public-functions","title":"Public Functions","text":"Type Name VL_INLINE_OPT VlCoroutine Vtop___024root___eval_initial__TOP__0 (Vtop___024root * vlSelf)  void Vtop___024root___eval_triggers__act (Vtop___024root * vlSelf)  void Vtop___024root___eval_triggers__ico (Vtop___024root * vlSelf)"},{"location":"TitanComms/Vtop______024root____DepSet__h84412442____0_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"TitanComms/Vtop______024root____DepSet__h84412442____0_8cpp/#function-vtop___024root___eval_initial__top__0","title":"function Vtop___024root___eval_initial__TOP__0","text":"<pre><code>VL_INLINE_OPT VlCoroutine Vtop___024root___eval_initial__TOP__0 (\n    Vtop___024root * vlSelf\n) \n</code></pre>"},{"location":"TitanComms/Vtop______024root____DepSet__h84412442____0_8cpp/#function-vtop___024root___eval_triggers__act","title":"function Vtop___024root___eval_triggers__act","text":"<pre><code>void Vtop___024root___eval_triggers__act (\n    Vtop___024root * vlSelf\n) \n</code></pre>"},{"location":"TitanComms/Vtop______024root____DepSet__h84412442____0_8cpp/#function-vtop___024root___eval_triggers__ico","title":"function Vtop___024root___eval_triggers__ico","text":"<pre><code>void Vtop___024root___eval_triggers__ico (\n    Vtop___024root * vlSelf\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>titan/comms/verilog/tests/sim_build/Vtop___024root__DepSet_h84412442__0.cpp</code></p>"},{"location":"TitanComms/Vtop______024root____DepSet__h84412442____0_8cpp_source/","title":"File Vtop___024root__DepSet_h84412442__0.cpp","text":"<p>File List &gt; comms &gt; verilog &gt; tests &gt; sim_build &gt; Vtop___024root__DepSet_h84412442__0.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// Verilated -*- C++ -*-\n// DESCRIPTION: Verilator output: Design implementation internals\n// See Vtop.h for the primary calling header\n\n#include \"verilated.h\"\n#include \"verilated_dpi.h\"\n\n#include \"Vtop__Syms.h\"\n#include \"Vtop___024root.h\"\n\nVL_INLINE_OPT VlCoroutine Vtop___024root___eval_initial__TOP__0(Vtop___024root* vlSelf) {\n    if (false &amp;&amp; vlSelf) {}  // Prevent unused\n    Vtop__Syms* const __restrict vlSymsp VL_ATTR_UNUSED = vlSelf-&gt;vlSymsp;\n    VL_DEBUG_IF(VL_DBG_MSGF(\"+    Vtop___024root___eval_initial__TOP__0\\n\"); );\n    // Init\n    VlWide&lt;6&gt;/*191:0*/ __Vtemp_h513746c2__0;\n    // Body\n    __Vtemp_h513746c2__0[0U] = 0x2e766364U;\n    __Vtemp_h513746c2__0[1U] = 0x5f6d7578U;\n    __Vtemp_h513746c2__0[2U] = 0x6172616dU;\n    __Vtemp_h513746c2__0[3U] = 0x75745f70U;\n    __Vtemp_h513746c2__0[4U] = 0x65735f64U;\n    __Vtemp_h513746c2__0[5U] = 0x776176U;\n    vlSymsp-&gt;_vm_contextp__-&gt;dumpfile(VL_CVT_PACK_STR_NW(6, __Vtemp_h513746c2__0));\n    vlSymsp-&gt;_traceDumpOpen();\n    co_await vlSelf-&gt;__VdlySched.delay(0x3e8U, \"/home/kris/repos/titan/titan/comms/verilog/tests/dut_param_mux.sv\", \n                                       12);\n}\n\n#ifdef VL_DEBUG\nVL_ATTR_COLD void Vtop___024root___dump_triggers__ico(Vtop___024root* vlSelf);\n#endif  // VL_DEBUG\n\nvoid Vtop___024root___eval_triggers__ico(Vtop___024root* vlSelf) {\n    if (false &amp;&amp; vlSelf) {}  // Prevent unused\n    Vtop__Syms* const __restrict vlSymsp VL_ATTR_UNUSED = vlSelf-&gt;vlSymsp;\n    VL_DEBUG_IF(VL_DBG_MSGF(\"+    Vtop___024root___eval_triggers__ico\\n\"); );\n    // Body\n    vlSelf-&gt;__VicoTriggered.at(0U) = (0U == vlSelf-&gt;__VicoIterCount);\n#ifdef VL_DEBUG\n    if (VL_UNLIKELY(vlSymsp-&gt;_vm_contextp__-&gt;debug())) {\n        Vtop___024root___dump_triggers__ico(vlSelf);\n    }\n#endif\n}\n\n#ifdef VL_DEBUG\nVL_ATTR_COLD void Vtop___024root___dump_triggers__act(Vtop___024root* vlSelf);\n#endif  // VL_DEBUG\n\nvoid Vtop___024root___eval_triggers__act(Vtop___024root* vlSelf) {\n    if (false &amp;&amp; vlSelf) {}  // Prevent unused\n    Vtop__Syms* const __restrict vlSymsp VL_ATTR_UNUSED = vlSelf-&gt;vlSymsp;\n    VL_DEBUG_IF(VL_DBG_MSGF(\"+    Vtop___024root___eval_triggers__act\\n\"); );\n    // Body\n    vlSelf-&gt;__VactTriggered.at(0U) = vlSelf-&gt;__VdlySched.awaitingCurrentTime();\n#ifdef VL_DEBUG\n    if (VL_UNLIKELY(vlSymsp-&gt;_vm_contextp__-&gt;debug())) {\n        Vtop___024root___dump_triggers__act(vlSelf);\n    }\n#endif\n}\n</code></pre>"},{"location":"TitanComms/Vtop______024root____DepSet__h84412442____0____Slow_8cpp/","title":"File Vtop___024root__DepSet_h84412442__0__Slow.cpp","text":"<p>FileList &gt; comms &gt; verilog &gt; tests &gt; sim_build &gt; Vtop___024root__DepSet_h84412442__0__Slow.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"verilated.h\"</code></li> <li><code>#include \"verilated_dpi.h\"</code></li> <li><code>#include \"Vtop__Syms.h\"</code></li> <li><code>#include \"Vtop___024root.h\"</code></li> </ul>"},{"location":"TitanComms/Vtop______024root____DepSet__h84412442____0____Slow_8cpp/#public-functions","title":"Public Functions","text":"Type Name VL_ATTR_COLD void Vtop___024root___eval_triggers__stl (Vtop___024root * vlSelf)"},{"location":"TitanComms/Vtop______024root____DepSet__h84412442____0____Slow_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"TitanComms/Vtop______024root____DepSet__h84412442____0____Slow_8cpp/#function-vtop___024root___eval_triggers__stl","title":"function Vtop___024root___eval_triggers__stl","text":"<pre><code>VL_ATTR_COLD void Vtop___024root___eval_triggers__stl (\n    Vtop___024root * vlSelf\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>titan/comms/verilog/tests/sim_build/Vtop___024root__DepSet_h84412442__0__Slow.cpp</code></p>"},{"location":"TitanComms/Vtop______024root____DepSet__h84412442____0____Slow_8cpp_source/","title":"File Vtop___024root__DepSet_h84412442__0__Slow.cpp","text":"<p>File List &gt; comms &gt; verilog &gt; tests &gt; sim_build &gt; Vtop___024root__DepSet_h84412442__0__Slow.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// Verilated -*- C++ -*-\n// DESCRIPTION: Verilator output: Design implementation internals\n// See Vtop.h for the primary calling header\n\n#include \"verilated.h\"\n#include \"verilated_dpi.h\"\n\n#include \"Vtop__Syms.h\"\n#include \"Vtop___024root.h\"\n\n#ifdef VL_DEBUG\nVL_ATTR_COLD void Vtop___024root___dump_triggers__stl(Vtop___024root* vlSelf);\n#endif  // VL_DEBUG\n\nVL_ATTR_COLD void Vtop___024root___eval_triggers__stl(Vtop___024root* vlSelf) {\n    if (false &amp;&amp; vlSelf) {}  // Prevent unused\n    Vtop__Syms* const __restrict vlSymsp VL_ATTR_UNUSED = vlSelf-&gt;vlSymsp;\n    VL_DEBUG_IF(VL_DBG_MSGF(\"+    Vtop___024root___eval_triggers__stl\\n\"); );\n    // Body\n    vlSelf-&gt;__VstlTriggered.at(0U) = (0U == vlSelf-&gt;__VstlIterCount);\n#ifdef VL_DEBUG\n    if (VL_UNLIKELY(vlSymsp-&gt;_vm_contextp__-&gt;debug())) {\n        Vtop___024root___dump_triggers__stl(vlSelf);\n    }\n#endif\n}\n</code></pre>"},{"location":"TitanComms/Vtop______024root____DepSet__heccd7ead____0_8cpp/","title":"File Vtop___024root__DepSet_heccd7ead__0.cpp","text":"<p>FileList &gt; comms &gt; verilog &gt; tests &gt; sim_build &gt; Vtop___024root__DepSet_heccd7ead__0.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"verilated.h\"</code></li> <li><code>#include \"verilated_dpi.h\"</code></li> <li><code>#include \"Vtop___024root.h\"</code></li> </ul>"},{"location":"TitanComms/Vtop______024root____DepSet__heccd7ead____0_8cpp/#public-functions","title":"Public Functions","text":"Type Name void Vtop___024root___eval (Vtop___024root * vlSelf)  void Vtop___024root___eval_act (Vtop___024root * vlSelf)  void Vtop___024root___eval_ico (Vtop___024root * vlSelf)  void Vtop___024root___eval_initial (Vtop___024root * vlSelf)  VlCoroutine Vtop___024root___eval_initial__TOP__0 (Vtop___024root * vlSelf)  void Vtop___024root___eval_nba (Vtop___024root * vlSelf)  void Vtop___024root___eval_triggers__act (Vtop___024root * vlSelf)  void Vtop___024root___eval_triggers__ico (Vtop___024root * vlSelf)  VL_INLINE_OPT void Vtop___024root___ico_sequent__TOP__0 (Vtop___024root * vlSelf)  void Vtop___024root___timing_resume (Vtop___024root * vlSelf)"},{"location":"TitanComms/Vtop______024root____DepSet__heccd7ead____0_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"TitanComms/Vtop______024root____DepSet__heccd7ead____0_8cpp/#function-vtop___024root___eval","title":"function Vtop___024root___eval","text":"<pre><code>void Vtop___024root___eval (\n    Vtop___024root * vlSelf\n) \n</code></pre>"},{"location":"TitanComms/Vtop______024root____DepSet__heccd7ead____0_8cpp/#function-vtop___024root___eval_act","title":"function Vtop___024root___eval_act","text":"<pre><code>void Vtop___024root___eval_act (\n    Vtop___024root * vlSelf\n) \n</code></pre>"},{"location":"TitanComms/Vtop______024root____DepSet__heccd7ead____0_8cpp/#function-vtop___024root___eval_ico","title":"function Vtop___024root___eval_ico","text":"<pre><code>void Vtop___024root___eval_ico (\n    Vtop___024root * vlSelf\n) \n</code></pre>"},{"location":"TitanComms/Vtop______024root____DepSet__heccd7ead____0_8cpp/#function-vtop___024root___eval_initial","title":"function Vtop___024root___eval_initial","text":"<pre><code>void Vtop___024root___eval_initial (\n    Vtop___024root * vlSelf\n) \n</code></pre>"},{"location":"TitanComms/Vtop______024root____DepSet__heccd7ead____0_8cpp/#function-vtop___024root___eval_initial__top__0","title":"function Vtop___024root___eval_initial__TOP__0","text":"<pre><code>VlCoroutine Vtop___024root___eval_initial__TOP__0 (\n    Vtop___024root * vlSelf\n) \n</code></pre>"},{"location":"TitanComms/Vtop______024root____DepSet__heccd7ead____0_8cpp/#function-vtop___024root___eval_nba","title":"function Vtop___024root___eval_nba","text":"<pre><code>void Vtop___024root___eval_nba (\n    Vtop___024root * vlSelf\n) \n</code></pre>"},{"location":"TitanComms/Vtop______024root____DepSet__heccd7ead____0_8cpp/#function-vtop___024root___eval_triggers__act","title":"function Vtop___024root___eval_triggers__act","text":"<pre><code>void Vtop___024root___eval_triggers__act (\n    Vtop___024root * vlSelf\n) \n</code></pre>"},{"location":"TitanComms/Vtop______024root____DepSet__heccd7ead____0_8cpp/#function-vtop___024root___eval_triggers__ico","title":"function Vtop___024root___eval_triggers__ico","text":"<pre><code>void Vtop___024root___eval_triggers__ico (\n    Vtop___024root * vlSelf\n) \n</code></pre>"},{"location":"TitanComms/Vtop______024root____DepSet__heccd7ead____0_8cpp/#function-vtop___024root___ico_sequent__top__0","title":"function Vtop___024root___ico_sequent__TOP__0","text":"<pre><code>VL_INLINE_OPT void Vtop___024root___ico_sequent__TOP__0 (\n    Vtop___024root * vlSelf\n) \n</code></pre>"},{"location":"TitanComms/Vtop______024root____DepSet__heccd7ead____0_8cpp/#function-vtop___024root___timing_resume","title":"function Vtop___024root___timing_resume","text":"<pre><code>void Vtop___024root___timing_resume (\n    Vtop___024root * vlSelf\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>titan/comms/verilog/tests/sim_build/Vtop___024root__DepSet_heccd7ead__0.cpp</code></p>"},{"location":"TitanComms/Vtop______024root____DepSet__heccd7ead____0_8cpp_source/","title":"File Vtop___024root__DepSet_heccd7ead__0.cpp","text":"<p>File List &gt; comms &gt; verilog &gt; tests &gt; sim_build &gt; Vtop___024root__DepSet_heccd7ead__0.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// Verilated -*- C++ -*-\n// DESCRIPTION: Verilator output: Design implementation internals\n// See Vtop.h for the primary calling header\n\n#include \"verilated.h\"\n#include \"verilated_dpi.h\"\n\n#include \"Vtop___024root.h\"\n\nVlCoroutine Vtop___024root___eval_initial__TOP__0(Vtop___024root* vlSelf);\n\nvoid Vtop___024root___eval_initial(Vtop___024root* vlSelf) {\n    if (false &amp;&amp; vlSelf) {}  // Prevent unused\n    Vtop__Syms* const __restrict vlSymsp VL_ATTR_UNUSED = vlSelf-&gt;vlSymsp;\n    VL_DEBUG_IF(VL_DBG_MSGF(\"+    Vtop___024root___eval_initial\\n\"); );\n    // Body\n    Vtop___024root___eval_initial__TOP__0(vlSelf);\n}\n\nVL_INLINE_OPT void Vtop___024root___ico_sequent__TOP__0(Vtop___024root* vlSelf) {\n    if (false &amp;&amp; vlSelf) {}  // Prevent unused\n    Vtop__Syms* const __restrict vlSymsp VL_ATTR_UNUSED = vlSelf-&gt;vlSymsp;\n    VL_DEBUG_IF(VL_DBG_MSGF(\"+    Vtop___024root___ico_sequent__TOP__0\\n\"); );\n    // Body\n    vlSelf-&gt;dut_param_mux__DOT__in1 = vlSelf-&gt;in1;\n    vlSelf-&gt;dut_param_mux__DOT__in2 = vlSelf-&gt;in2;\n    vlSelf-&gt;dut_param_mux__DOT__in3 = vlSelf-&gt;in3;\n    vlSelf-&gt;dut_param_mux__DOT__in4 = vlSelf-&gt;in4;\n    vlSelf-&gt;dut_param_mux__DOT__sel_i = vlSelf-&gt;sel_i;\n    vlSelf-&gt;dut_param_mux__DOT____Vcellinp__uut_pmux__inputs[0U] \n        = vlSelf-&gt;in1;\n    vlSelf-&gt;dut_param_mux__DOT____Vcellinp__uut_pmux__inputs[1U] \n        = vlSelf-&gt;in2;\n    vlSelf-&gt;dut_param_mux__DOT____Vcellinp__uut_pmux__inputs[2U] \n        = vlSelf-&gt;in3;\n    vlSelf-&gt;dut_param_mux__DOT____Vcellinp__uut_pmux__inputs[3U] \n        = vlSelf-&gt;in4;\n    vlSelf-&gt;dut_param_mux__DOT__uut_pmux__DOT__selector \n        = vlSelf-&gt;dut_param_mux__DOT__sel_i;\n    vlSelf-&gt;dut_param_mux__DOT__uut_pmux__DOT__inputs[0U] \n        = vlSelf-&gt;dut_param_mux__DOT____Vcellinp__uut_pmux__inputs\n        [0U];\n    vlSelf-&gt;dut_param_mux__DOT__uut_pmux__DOT__inputs[1U] \n        = vlSelf-&gt;dut_param_mux__DOT____Vcellinp__uut_pmux__inputs\n        [1U];\n    vlSelf-&gt;dut_param_mux__DOT__uut_pmux__DOT__inputs[2U] \n        = vlSelf-&gt;dut_param_mux__DOT____Vcellinp__uut_pmux__inputs\n        [2U];\n    vlSelf-&gt;dut_param_mux__DOT__uut_pmux__DOT__inputs[3U] \n        = vlSelf-&gt;dut_param_mux__DOT____Vcellinp__uut_pmux__inputs\n        [3U];\n    vlSelf-&gt;mux_o = vlSelf-&gt;dut_param_mux__DOT____Vcellinp__uut_pmux__inputs\n        [vlSelf-&gt;sel_i];\n    vlSelf-&gt;dut_param_mux__DOT__mux_o = vlSelf-&gt;mux_o;\n    vlSelf-&gt;dut_param_mux__DOT__uut_pmux__DOT__out \n        = vlSelf-&gt;mux_o;\n}\n\nvoid Vtop___024root___eval_ico(Vtop___024root* vlSelf) {\n    if (false &amp;&amp; vlSelf) {}  // Prevent unused\n    Vtop__Syms* const __restrict vlSymsp VL_ATTR_UNUSED = vlSelf-&gt;vlSymsp;\n    VL_DEBUG_IF(VL_DBG_MSGF(\"+    Vtop___024root___eval_ico\\n\"); );\n    // Body\n    if (vlSelf-&gt;__VicoTriggered.at(0U)) {\n        Vtop___024root___ico_sequent__TOP__0(vlSelf);\n    }\n}\n\nvoid Vtop___024root___eval_act(Vtop___024root* vlSelf) {\n    if (false &amp;&amp; vlSelf) {}  // Prevent unused\n    Vtop__Syms* const __restrict vlSymsp VL_ATTR_UNUSED = vlSelf-&gt;vlSymsp;\n    VL_DEBUG_IF(VL_DBG_MSGF(\"+    Vtop___024root___eval_act\\n\"); );\n}\n\nvoid Vtop___024root___eval_nba(Vtop___024root* vlSelf) {\n    if (false &amp;&amp; vlSelf) {}  // Prevent unused\n    Vtop__Syms* const __restrict vlSymsp VL_ATTR_UNUSED = vlSelf-&gt;vlSymsp;\n    VL_DEBUG_IF(VL_DBG_MSGF(\"+    Vtop___024root___eval_nba\\n\"); );\n}\n\nvoid Vtop___024root___eval_triggers__ico(Vtop___024root* vlSelf);\n#ifdef VL_DEBUG\nVL_ATTR_COLD void Vtop___024root___dump_triggers__ico(Vtop___024root* vlSelf);\n#endif  // VL_DEBUG\nvoid Vtop___024root___eval_triggers__act(Vtop___024root* vlSelf);\n#ifdef VL_DEBUG\nVL_ATTR_COLD void Vtop___024root___dump_triggers__act(Vtop___024root* vlSelf);\n#endif  // VL_DEBUG\nvoid Vtop___024root___timing_resume(Vtop___024root* vlSelf);\n#ifdef VL_DEBUG\nVL_ATTR_COLD void Vtop___024root___dump_triggers__nba(Vtop___024root* vlSelf);\n#endif  // VL_DEBUG\n\nvoid Vtop___024root___eval(Vtop___024root* vlSelf) {\n    if (false &amp;&amp; vlSelf) {}  // Prevent unused\n    Vtop__Syms* const __restrict vlSymsp VL_ATTR_UNUSED = vlSelf-&gt;vlSymsp;\n    VL_DEBUG_IF(VL_DBG_MSGF(\"+    Vtop___024root___eval\\n\"); );\n    // Init\n    CData/*0:0*/ __VicoContinue;\n    VlTriggerVec&lt;1&gt; __VpreTriggered;\n    IData/*31:0*/ __VnbaIterCount;\n    CData/*0:0*/ __VnbaContinue;\n    // Body\n    vlSelf-&gt;__VicoIterCount = 0U;\n    __VicoContinue = 1U;\n    while (__VicoContinue) {\n        __VicoContinue = 0U;\n        Vtop___024root___eval_triggers__ico(vlSelf);\n        if (vlSelf-&gt;__VicoTriggered.any()) {\n            __VicoContinue = 1U;\n            if (VL_UNLIKELY((0x64U &lt; vlSelf-&gt;__VicoIterCount))) {\n#ifdef VL_DEBUG\n                Vtop___024root___dump_triggers__ico(vlSelf);\n#endif\n                VL_FATAL_MT(\"/home/kris/repos/titan/titan/comms/verilog/tests/dut_param_mux.sv\", 1, \"\", \"Input combinational region did not converge.\");\n            }\n            vlSelf-&gt;__VicoIterCount = ((IData)(1U) \n                                       + vlSelf-&gt;__VicoIterCount);\n            Vtop___024root___eval_ico(vlSelf);\n        }\n    }\n    __VnbaIterCount = 0U;\n    __VnbaContinue = 1U;\n    while (__VnbaContinue) {\n        __VnbaContinue = 0U;\n        vlSelf-&gt;__VnbaTriggered.clear();\n        vlSelf-&gt;__VactIterCount = 0U;\n        vlSelf-&gt;__VactContinue = 1U;\n        while (vlSelf-&gt;__VactContinue) {\n            vlSelf-&gt;__VactContinue = 0U;\n            Vtop___024root___eval_triggers__act(vlSelf);\n            if (vlSelf-&gt;__VactTriggered.any()) {\n                vlSelf-&gt;__VactContinue = 1U;\n                if (VL_UNLIKELY((0x64U &lt; vlSelf-&gt;__VactIterCount))) {\n#ifdef VL_DEBUG\n                    Vtop___024root___dump_triggers__act(vlSelf);\n#endif\n                    VL_FATAL_MT(\"/home/kris/repos/titan/titan/comms/verilog/tests/dut_param_mux.sv\", 1, \"\", \"Active region did not converge.\");\n                }\n                vlSelf-&gt;__VactIterCount = ((IData)(1U) \n                                           + vlSelf-&gt;__VactIterCount);\n                __VpreTriggered.andNot(vlSelf-&gt;__VactTriggered, vlSelf-&gt;__VnbaTriggered);\n                vlSelf-&gt;__VnbaTriggered.set(vlSelf-&gt;__VactTriggered);\n                Vtop___024root___timing_resume(vlSelf);\n                Vtop___024root___eval_act(vlSelf);\n            }\n        }\n        if (vlSelf-&gt;__VnbaTriggered.any()) {\n            __VnbaContinue = 1U;\n            if (VL_UNLIKELY((0x64U &lt; __VnbaIterCount))) {\n#ifdef VL_DEBUG\n                Vtop___024root___dump_triggers__nba(vlSelf);\n#endif\n                VL_FATAL_MT(\"/home/kris/repos/titan/titan/comms/verilog/tests/dut_param_mux.sv\", 1, \"\", \"NBA region did not converge.\");\n            }\n            __VnbaIterCount = ((IData)(1U) + __VnbaIterCount);\n            Vtop___024root___eval_nba(vlSelf);\n        }\n    }\n}\n\nvoid Vtop___024root___timing_resume(Vtop___024root* vlSelf) {\n    if (false &amp;&amp; vlSelf) {}  // Prevent unused\n    Vtop__Syms* const __restrict vlSymsp VL_ATTR_UNUSED = vlSelf-&gt;vlSymsp;\n    VL_DEBUG_IF(VL_DBG_MSGF(\"+    Vtop___024root___timing_resume\\n\"); );\n    // Body\n    if (vlSelf-&gt;__VactTriggered.at(0U)) {\n        vlSelf-&gt;__VdlySched.resume();\n    }\n}\n\n#ifdef VL_DEBUG\nvoid Vtop___024root___eval_debug_assertions(Vtop___024root* vlSelf) {\n    if (false &amp;&amp; vlSelf) {}  // Prevent unused\n    Vtop__Syms* const __restrict vlSymsp VL_ATTR_UNUSED = vlSelf-&gt;vlSymsp;\n    VL_DEBUG_IF(VL_DBG_MSGF(\"+    Vtop___024root___eval_debug_assertions\\n\"); );\n    // Body\n    if (VL_UNLIKELY((vlSelf-&gt;sel_i &amp; 0xfcU))) {\n        Verilated::overWidthError(\"sel_i\");}\n}\n#endif  // VL_DEBUG\n</code></pre>"},{"location":"TitanComms/Vtop______024root____DepSet__heccd7ead____0____Slow_8cpp/","title":"File Vtop___024root__DepSet_heccd7ead__0__Slow.cpp","text":"<p>FileList &gt; comms &gt; verilog &gt; tests &gt; sim_build &gt; Vtop___024root__DepSet_heccd7ead__0__Slow.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"verilated.h\"</code></li> <li><code>#include \"verilated_dpi.h\"</code></li> <li><code>#include \"Vtop___024root.h\"</code></li> </ul>"},{"location":"TitanComms/Vtop______024root____DepSet__heccd7ead____0____Slow_8cpp/#public-functions","title":"Public Functions","text":"Type Name VL_ATTR_COLD void Vtop___024root___ctor_var_reset (Vtop___024root * vlSelf)  VL_ATTR_COLD void Vtop___024root___eval_final (Vtop___024root * vlSelf)  VL_ATTR_COLD void Vtop___024root___eval_settle (Vtop___024root * vlSelf)  VL_ATTR_COLD void Vtop___024root___eval_static (Vtop___024root * vlSelf)  VL_ATTR_COLD void Vtop___024root___eval_stl (Vtop___024root * vlSelf)  VL_ATTR_COLD void Vtop___024root___eval_triggers__stl (Vtop___024root * vlSelf)  void Vtop___024root___ico_sequent__TOP__0 (Vtop___024root * vlSelf)"},{"location":"TitanComms/Vtop______024root____DepSet__heccd7ead____0____Slow_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"TitanComms/Vtop______024root____DepSet__heccd7ead____0____Slow_8cpp/#function-vtop___024root___ctor_var_reset","title":"function Vtop___024root___ctor_var_reset","text":"<pre><code>VL_ATTR_COLD void Vtop___024root___ctor_var_reset (\n    Vtop___024root * vlSelf\n) \n</code></pre>"},{"location":"TitanComms/Vtop______024root____DepSet__heccd7ead____0____Slow_8cpp/#function-vtop___024root___eval_final","title":"function Vtop___024root___eval_final","text":"<pre><code>VL_ATTR_COLD void Vtop___024root___eval_final (\n    Vtop___024root * vlSelf\n) \n</code></pre>"},{"location":"TitanComms/Vtop______024root____DepSet__heccd7ead____0____Slow_8cpp/#function-vtop___024root___eval_settle","title":"function Vtop___024root___eval_settle","text":"<pre><code>VL_ATTR_COLD void Vtop___024root___eval_settle (\n    Vtop___024root * vlSelf\n) \n</code></pre>"},{"location":"TitanComms/Vtop______024root____DepSet__heccd7ead____0____Slow_8cpp/#function-vtop___024root___eval_static","title":"function Vtop___024root___eval_static","text":"<pre><code>VL_ATTR_COLD void Vtop___024root___eval_static (\n    Vtop___024root * vlSelf\n) \n</code></pre>"},{"location":"TitanComms/Vtop______024root____DepSet__heccd7ead____0____Slow_8cpp/#function-vtop___024root___eval_stl","title":"function Vtop___024root___eval_stl","text":"<pre><code>VL_ATTR_COLD void Vtop___024root___eval_stl (\n    Vtop___024root * vlSelf\n) \n</code></pre>"},{"location":"TitanComms/Vtop______024root____DepSet__heccd7ead____0____Slow_8cpp/#function-vtop___024root___eval_triggers__stl","title":"function Vtop___024root___eval_triggers__stl","text":"<pre><code>VL_ATTR_COLD void Vtop___024root___eval_triggers__stl (\n    Vtop___024root * vlSelf\n) \n</code></pre>"},{"location":"TitanComms/Vtop______024root____DepSet__heccd7ead____0____Slow_8cpp/#function-vtop___024root___ico_sequent__top__0","title":"function Vtop___024root___ico_sequent__TOP__0","text":"<pre><code>void Vtop___024root___ico_sequent__TOP__0 (\n    Vtop___024root * vlSelf\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>titan/comms/verilog/tests/sim_build/Vtop___024root__DepSet_heccd7ead__0__Slow.cpp</code></p>"},{"location":"TitanComms/Vtop______024root____DepSet__heccd7ead____0____Slow_8cpp_source/","title":"File Vtop___024root__DepSet_heccd7ead__0__Slow.cpp","text":"<p>File List &gt; comms &gt; verilog &gt; tests &gt; sim_build &gt; Vtop___024root__DepSet_heccd7ead__0__Slow.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// Verilated -*- C++ -*-\n// DESCRIPTION: Verilator output: Design implementation internals\n// See Vtop.h for the primary calling header\n\n#include \"verilated.h\"\n#include \"verilated_dpi.h\"\n\n#include \"Vtop___024root.h\"\n\nVL_ATTR_COLD void Vtop___024root___eval_static(Vtop___024root* vlSelf) {\n    if (false &amp;&amp; vlSelf) {}  // Prevent unused\n    Vtop__Syms* const __restrict vlSymsp VL_ATTR_UNUSED = vlSelf-&gt;vlSymsp;\n    VL_DEBUG_IF(VL_DBG_MSGF(\"+    Vtop___024root___eval_static\\n\"); );\n}\n\nVL_ATTR_COLD void Vtop___024root___eval_final(Vtop___024root* vlSelf) {\n    if (false &amp;&amp; vlSelf) {}  // Prevent unused\n    Vtop__Syms* const __restrict vlSymsp VL_ATTR_UNUSED = vlSelf-&gt;vlSymsp;\n    VL_DEBUG_IF(VL_DBG_MSGF(\"+    Vtop___024root___eval_final\\n\"); );\n}\n\nVL_ATTR_COLD void Vtop___024root___eval_triggers__stl(Vtop___024root* vlSelf);\n#ifdef VL_DEBUG\nVL_ATTR_COLD void Vtop___024root___dump_triggers__stl(Vtop___024root* vlSelf);\n#endif  // VL_DEBUG\nVL_ATTR_COLD void Vtop___024root___eval_stl(Vtop___024root* vlSelf);\n\nVL_ATTR_COLD void Vtop___024root___eval_settle(Vtop___024root* vlSelf) {\n    if (false &amp;&amp; vlSelf) {}  // Prevent unused\n    Vtop__Syms* const __restrict vlSymsp VL_ATTR_UNUSED = vlSelf-&gt;vlSymsp;\n    VL_DEBUG_IF(VL_DBG_MSGF(\"+    Vtop___024root___eval_settle\\n\"); );\n    // Init\n    CData/*0:0*/ __VstlContinue;\n    // Body\n    vlSelf-&gt;__VstlIterCount = 0U;\n    __VstlContinue = 1U;\n    while (__VstlContinue) {\n        __VstlContinue = 0U;\n        Vtop___024root___eval_triggers__stl(vlSelf);\n        if (vlSelf-&gt;__VstlTriggered.any()) {\n            __VstlContinue = 1U;\n            if (VL_UNLIKELY((0x64U &lt; vlSelf-&gt;__VstlIterCount))) {\n#ifdef VL_DEBUG\n                Vtop___024root___dump_triggers__stl(vlSelf);\n#endif\n                VL_FATAL_MT(\"/home/kris/repos/titan/titan/comms/verilog/tests/dut_param_mux.sv\", 1, \"\", \"Settle region did not converge.\");\n            }\n            vlSelf-&gt;__VstlIterCount = ((IData)(1U) \n                                       + vlSelf-&gt;__VstlIterCount);\n            Vtop___024root___eval_stl(vlSelf);\n        }\n    }\n}\n\n#ifdef VL_DEBUG\nVL_ATTR_COLD void Vtop___024root___dump_triggers__stl(Vtop___024root* vlSelf) {\n    if (false &amp;&amp; vlSelf) {}  // Prevent unused\n    Vtop__Syms* const __restrict vlSymsp VL_ATTR_UNUSED = vlSelf-&gt;vlSymsp;\n    VL_DEBUG_IF(VL_DBG_MSGF(\"+    Vtop___024root___dump_triggers__stl\\n\"); );\n    // Body\n    if ((1U &amp; (~ (IData)(vlSelf-&gt;__VstlTriggered.any())))) {\n        VL_DBG_MSGF(\"         No triggers active\\n\");\n    }\n    if (vlSelf-&gt;__VstlTriggered.at(0U)) {\n        VL_DBG_MSGF(\"         'stl' region trigger index 0 is active: Internal 'stl' trigger - first iteration\\n\");\n    }\n}\n#endif  // VL_DEBUG\n\nvoid Vtop___024root___ico_sequent__TOP__0(Vtop___024root* vlSelf);\n\nVL_ATTR_COLD void Vtop___024root___eval_stl(Vtop___024root* vlSelf) {\n    if (false &amp;&amp; vlSelf) {}  // Prevent unused\n    Vtop__Syms* const __restrict vlSymsp VL_ATTR_UNUSED = vlSelf-&gt;vlSymsp;\n    VL_DEBUG_IF(VL_DBG_MSGF(\"+    Vtop___024root___eval_stl\\n\"); );\n    // Body\n    if (vlSelf-&gt;__VstlTriggered.at(0U)) {\n        Vtop___024root___ico_sequent__TOP__0(vlSelf);\n    }\n}\n\n#ifdef VL_DEBUG\nVL_ATTR_COLD void Vtop___024root___dump_triggers__ico(Vtop___024root* vlSelf) {\n    if (false &amp;&amp; vlSelf) {}  // Prevent unused\n    Vtop__Syms* const __restrict vlSymsp VL_ATTR_UNUSED = vlSelf-&gt;vlSymsp;\n    VL_DEBUG_IF(VL_DBG_MSGF(\"+    Vtop___024root___dump_triggers__ico\\n\"); );\n    // Body\n    if ((1U &amp; (~ (IData)(vlSelf-&gt;__VicoTriggered.any())))) {\n        VL_DBG_MSGF(\"         No triggers active\\n\");\n    }\n    if (vlSelf-&gt;__VicoTriggered.at(0U)) {\n        VL_DBG_MSGF(\"         'ico' region trigger index 0 is active: Internal 'ico' trigger - first iteration\\n\");\n    }\n}\n#endif  // VL_DEBUG\n\n#ifdef VL_DEBUG\nVL_ATTR_COLD void Vtop___024root___dump_triggers__act(Vtop___024root* vlSelf) {\n    if (false &amp;&amp; vlSelf) {}  // Prevent unused\n    Vtop__Syms* const __restrict vlSymsp VL_ATTR_UNUSED = vlSelf-&gt;vlSymsp;\n    VL_DEBUG_IF(VL_DBG_MSGF(\"+    Vtop___024root___dump_triggers__act\\n\"); );\n    // Body\n    if ((1U &amp; (~ (IData)(vlSelf-&gt;__VactTriggered.any())))) {\n        VL_DBG_MSGF(\"         No triggers active\\n\");\n    }\n    if (vlSelf-&gt;__VactTriggered.at(0U)) {\n        VL_DBG_MSGF(\"         'act' region trigger index 0 is active: @([true] __VdlySched.awaitingCurrentTime())\\n\");\n    }\n}\n#endif  // VL_DEBUG\n\n#ifdef VL_DEBUG\nVL_ATTR_COLD void Vtop___024root___dump_triggers__nba(Vtop___024root* vlSelf) {\n    if (false &amp;&amp; vlSelf) {}  // Prevent unused\n    Vtop__Syms* const __restrict vlSymsp VL_ATTR_UNUSED = vlSelf-&gt;vlSymsp;\n    VL_DEBUG_IF(VL_DBG_MSGF(\"+    Vtop___024root___dump_triggers__nba\\n\"); );\n    // Body\n    if ((1U &amp; (~ (IData)(vlSelf-&gt;__VnbaTriggered.any())))) {\n        VL_DBG_MSGF(\"         No triggers active\\n\");\n    }\n    if (vlSelf-&gt;__VnbaTriggered.at(0U)) {\n        VL_DBG_MSGF(\"         'nba' region trigger index 0 is active: @([true] __VdlySched.awaitingCurrentTime())\\n\");\n    }\n}\n#endif  // VL_DEBUG\n\nVL_ATTR_COLD void Vtop___024root___ctor_var_reset(Vtop___024root* vlSelf) {\n    if (false &amp;&amp; vlSelf) {}  // Prevent unused\n    Vtop__Syms* const __restrict vlSymsp VL_ATTR_UNUSED = vlSelf-&gt;vlSymsp;\n    VL_DEBUG_IF(VL_DBG_MSGF(\"+    Vtop___024root___ctor_var_reset\\n\"); );\n    // Body\n    vlSelf-&gt;in1 = VL_RAND_RESET_I(32);\n    vlSelf-&gt;in2 = VL_RAND_RESET_I(32);\n    vlSelf-&gt;in3 = VL_RAND_RESET_I(32);\n    vlSelf-&gt;in4 = VL_RAND_RESET_I(32);\n    vlSelf-&gt;sel_i = VL_RAND_RESET_I(2);\n    vlSelf-&gt;mux_o = VL_RAND_RESET_I(32);\n    vlSelf-&gt;dut_param_mux__DOT__in1 = VL_RAND_RESET_I(32);\n    vlSelf-&gt;dut_param_mux__DOT__in2 = VL_RAND_RESET_I(32);\n    vlSelf-&gt;dut_param_mux__DOT__in3 = VL_RAND_RESET_I(32);\n    vlSelf-&gt;dut_param_mux__DOT__in4 = VL_RAND_RESET_I(32);\n    vlSelf-&gt;dut_param_mux__DOT__sel_i = VL_RAND_RESET_I(2);\n    vlSelf-&gt;dut_param_mux__DOT__mux_o = VL_RAND_RESET_I(32);\n    for (int __Vi0 = 0; __Vi0 &lt; 4; ++__Vi0) {\n        vlSelf-&gt;dut_param_mux__DOT____Vcellinp__uut_pmux__inputs[__Vi0] = VL_RAND_RESET_I(32);\n    }\n    vlSelf-&gt;dut_param_mux__DOT__uut_pmux__DOT__selector = VL_RAND_RESET_I(2);\n    for (int __Vi0 = 0; __Vi0 &lt; 4; ++__Vi0) {\n        vlSelf-&gt;dut_param_mux__DOT__uut_pmux__DOT__inputs[__Vi0] = VL_RAND_RESET_I(32);\n    }\n    vlSelf-&gt;dut_param_mux__DOT__uut_pmux__DOT__out = VL_RAND_RESET_I(32);\n    }\n</code></pre>"},{"location":"TitanComms/Vtop______024root____Slow_8cpp/","title":"File Vtop___024root__Slow.cpp","text":"<p>FileList &gt; comms &gt; verilog &gt; tests &gt; sim_build &gt; Vtop___024root__Slow.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"verilated.h\"</code></li> <li><code>#include \"verilated_dpi.h\"</code></li> <li><code>#include \"Vtop__Syms.h\"</code></li> <li><code>#include \"Vtop___024root.h\"</code></li> </ul>"},{"location":"TitanComms/Vtop______024root____Slow_8cpp/#public-functions","title":"Public Functions","text":"Type Name void Vtop___024root___ctor_var_reset (Vtop___024root * vlSelf)"},{"location":"TitanComms/Vtop______024root____Slow_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"TitanComms/Vtop______024root____Slow_8cpp/#function-vtop___024root___ctor_var_reset","title":"function Vtop___024root___ctor_var_reset","text":"<pre><code>void Vtop___024root___ctor_var_reset (\n    Vtop___024root * vlSelf\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>titan/comms/verilog/tests/sim_build/Vtop___024root__Slow.cpp</code></p>"},{"location":"TitanComms/Vtop______024root____Slow_8cpp_source/","title":"File Vtop___024root__Slow.cpp","text":"<p>File List &gt; comms &gt; verilog &gt; tests &gt; sim_build &gt; Vtop___024root__Slow.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// Verilated -*- C++ -*-\n// DESCRIPTION: Verilator output: Design implementation internals\n// See Vtop.h for the primary calling header\n\n#include \"verilated.h\"\n#include \"verilated_dpi.h\"\n\n#include \"Vtop__Syms.h\"\n#include \"Vtop___024root.h\"\n\n// Parameter definitions for Vtop___024root\nconstexpr IData/*31:0*/ Vtop___024root::dut_param_mux__DOT__uut_pmux__DOT__INPUT_WIDTH;\nconstexpr IData/*31:0*/ Vtop___024root::dut_param_mux__DOT__uut_pmux__DOT__SELECTOR_WIDTH;\nconstexpr IData/*31:0*/ Vtop___024root::dut_param_mux__DOT__uut_pmux__DOT__SIGNAL_COUNT;\n\n\nvoid Vtop___024root___ctor_var_reset(Vtop___024root* vlSelf);\n\nVtop___024root::Vtop___024root(Vtop__Syms* symsp, const char* v__name)\n    : VerilatedModule{v__name}\n    , __VdlySched{*symsp-&gt;_vm_contextp__}\n    , vlSymsp{symsp}\n {\n    // Reset structure values\n    Vtop___024root___ctor_var_reset(this);\n}\n\nvoid Vtop___024root::__Vconfigure(bool first) {\n    if (false &amp;&amp; first) {}  // Prevent unused\n}\n\nVtop___024root::~Vtop___024root() {\n}\n</code></pre>"},{"location":"TitanComms/Vtop______024unit_8h/","title":"File Vtop___024unit.h","text":"<p>FileList &gt; comms &gt; verilog &gt; tests &gt; sim_build &gt; Vtop___024unit.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"verilated.h\"</code></li> <li><code>#include \"verilated_timing.h\"</code></li> </ul>"},{"location":"TitanComms/Vtop______024unit_8h/#classes","title":"Classes","text":"Type Name class Vtop___024unit"},{"location":"TitanComms/Vtop______024unit_8h/#public-attributes","title":"Public Attributes","text":"Type Name Vtop__Syms *const vlSymsp"},{"location":"TitanComms/Vtop______024unit_8h/#public-functions","title":"Public Functions","text":"Type Name Vtop___024unit VerilatedModule VL_ATTR_ALIGNED (VL_CACHE_LINE_BYTES)  VL_UNCOPYABLE (Vtop___024unit)  Vtop___024unit (Vtop__Syms * symsp, const char * v__name)  void __Vconfigure (bool first)  ~Vtop___024unit ()"},{"location":"TitanComms/Vtop______024unit_8h/#macros","title":"Macros","text":"Type Name define VERILATED_VTOP___024UNIT_H_"},{"location":"TitanComms/Vtop______024unit_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"TitanComms/Vtop______024unit_8h/#variable-vlsymsp","title":"variable vlSymsp","text":"<pre><code>Vtop__Syms* const vlSymsp;\n</code></pre>"},{"location":"TitanComms/Vtop______024unit_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"TitanComms/Vtop______024unit_8h/#function-vl_attr_aligned","title":"function VL_ATTR_ALIGNED","text":"<pre><code>Vtop___024unit VerilatedModule VL_ATTR_ALIGNED (\n    VL_CACHE_LINE_BYTES\n) \n</code></pre>"},{"location":"TitanComms/Vtop______024unit_8h/#function-vl_uncopyable","title":"function VL_UNCOPYABLE","text":"<pre><code>VL_UNCOPYABLE (\n    Vtop___024unit\n) \n</code></pre>"},{"location":"TitanComms/Vtop______024unit_8h/#function-vtop___024unit","title":"function Vtop___024unit","text":"<pre><code>Vtop___024unit (\n    Vtop__Syms * symsp,\n    const char * v__name\n) \n</code></pre>"},{"location":"TitanComms/Vtop______024unit_8h/#function-__vconfigure","title":"function __Vconfigure","text":"<pre><code>void __Vconfigure (\n    bool first\n) \n</code></pre>"},{"location":"TitanComms/Vtop______024unit_8h/#function-vtop___024unit_1","title":"function ~Vtop___024unit","text":"<pre><code>~Vtop___024unit () \n</code></pre>"},{"location":"TitanComms/Vtop______024unit_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"TitanComms/Vtop______024unit_8h/#define-verilated_vtop___024unit_h_","title":"define VERILATED_VTOP___024UNIT_H_","text":"<pre><code>#define VERILATED_VTOP___024UNIT_H_ \n</code></pre> <p>The documentation for this class was generated from the following file <code>titan/comms/verilog/tests/sim_build/Vtop___024unit.h</code></p>"},{"location":"TitanComms/Vtop______024unit_8h_source/","title":"File Vtop___024unit.h","text":"<p>File List &gt; comms &gt; verilog &gt; tests &gt; sim_build &gt; Vtop___024unit.h</p> <p>Go to the documentation of this file</p> <pre><code>// Verilated -*- C++ -*-\n// DESCRIPTION: Verilator output: Design internal header\n// See Vtop.h for the primary calling header\n\n#ifndef VERILATED_VTOP___024UNIT_H_\n#define VERILATED_VTOP___024UNIT_H_  // guard\n\n#include \"verilated.h\"\n#include \"verilated_timing.h\"\n\nclass Vtop__Syms;\n\nclass Vtop___024unit final : public VerilatedModule {\n  public:\n\n    // INTERNAL VARIABLES\n    Vtop__Syms* const vlSymsp;\n\n    // CONSTRUCTORS\n    Vtop___024unit(Vtop__Syms* symsp, const char* v__name);\n    ~Vtop___024unit();\n    VL_UNCOPYABLE(Vtop___024unit);\n\n    // INTERNAL METHODS\n    void __Vconfigure(bool first);\n} VL_ATTR_ALIGNED(VL_CACHE_LINE_BYTES);\n\n\n#endif  // guard\n</code></pre>"},{"location":"TitanComms/Vtop______024unit____DepSet__hff17caec____0____Slow_8cpp/","title":"File Vtop___024unit__DepSet_hff17caec__0__Slow.cpp","text":"<p>FileList &gt; comms &gt; verilog &gt; tests &gt; sim_build &gt; Vtop___024unit__DepSet_hff17caec__0__Slow.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"verilated.h\"</code></li> <li><code>#include \"verilated_dpi.h\"</code></li> <li><code>#include \"Vtop___024unit.h\"</code></li> </ul>"},{"location":"TitanComms/Vtop______024unit____DepSet__hff17caec____0____Slow_8cpp/#public-functions","title":"Public Functions","text":"Type Name VL_ATTR_COLD void Vtop___024unit___ctor_var_reset (Vtop___024unit * vlSelf)"},{"location":"TitanComms/Vtop______024unit____DepSet__hff17caec____0____Slow_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"TitanComms/Vtop______024unit____DepSet__hff17caec____0____Slow_8cpp/#function-vtop___024unit___ctor_var_reset","title":"function Vtop___024unit___ctor_var_reset","text":"<pre><code>VL_ATTR_COLD void Vtop___024unit___ctor_var_reset (\n    Vtop___024unit * vlSelf\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>titan/comms/verilog/tests/sim_build/Vtop___024unit__DepSet_hff17caec__0__Slow.cpp</code></p>"},{"location":"TitanComms/Vtop______024unit____DepSet__hff17caec____0____Slow_8cpp_source/","title":"File Vtop___024unit__DepSet_hff17caec__0__Slow.cpp","text":"<p>File List &gt; comms &gt; verilog &gt; tests &gt; sim_build &gt; Vtop___024unit__DepSet_hff17caec__0__Slow.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// Verilated -*- C++ -*-\n// DESCRIPTION: Verilator output: Design implementation internals\n// See Vtop.h for the primary calling header\n\n#include \"verilated.h\"\n#include \"verilated_dpi.h\"\n\n#include \"Vtop___024unit.h\"\n\nVL_ATTR_COLD void Vtop___024unit___ctor_var_reset(Vtop___024unit* vlSelf) {\n    if (false &amp;&amp; vlSelf) {}  // Prevent unused\n    Vtop__Syms* const __restrict vlSymsp VL_ATTR_UNUSED = vlSelf-&gt;vlSymsp;\n    VL_DEBUG_IF(VL_DBG_MSGF(\"+        Vtop___024unit___ctor_var_reset\\n\"); );\n}\n</code></pre>"},{"location":"TitanComms/Vtop______024unit____Slow_8cpp/","title":"File Vtop___024unit__Slow.cpp","text":"<p>FileList &gt; comms &gt; verilog &gt; tests &gt; sim_build &gt; Vtop___024unit__Slow.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"verilated.h\"</code></li> <li><code>#include \"verilated_dpi.h\"</code></li> <li><code>#include \"Vtop__Syms.h\"</code></li> <li><code>#include \"Vtop___024unit.h\"</code></li> </ul>"},{"location":"TitanComms/Vtop______024unit____Slow_8cpp/#public-functions","title":"Public Functions","text":"Type Name void Vtop___024unit___ctor_var_reset (Vtop___024unit * vlSelf)"},{"location":"TitanComms/Vtop______024unit____Slow_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"TitanComms/Vtop______024unit____Slow_8cpp/#function-vtop___024unit___ctor_var_reset","title":"function Vtop___024unit___ctor_var_reset","text":"<pre><code>void Vtop___024unit___ctor_var_reset (\n    Vtop___024unit * vlSelf\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>titan/comms/verilog/tests/sim_build/Vtop___024unit__Slow.cpp</code></p>"},{"location":"TitanComms/Vtop______024unit____Slow_8cpp_source/","title":"File Vtop___024unit__Slow.cpp","text":"<p>File List &gt; comms &gt; verilog &gt; tests &gt; sim_build &gt; Vtop___024unit__Slow.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// Verilated -*- C++ -*-\n// DESCRIPTION: Verilator output: Design implementation internals\n// See Vtop.h for the primary calling header\n\n#include \"verilated.h\"\n#include \"verilated_dpi.h\"\n\n#include \"Vtop__Syms.h\"\n#include \"Vtop___024unit.h\"\n\nvoid Vtop___024unit___ctor_var_reset(Vtop___024unit* vlSelf);\n\nVtop___024unit::Vtop___024unit(Vtop__Syms* symsp, const char* v__name)\n    : VerilatedModule{v__name}\n    , vlSymsp{symsp}\n {\n    // Reset structure values\n    Vtop___024unit___ctor_var_reset(this);\n}\n\nvoid Vtop___024unit::__Vconfigure(bool first) {\n    if (false &amp;&amp; first) {}  // Prevent unused\n}\n\nVtop___024unit::~Vtop___024unit() {\n}\n</code></pre>"},{"location":"TitanComms/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p>"},{"location":"TitanComms/classes/","title":"Class Index","text":""},{"location":"TitanComms/classes/#t","title":"t","text":"<ul> <li>TitanComms</li> </ul>"},{"location":"TitanComms/classes/#u","title":"u","text":"<ul> <li>u_int24 (TitanComms)</li> </ul>"},{"location":"TitanComms/classes/#v","title":"v","text":"<ul> <li>VL_NOT_FINAL</li> <li>Vtop___024root</li> <li>Vtop___024unit</li> <li>Vtop__Syms</li> </ul>"},{"location":"TitanComms/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>class TitanComms </li> <li>struct TitanComms::u_int24 </li> <li>class VerilatedModel <ul> <li>class VL_NOT_FINAL </li> </ul> </li> <li>class VerilatedSyms <ul> <li>class Vtop__Syms </li> </ul> </li> <li>class VerilatedModule <ul> <li>class Vtop___024root </li> <li>class Vtop___024unit </li> </ul> </li> </ul>"},{"location":"TitanComms/modules/","title":"Modules","text":"<p>No modules found.</p>"},{"location":"TitanComms/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p>"},{"location":"TitanComms/class_members/","title":"Class Members","text":""},{"location":"TitanComms/class_members/#b","title":"b","text":"<ul> <li>begin (TitanComms)</li> <li>bind_address (TitanComms)</li> </ul>"},{"location":"TitanComms/class_members/#d","title":"d","text":"<ul> <li>data (TitanComms::u_int24)</li> <li>dut_param_mux__DOT____Vcellinp__uut_pmux__inputs (Vtop___024root)</li> <li>dut_param_mux__DOT__in1 (Vtop___024root)</li> <li>dut_param_mux__DOT__in2 (Vtop___024root)</li> <li>dut_param_mux__DOT__in3 (Vtop___024root)</li> <li>dut_param_mux__DOT__in4 (Vtop___024root)</li> <li>dut_param_mux__DOT__mux_o (Vtop___024root)</li> <li>dut_param_mux__DOT__sel_i (Vtop___024root)</li> <li>dut_param_mux__DOT__uut_pmux__DOT__INPUT_WIDTH (Vtop___024root)</li> <li>dut_param_mux__DOT__uut_pmux__DOT__SELECTOR_WIDTH (Vtop___024root)</li> <li>dut_param_mux__DOT__uut_pmux__DOT__SIGNAL_COUNT (Vtop___024root)</li> <li>dut_param_mux__DOT__uut_pmux__DOT__inputs (Vtop___024root)</li> <li>dut_param_mux__DOT__uut_pmux__DOT__out (Vtop___024root)</li> <li>dut_param_mux__DOT__uut_pmux__DOT__selector (Vtop___024root)</li> </ul>"},{"location":"TitanComms/class_members/#e","title":"e","text":"<ul> <li>eval (VL_NOT_FINAL)</li> <li>eval_end_step (VL_NOT_FINAL)</li> <li>eval_step (VL_NOT_FINAL)</li> <li>eventsPending (VL_NOT_FINAL)</li> </ul>"},{"location":"TitanComms/class_members/#f","title":"f","text":"<ul> <li>final (VL_NOT_FINAL)</li> </ul>"},{"location":"TitanComms/class_members/#h","title":"h","text":"<ul> <li>hierName (VL_NOT_FINAL)</li> </ul>"},{"location":"TitanComms/class_members/#i","title":"i","text":"<ul> <li>instruction (TitanComms)</li> <li>in1 (VL_NOT_FINAL)</li> <li>in2 (VL_NOT_FINAL)</li> <li>in3 (VL_NOT_FINAL)</li> <li>in4 (VL_NOT_FINAL)</li> </ul>"},{"location":"TitanComms/class_members/#m","title":"m","text":"<ul> <li>modelName (VL_NOT_FINAL)</li> <li>mux_o (VL_NOT_FINAL)</li> </ul>"},{"location":"TitanComms/class_members/#n","title":"n","text":"<ul> <li>name (VL_NOT_FINAL, Vtop__Syms)</li> <li>nextTimeSlot (VL_NOT_FINAL)</li> </ul>"},{"location":"TitanComms/class_members/#r","title":"r","text":"<ul> <li>read (TitanComms)</li> <li>rootp (VL_NOT_FINAL)</li> </ul>"},{"location":"TitanComms/class_members/#s","title":"s","text":"<ul> <li>set_core_interrupt (TitanComms)</li> <li>set_stream_read_address (TitanComms)</li> <li>set_stream_write_address (TitanComms)</li> <li>stream (TitanComms)</li> <li>sel_i (VL_NOT_FINAL)</li> </ul>"},{"location":"TitanComms/class_members/#t","title":"t","text":"<ul> <li>TitanComms (TitanComms)</li> <li>threads (VL_NOT_FINAL)</li> <li>trace (VL_NOT_FINAL)</li> <li>traceConfig (VL_NOT_FINAL)</li> <li>TOP (Vtop__Syms)</li> </ul>"},{"location":"TitanComms/class_members/#v","title":"v","text":"<ul> <li>VL_UNCOPYABLE (VL_NOT_FINAL, Vtop___024root, Vtop___024unit)</li> <li>Vtop (VL_NOT_FINAL)</li> <li>vlSymsp (VL_NOT_FINAL, Vtop___024root, Vtop___024unit)</li> <li>VL_GUARDED_BY (Vtop__Syms)</li> <li>Vtop__Syms (Vtop__Syms)</li> <li>VL_IN (Vtop___024root)</li> <li>VL_IN8 (Vtop___024root)</li> <li>VL_OUT (Vtop___024root)</li> <li>Vtop___024root (Vtop___024root)</li> <li>Vtop___024unit (Vtop___024unit)</li> </ul>"},{"location":"TitanComms/class_members/#w","title":"w","text":"<ul> <li>write (TitanComms)</li> </ul>"},{"location":"TitanComms/class_members/#_1","title":"~","text":"<ul> <li>~Vtop (VL_NOT_FINAL)</li> <li>~Vtop__Syms (Vtop__Syms)</li> <li>~Vtop___024root (Vtop___024root)</li> <li>~Vtop___024unit (Vtop___024unit)</li> </ul>"},{"location":"TitanComms/class_members/#_","title":"_","text":"<ul> <li>_chip_deselect (TitanComms)</li> <li>_chip_select (TitanComms)</li> <li>_cs_pin (TitanComms)</li> <li>_extract_byte_from_int (TitanComms)</li> <li>_nop_and_read16 (TitanComms)</li> <li>_nop_and_read8 (TitanComms)</li> <li>_repeat (TitanComms)</li> <li>_spi_settings (TitanComms)</li> <li>_xor_checksum (TitanComms)</li> <li>__Vhier (Vtop__Syms)</li> <li>__Vm_activity (Vtop__Syms)</li> <li>__Vm_baseCode (Vtop__Syms)</li> <li>__Vm_didInit (Vtop__Syms)</li> <li>__Vm_dumperMutex (Vtop__Syms)</li> <li>__Vm_dumping (Vtop__Syms)</li> <li>__Vm_modelp (Vtop__Syms)</li> <li>__Vscope_TOP (Vtop__Syms)</li> <li>__Vscope_dut_param_mux (Vtop__Syms)</li> <li>__Vscope_dut_param_mux__uut_pmux (Vtop__Syms)</li> <li>_traceDump (Vtop__Syms)</li> <li>_traceDumpClose (Vtop__Syms)</li> <li>_traceDumpOpen (Vtop__Syms)</li> <li>__VactContinue (Vtop___024root)</li> <li>__VactIterCount (Vtop___024root)</li> <li>__VactTriggered (Vtop___024root)</li> <li>__Vconfigure (Vtop___024root, Vtop___024unit)</li> <li>__VdlySched (Vtop___024root)</li> <li>__VicoIterCount (Vtop___024root)</li> <li>__VicoTriggered (Vtop___024root)</li> <li>__VnbaTriggered (Vtop___024root)</li> <li>__VstlIterCount (Vtop___024root)</li> <li>__VstlTriggered (Vtop___024root)</li> </ul>"},{"location":"TitanComms/class_member_functions/","title":"Class Member Functions","text":""},{"location":"TitanComms/class_member_functions/#b","title":"b","text":"<ul> <li>begin (TitanComms)</li> <li>bind_address (TitanComms)</li> </ul>"},{"location":"TitanComms/class_member_functions/#e","title":"e","text":"<ul> <li>eval (VL_NOT_FINAL)</li> <li>eval_end_step (VL_NOT_FINAL)</li> <li>eval_step (VL_NOT_FINAL)</li> <li>eventsPending (VL_NOT_FINAL)</li> </ul>"},{"location":"TitanComms/class_member_functions/#f","title":"f","text":"<ul> <li>final (VL_NOT_FINAL)</li> </ul>"},{"location":"TitanComms/class_member_functions/#h","title":"h","text":"<ul> <li>hierName (VL_NOT_FINAL)</li> </ul>"},{"location":"TitanComms/class_member_functions/#m","title":"m","text":"<ul> <li>modelName (VL_NOT_FINAL)</li> </ul>"},{"location":"TitanComms/class_member_functions/#n","title":"n","text":"<ul> <li>name (VL_NOT_FINAL, Vtop__Syms)</li> <li>nextTimeSlot (VL_NOT_FINAL)</li> </ul>"},{"location":"TitanComms/class_member_functions/#r","title":"r","text":"<ul> <li>read (TitanComms)</li> </ul>"},{"location":"TitanComms/class_member_functions/#s","title":"s","text":"<ul> <li>set_core_interrupt (TitanComms)</li> <li>set_stream_read_address (TitanComms)</li> <li>set_stream_write_address (TitanComms)</li> <li>stream (TitanComms)</li> </ul>"},{"location":"TitanComms/class_member_functions/#t","title":"t","text":"<ul> <li>TitanComms (TitanComms)</li> <li>threads (VL_NOT_FINAL)</li> <li>trace (VL_NOT_FINAL)</li> <li>traceConfig (VL_NOT_FINAL)</li> </ul>"},{"location":"TitanComms/class_member_functions/#v","title":"v","text":"<ul> <li>VL_UNCOPYABLE (VL_NOT_FINAL, Vtop___024root, Vtop___024unit)</li> <li>Vtop (VL_NOT_FINAL)</li> <li>VL_GUARDED_BY (Vtop__Syms)</li> <li>Vtop__Syms (Vtop__Syms)</li> <li>VL_IN (Vtop___024root)</li> <li>VL_IN8 (Vtop___024root)</li> <li>VL_OUT (Vtop___024root)</li> <li>Vtop___024root (Vtop___024root)</li> <li>Vtop___024unit (Vtop___024unit)</li> </ul>"},{"location":"TitanComms/class_member_functions/#w","title":"w","text":"<ul> <li>write (TitanComms)</li> </ul>"},{"location":"TitanComms/class_member_functions/#_1","title":"~","text":"<ul> <li>~Vtop (VL_NOT_FINAL)</li> <li>~Vtop__Syms (Vtop__Syms)</li> <li>~Vtop___024root (Vtop___024root)</li> <li>~Vtop___024unit (Vtop___024unit)</li> </ul>"},{"location":"TitanComms/class_member_functions/#_","title":"_","text":"<ul> <li>_chip_deselect (TitanComms)</li> <li>_chip_select (TitanComms)</li> <li>_extract_byte_from_int (TitanComms)</li> <li>_nop_and_read16 (TitanComms)</li> <li>_nop_and_read8 (TitanComms)</li> <li>_repeat (TitanComms)</li> <li>_xor_checksum (TitanComms)</li> <li>_traceDump (Vtop__Syms)</li> <li>_traceDumpClose (Vtop__Syms)</li> <li>_traceDumpOpen (Vtop__Syms)</li> <li>__Vconfigure (Vtop___024root, Vtop___024unit)</li> </ul>"},{"location":"TitanComms/class_member_variables/","title":"Class Member Variables","text":""},{"location":"TitanComms/class_member_variables/#d","title":"d","text":"<ul> <li>data (TitanComms::u_int24)</li> <li>dut_param_mux__DOT____Vcellinp__uut_pmux__inputs (Vtop___024root)</li> <li>dut_param_mux__DOT__in1 (Vtop___024root)</li> <li>dut_param_mux__DOT__in2 (Vtop___024root)</li> <li>dut_param_mux__DOT__in3 (Vtop___024root)</li> <li>dut_param_mux__DOT__in4 (Vtop___024root)</li> <li>dut_param_mux__DOT__mux_o (Vtop___024root)</li> <li>dut_param_mux__DOT__sel_i (Vtop___024root)</li> <li>dut_param_mux__DOT__uut_pmux__DOT__INPUT_WIDTH (Vtop___024root)</li> <li>dut_param_mux__DOT__uut_pmux__DOT__SELECTOR_WIDTH (Vtop___024root)</li> <li>dut_param_mux__DOT__uut_pmux__DOT__SIGNAL_COUNT (Vtop___024root)</li> <li>dut_param_mux__DOT__uut_pmux__DOT__inputs (Vtop___024root)</li> <li>dut_param_mux__DOT__uut_pmux__DOT__out (Vtop___024root)</li> <li>dut_param_mux__DOT__uut_pmux__DOT__selector (Vtop___024root)</li> </ul>"},{"location":"TitanComms/class_member_variables/#i","title":"i","text":"<ul> <li>in1 (VL_NOT_FINAL)</li> <li>in2 (VL_NOT_FINAL)</li> <li>in3 (VL_NOT_FINAL)</li> <li>in4 (VL_NOT_FINAL)</li> </ul>"},{"location":"TitanComms/class_member_variables/#m","title":"m","text":"<ul> <li>mux_o (VL_NOT_FINAL)</li> </ul>"},{"location":"TitanComms/class_member_variables/#r","title":"r","text":"<ul> <li>rootp (VL_NOT_FINAL)</li> </ul>"},{"location":"TitanComms/class_member_variables/#s","title":"s","text":"<ul> <li>sel_i (VL_NOT_FINAL)</li> </ul>"},{"location":"TitanComms/class_member_variables/#t","title":"t","text":"<ul> <li>TOP (Vtop__Syms)</li> </ul>"},{"location":"TitanComms/class_member_variables/#v","title":"v","text":"<ul> <li>vlSymsp (VL_NOT_FINAL, Vtop___024root, Vtop___024unit)</li> </ul>"},{"location":"TitanComms/class_member_variables/#_","title":"_","text":"<ul> <li>_cs_pin (TitanComms)</li> <li>_spi_settings (TitanComms)</li> <li>__Vhier (Vtop__Syms)</li> <li>__Vm_activity (Vtop__Syms)</li> <li>__Vm_baseCode (Vtop__Syms)</li> <li>__Vm_didInit (Vtop__Syms)</li> <li>__Vm_dumperMutex (Vtop__Syms)</li> <li>__Vm_dumping (Vtop__Syms)</li> <li>__Vm_modelp (Vtop__Syms)</li> <li>__Vscope_TOP (Vtop__Syms)</li> <li>__Vscope_dut_param_mux (Vtop__Syms)</li> <li>__Vscope_dut_param_mux__uut_pmux (Vtop__Syms)</li> <li>__VactContinue (Vtop___024root)</li> <li>__VactIterCount (Vtop___024root)</li> <li>__VactTriggered (Vtop___024root)</li> <li>__VdlySched (Vtop___024root)</li> <li>__VicoIterCount (Vtop___024root)</li> <li>__VicoTriggered (Vtop___024root)</li> <li>__VnbaTriggered (Vtop___024root)</li> <li>__VstlIterCount (Vtop___024root)</li> <li>__VstlTriggered (Vtop___024root)</li> </ul>"},{"location":"TitanComms/class_member_typedefs/","title":"Class Member Typedefs","text":"<p>Nothing related to Class Member Typedefs found.</p>"},{"location":"TitanComms/class_member_enums/","title":"Class Member Enums","text":""},{"location":"TitanComms/class_member_enums/#i","title":"i","text":"<ul> <li>instruction (TitanComms)</li> </ul>"},{"location":"TitanComms/namespace_members/","title":"Namespace Members","text":"<p>Nothing related to Namespace Members found.</p>"},{"location":"TitanComms/namespace_member_functions/","title":"Namespace Member Functions","text":"<p>Nothing related to Namespace Member Functions found.</p>"},{"location":"TitanComms/namespace_member_variables/","title":"Namespace Member Variables","text":"<p>Nothing related to Namespace Member Variables found.</p>"},{"location":"TitanComms/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":"<p>Nothing related to Namespace Member Typedefs found.</p>"},{"location":"TitanComms/namespace_member_enums/","title":"Namespace Member Enums","text":"<p>Nothing related to Namespace Member Enums found.</p>"},{"location":"TitanComms/functions/","title":"Functions","text":""},{"location":"TitanComms/functions/#e","title":"e","text":"<ul> <li>eval (Vtop.h)</li> <li>eval_end_step (Vtop.h)</li> <li>eval_step (Vtop.h)</li> <li>eventsPending (Vtop.h)</li> </ul>"},{"location":"TitanComms/functions/#f","title":"f","text":"<ul> <li>final (Vtop.h)</li> </ul>"},{"location":"TitanComms/functions/#h","title":"h","text":"<ul> <li>hierName (Vtop.h)</li> </ul>"},{"location":"TitanComms/functions/#m","title":"m","text":"<ul> <li>modelName (Vtop.h)</li> </ul>"},{"location":"TitanComms/functions/#n","title":"n","text":"<ul> <li>name (Vtop.h, Vtop__Syms.h)</li> <li>nextTimeSlot (Vtop.h)</li> </ul>"},{"location":"TitanComms/functions/#t","title":"t","text":"<ul> <li>trace_init (Vtop.cpp)</li> <li>threads (Vtop.h)</li> <li>trace (Vtop.h)</li> <li>traceConfig (Vtop.h)</li> </ul>"},{"location":"TitanComms/functions/#v","title":"v","text":"<ul> <li>Vtop___024root___eval (Vtop.cpp, Vtop___024root__DepSet_heccd7ead__0.cpp)</li> <li>Vtop___024root___eval_final (Vtop.cpp, Vtop___024root__DepSet_heccd7ead__0__Slow.cpp)</li> <li>Vtop___024root___eval_initial (Vtop.cpp, Vtop___024root__DepSet_heccd7ead__0.cpp)</li> <li>Vtop___024root___eval_settle (Vtop.cpp, Vtop___024root__DepSet_heccd7ead__0__Slow.cpp)</li> <li>Vtop___024root___eval_static (Vtop.cpp, Vtop___024root__DepSet_heccd7ead__0__Slow.cpp)</li> <li>Vtop___024root__trace_init_top (Vtop.cpp, Vtop__Trace__0__Slow.cpp)</li> <li>Vtop___024root__trace_register (Vtop.cpp, Vtop__Trace__0__Slow.cpp)</li> <li>VL_ATTR_ALIGNED (Vtop.h, Vtop__Syms.h, Vtop___024root.h, Vtop___024unit.h)</li> <li>VL_UNCOPYABLE (Vtop.h, Vtop___024root.h, Vtop___024unit.h)</li> <li>Vtop (Vtop.h)</li> <li>VL_GUARDED_BY (Vtop__Syms.h)</li> <li>Vtop__Syms (Vtop__Syms.h)</li> <li>Vtop___024root__trace_chg_sub_0 (Vtop__Trace__0.cpp)</li> <li>Vtop___024root__trace_chg_top_0 (Vtop__Trace__0.cpp, Vtop__Trace__0__Slow.cpp)</li> <li>Vtop___024root__trace_cleanup (Vtop__Trace__0.cpp, Vtop__Trace__0__Slow.cpp)</li> <li>Vtop___024root__trace_full_sub_0 (Vtop__Trace__0__Slow.cpp)</li> <li>Vtop___024root__trace_full_top_0 (Vtop__Trace__0__Slow.cpp)</li> <li>Vtop___024root__trace_init_sub__TOP__0 (Vtop__Trace__0__Slow.cpp)</li> <li>VL_IN (Vtop___024root.h)</li> <li>VL_IN8 (Vtop___024root.h)</li> <li>VL_OUT (Vtop___024root.h)</li> <li>Vtop___024root (Vtop___024root.h)</li> <li>Vtop___024root___eval_initial__TOP__0 (Vtop___024root__DepSet_h84412442__0.cpp, Vtop___024root__DepSet_heccd7ead__0.cpp)</li> <li>Vtop___024root___eval_triggers__act (Vtop___024root__DepSet_h84412442__0.cpp, Vtop___024root__DepSet_heccd7ead__0.cpp)</li> <li>Vtop___024root___eval_triggers__ico (Vtop___024root__DepSet_h84412442__0.cpp, Vtop___024root__DepSet_heccd7ead__0.cpp)</li> <li>Vtop___024root___eval_triggers__stl (Vtop___024root__DepSet_h84412442__0__Slow.cpp, Vtop___024root__DepSet_heccd7ead__0__Slow.cpp)</li> <li>Vtop___024root___eval_act (Vtop___024root__DepSet_heccd7ead__0.cpp)</li> <li>Vtop___024root___eval_ico (Vtop___024root__DepSet_heccd7ead__0.cpp)</li> <li>Vtop___024root___eval_nba (Vtop___024root__DepSet_heccd7ead__0.cpp)</li> <li>Vtop___024root___ico_sequent__TOP__0 (Vtop___024root__DepSet_heccd7ead__0.cpp, Vtop___024root__DepSet_heccd7ead__0__Slow.cpp)</li> <li>Vtop___024root___timing_resume (Vtop___024root__DepSet_heccd7ead__0.cpp)</li> <li>Vtop___024root___ctor_var_reset (Vtop___024root__DepSet_heccd7ead__0__Slow.cpp, Vtop___024root__Slow.cpp)</li> <li>Vtop___024root___eval_stl (Vtop___024root__DepSet_heccd7ead__0__Slow.cpp)</li> <li>Vtop___024unit (Vtop___024unit.h)</li> <li>Vtop___024unit___ctor_var_reset (Vtop___024unit__DepSet_hff17caec__0__Slow.cpp, Vtop___024unit__Slow.cpp)</li> </ul>"},{"location":"TitanComms/functions/#_1","title":"~","text":"<ul> <li>~Vtop (Vtop.h)</li> <li>~Vtop__Syms (Vtop__Syms.h)</li> <li>~Vtop___024root (Vtop___024root.h)</li> <li>~Vtop___024unit (Vtop___024unit.h)</li> </ul>"},{"location":"TitanComms/functions/#_","title":"_","text":"<ul> <li>_traceDump (Vtop__Syms.h)</li> <li>_traceDumpClose (Vtop__Syms.h)</li> <li>_traceDumpOpen (Vtop__Syms.h)</li> <li>__Vconfigure (Vtop___024root.h, Vtop___024unit.h)</li> </ul>"},{"location":"TitanComms/macros/","title":"Macros","text":""},{"location":"TitanComms/macros/#d","title":"d","text":"<ul> <li>DEBUG (TitanComms.cpp)</li> <li>DEBUG_PRINT (TitanCommsDebug.h)</li> <li>DEBUG_PRINTLN (TitanCommsDebug.h)</li> <li>DEBUG_PRINTLN_STR (TitanCommsDebug.h)</li> <li>DEBUG_PRINT_BIN (TitanCommsDebug.h)</li> <li>DEBUG_PRINT_HEX (TitanCommsDebug.h)</li> <li>DEBUG_PRINT_INT (TitanCommsDebug.h)</li> <li>DEBUG_PRINT_SIZEOF (TitanCommsDebug.h)</li> <li>DEBUG_PRINT_STR (TitanCommsDebug.h)</li> </ul>"},{"location":"TitanComms/macros/#v","title":"v","text":"<ul> <li>VERILATED_VTOP_H_ (Vtop.h)</li> <li>VL_INCLUDE_OPT (Vtop__ALL.cpp)</li> <li>VERILATED_VTOP__DPI_H_ (Vtop__Dpi.h)</li> <li>VERILATED_VTOP__SYMS_H_ (Vtop__Syms.h)</li> <li>VERILATED_VTOP___024ROOT_H_ (Vtop___024root.h)</li> <li>VERILATED_VTOP___024UNIT_H_ (Vtop___024unit.h)</li> </ul>"},{"location":"TitanComms/variables/","title":"Variables","text":""},{"location":"TitanComms/variables/#d","title":"d","text":"<ul> <li>dut_param_mux__DOT____Vcellinp__uut_pmux__inputs (Vtop___024root.h)</li> <li>dut_param_mux__DOT__in1 (Vtop___024root.h)</li> <li>dut_param_mux__DOT__in2 (Vtop___024root.h)</li> <li>dut_param_mux__DOT__in3 (Vtop___024root.h)</li> <li>dut_param_mux__DOT__in4 (Vtop___024root.h)</li> <li>dut_param_mux__DOT__mux_o (Vtop___024root.h)</li> <li>dut_param_mux__DOT__sel_i (Vtop___024root.h)</li> <li>dut_param_mux__DOT__uut_pmux__DOT__INPUT_WIDTH (Vtop___024root.h)</li> <li>dut_param_mux__DOT__uut_pmux__DOT__SELECTOR_WIDTH (Vtop___024root.h)</li> <li>dut_param_mux__DOT__uut_pmux__DOT__SIGNAL_COUNT (Vtop___024root.h)</li> <li>dut_param_mux__DOT__uut_pmux__DOT__inputs (Vtop___024root.h)</li> <li>dut_param_mux__DOT__uut_pmux__DOT__out (Vtop___024root.h)</li> <li>dut_param_mux__DOT__uut_pmux__DOT__selector (Vtop___024root.h)</li> </ul>"},{"location":"TitanComms/variables/#i","title":"i","text":"<ul> <li>in1 (Vtop.h)</li> <li>in2 (Vtop.h)</li> <li>in3 (Vtop.h)</li> <li>in4 (Vtop.h)</li> </ul>"},{"location":"TitanComms/variables/#m","title":"m","text":"<ul> <li>mux_o (Vtop.h)</li> </ul>"},{"location":"TitanComms/variables/#r","title":"r","text":"<ul> <li>rootp (Vtop.h)</li> </ul>"},{"location":"TitanComms/variables/#s","title":"s","text":"<ul> <li>sel_i (Vtop.h)</li> </ul>"},{"location":"TitanComms/variables/#t","title":"t","text":"<ul> <li>TOP (Vtop__Syms.h)</li> </ul>"},{"location":"TitanComms/variables/#v","title":"v","text":"<ul> <li>vlSymsp (Vtop.h, Vtop___024root.h, Vtop___024unit.h)</li> </ul>"},{"location":"TitanComms/variables/#_","title":"_","text":"<ul> <li>__Vhier (Vtop__Syms.h)</li> <li>__Vm_activity (Vtop__Syms.h)</li> <li>__Vm_baseCode (Vtop__Syms.h)</li> <li>__Vm_didInit (Vtop__Syms.h)</li> <li>__Vm_dumperMutex (Vtop__Syms.h)</li> <li>__Vm_dumping (Vtop__Syms.h)</li> <li>__Vm_modelp (Vtop__Syms.h)</li> <li>__Vscope_TOP (Vtop__Syms.h)</li> <li>__Vscope_dut_param_mux (Vtop__Syms.h)</li> <li>__Vscope_dut_param_mux__uut_pmux (Vtop__Syms.h)</li> <li>__VactContinue (Vtop___024root.h)</li> <li>__VactIterCount (Vtop___024root.h)</li> <li>__VactTriggered (Vtop___024root.h)</li> <li>__VdlySched (Vtop___024root.h)</li> <li>__VicoIterCount (Vtop___024root.h)</li> <li>__VicoTriggered (Vtop___024root.h)</li> <li>__VnbaTriggered (Vtop___024root.h)</li> <li>__VstlIterCount (Vtop___024root.h)</li> <li>__VstlTriggered (Vtop___024root.h)</li> </ul>"},{"location":"TitanComms/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"}]}